From 1b7973037eb871f4ccd8dd94b7bc847095c60a8e Mon Sep 17 00:00:00 2001
From: Anthoine Bourgeois <anthoine.bourgeois@vates.tech>
Date: Thu, 16 Jan 2025 14:09:28 +0100
Subject: [PATCH] libqcow2: build qcow2 library for tapdisk

This commit modify sources from qemu to disable some features
unneeded for tapdisk.

Signed-off-by: Anthoine Bourgeois <anthoine.bourgeois@vates.tech>
---
 .gitignore                                  |   4 +
 Makefile.am                                 |   1 +
 configure.ac                                |   8 +
 include/block/aio.h                         |   9 +-
 include/block/block-common.h                |   4 +-
 include/block/block-global-state.h          |   2 +
 include/block/block_int-common.h            |   2 +-
 include/block/block_int-global-state.h      |  12 +
 include/compiler.h                          |   2 +
 include/crypto/hash.h                       |  20 +-
 include/hw/block/block.h                    |   2 +-
 include/list.h                              |   2 +
 include/qapi/qapi-commands-block-core.h     |   6 +-
 include/qapi/qapi-commands-block.h          |   2 +-
 include/qapi/qapi-events-block-core.h       |   4 +-
 include/qapi/qapi-types-block-core.h        |  76 ++-
 include/qapi/qapi-visit-block-core.h        |   6 +-
 include/qapi/qmp/dispatch.h                 |   2 +-
 include/qcow2.h                             |  22 +-
 include/qemu/atomic.h                       |   2 +-
 include/qemu/bitops.h                       |   9 +-
 include/qemu/config-host.h                  | 495 ++++++++++++++++++++
 include/qemu/hbitmap.h                      |   4 +-
 include/qemu/host-utils.h                   |   6 +-
 include/qemu/main-loop.h                    |  12 +-
 include/qemu/option_int.h                   |   2 +-
 include/qemu/osdep.h                        |   2 +-
 include/qemu/range.h                        |   2 +
 include/qemu/timer.h                        |   6 +-
 include/sysemu/block-backend-common.h       |   4 +-
 include/sysemu/block-backend-global-state.h |   2 +-
 include/sysemu/block-backend-io.h           |   4 +
 qcow2/Makefile.am                           |  21 +
 qcow2/lib/Makefile.am                       | 136 ++++++
 qcow2/lib/block.c                           |  28 +-
 qcow2/lib/block/accounting.c                |   3 +-
 qcow2/lib/block/block-backend.c             | 108 +++--
 qcow2/lib/block/block-gen.c                 |   4 +
 qcow2/lib/block/commit.c                    |   6 +-
 qcow2/lib/block/dirty-bitmap.c              |   2 +-
 qcow2/lib/block/file-posix.c                |  46 +-
 qcow2/lib/block/io.c                        |  60 ++-
 qcow2/lib/block/mirror.c                    |  30 +-
 qcow2/lib/block/qapi.c                      |   6 +-
 qcow2/lib/block/raw-format.c                |   4 +
 qcow2/lib/blockdev.c                        |  26 +-
 qcow2/lib/blockjob.c                        |   6 +-
 qcow2/lib/crypto/hash.c                     |  96 +++-
 qcow2/lib/hw/block/block.c                  |   8 +-
 qcow2/lib/hw/block/hd-geometry.c            |   6 +-
 qcow2/lib/job-qmp.c                         |  14 +-
 qcow2/lib/job.c                             |  14 +-
 qcow2/lib/qapi/qapi-events-block-core.c     |  24 +-
 qcow2/lib/qapi/qapi-events-job.c            |   6 +-
 qcow2/lib/qapi/qapi-types-block-core.c      |  38 +-
 qcow2/lib/qapi/qapi-types-common.c          |   4 +-
 qcow2/lib/qapi/qapi-types-job.c             |   4 +-
 qcow2/lib/qapi/qapi-visit-block-core.c      |  80 +++-
 qcow2/lib/qapi/qapi-visit-common.c          |   2 +-
 qcow2/lib/qapi/qapi-visit-core.c            |  62 +--
 qcow2/lib/qapi/qapi-visit-job.c             |   2 +-
 qcow2/lib/qapi/qmp-dispatch.c               |   2 +
 qcow2/lib/qapi/qobject-input-visitor.c      |   4 +-
 qcow2/lib/qcow2-cache.c                     |  26 +-
 qcow2/lib/qcow2-cluster.c                   |  34 +-
 qcow2/lib/qcow2-refcount.c                  |   7 +-
 qcow2/lib/qcow2-threads.c                   |   4 +-
 qcow2/lib/qcow2.c                           | 186 +++++---
 qcow2/lib/qobject/block-qdict.c             |   2 +
 qcow2/lib/system/cpus.c                     |  44 +-
 qcow2/lib/util/aio-posix.c                  |  20 +-
 qcow2/lib/util/async.c                      |   8 +-
 qcow2/lib/util/bufferiszero.c               |   9 +-
 qcow2/lib/util/cutils.c                     |   6 +-
 qcow2/lib/util/error-report.c               |  19 +-
 qcow2/lib/util/error.c                      |   6 +-
 qcow2/lib/util/hbitmap.c                    |  12 +-
 qcow2/lib/util/host-utils.c                 |   2 +
 qcow2/lib/util/iov.c                        |   6 +-
 qcow2/lib/util/lockcnt.c                    |  22 +-
 qcow2/lib/util/main-loop.c                  |  24 +-
 qcow2/lib/util/memalign.c                   |   9 +-
 qcow2/lib/util/module.c                     |   6 +-
 qcow2/lib/util/osdep.c                      |  22 +-
 qcow2/lib/util/oslib-posix.c                |  32 +-
 qcow2/lib/util/qemu-coroutine-lock.c        |  12 +-
 qcow2/lib/util/qemu-coroutine.c             |   8 +-
 qcow2/lib/util/qemu-option.c                |  12 +-
 qcow2/lib/util/qemu-print.c                 |   6 +-
 qcow2/lib/util/qemu-thread-common.h         |   8 +-
 qcow2/lib/util/qemu-thread-posix.c          |   8 +-
 qcow2/lib/util/qemu-timer.c                 |  25 +-
 qcow2/lib/util/qsp.c                        |  10 +-
 qcow2/lib/util/thread-pool.c                |  10 +-
 qcow2/qemu-img.c                            |  76 +--
 95 files changed, 1765 insertions(+), 504 deletions(-)
 create mode 100644 include/qemu/config-host.h
 create mode 100644 qcow2/Makefile.am
 create mode 100644 qcow2/lib/Makefile.am

diff --git a/.gitignore b/.gitignore
index eb160772..c673495b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,6 +12,7 @@
 *.trs
 .deps
 .libs
+.dirstamp
 cscope.*
 TAGS
 VERSION
@@ -51,6 +52,7 @@ Makefile.in
 /vhd/vhd-util
 /vhd/lib/test/random-copy
 /vhd/lib/test/test-snapshot
+/qcow2/qemu-img
 /tapback/tapback
 /test-driver
 
@@ -73,6 +75,8 @@ Makefile.in
 /vhd/Makefile
 /vhd/lib/Makefile
 /vhd/lib/test/Makefile
+/qcow2/Makefile
+/qcow2/lib/Makefile
 /tapback/Makefile
 mk/config.log
 
diff --git a/Makefile.am b/Makefile.am
index 7133a020..78c56ba3 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -5,6 +5,7 @@
 
 SUBDIRS  = lvm
 SUBDIRS += vhd
+SUBDIRS += qcow2
 SUBDIRS += cpumond
 SUBDIRS += control
 SUBDIRS += drivers
diff --git a/configure.ac b/configure.ac
index a419f8ae..43fc21a6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -29,6 +29,12 @@ AC_CHECK_LIB([uuid], [main],
              [:],
 	     AC_MSG_ERROR([Need uuid-dev]))
 
+PKG_PROG_PKG_CONFIG
+PKG_CHECK_MODULES([GLIB], [glib-2.0])
+PKG_CHECK_MODULES([ZLIB], [zlib])
+PKG_CHECK_MODULES([GNUTLS], [gnutls])
+PKG_CHECK_MODULES([LIBZSTD], [libzstd])
+
 AS_IF([test x$with_libiconv != xno],
       [AC_CHECK_LIB([iconv], [main],
 		    [AC_SUBST([LIBICONV], ["-liconv"])],
@@ -64,6 +70,8 @@ cbt/Makefile
 vhd/Makefile
 vhd/lib/Makefile
 vhd/lib/test/Makefile
+qcow2/Makefile
+qcow2/lib/Makefile
 control/Makefile
 drivers/Makefile
 drivers/crypto/Makefile
diff --git a/include/block/aio.h b/include/block/aio.h
index 4ee81936..3776e8bf 100644
--- a/include/block/aio.h
+++ b/include/block/aio.h
@@ -23,11 +23,15 @@
 #include "qemu/thread.h"
 #include "qemu/timer.h"
 #include "block/graph-lock.h"
-#include "hw/qdev-core.h"
+//#include "hw/qdev-core.h"
 
+typedef struct {
+        bool engaged_in_io;
+} MemReentrancyGuard;
 
 typedef struct BlockAIOCB BlockAIOCB;
 typedef void BlockCompletionFunc(void *opaque, int ret);
+typedef struct AioContext AioContext;
 
 typedef struct AIOCBInfo {
     void (*cancel_async)(BlockAIOCB *acb);
@@ -294,6 +298,7 @@ void aio_bh_schedule_oneshot_full(AioContext *ctx, QEMUBHFunc *cb, void *opaque,
  * A convenience wrapper for aio_bh_schedule_oneshot_full() that uses cb as the
  * name string.
  */
+#define replay_bh_schedule_oneshot_event(ctx, bh, acb) aio_bh_schedule_oneshot(ctx, bh, acb)
 #define aio_bh_schedule_oneshot(ctx, cb, opaque) \
     aio_bh_schedule_oneshot_full((ctx), (cb), (opaque), (stringify(cb)))
 
@@ -691,6 +696,7 @@ void aio_context_destroy(AioContext *ctx);
 /* Used internally, do not call outside AioContext code */
 void aio_context_use_g_source(AioContext *ctx);
 
+#if 0
 /**
  * aio_context_set_poll_params:
  * @ctx: the aio context
@@ -721,3 +727,4 @@ void aio_context_set_aio_params(AioContext *ctx, int64_t max_batch);
 void aio_context_set_thread_pool_params(AioContext *ctx, int64_t min,
                                         int64_t max, Error **errp);
 #endif
+#endif
diff --git a/include/block/block-common.h b/include/block/block-common.h
index 338fe5ff..b07b07e2 100644
--- a/include/block/block-common.h
+++ b/include/block/block-common.h
@@ -125,6 +125,7 @@ typedef struct BlockZoneDescriptor {
     BlockZoneState state;
 } BlockZoneDescriptor;
 
+#if 0
 /*
  * Track write pointers of a zone in bytes.
  */
@@ -132,6 +133,7 @@ typedef struct BlockZoneWps {
     CoMutex colock;
     uint64_t wp[];
 } BlockZoneWps;
+#endif
 
 typedef struct BlockDriverInfo {
     /* in bytes, 0 if irrelevant */
@@ -546,7 +548,7 @@ typedef struct HDGeometry {
  */
 
 char *bdrv_perm_names(uint64_t perm);
-uint64_t bdrv_qapi_perm_to_blk_perm(BlockPermission qapi_perm);
+//uint64_t bdrv_qapi_perm_to_blk_perm(BlockPermission qapi_perm);
 
 void bdrv_init_with_whitelist(void);
 bool bdrv_uses_whitelist(void);
diff --git a/include/block/block-global-state.h b/include/block/block-global-state.h
index bd7cecd1..2e54cf5e 100644
--- a/include/block/block-global-state.h
+++ b/include/block/block-global-state.h
@@ -196,8 +196,10 @@ void bdrv_aio_cancel(BlockAIOCB *acb);
 int bdrv_has_zero_init_1(BlockDriverState *bs);
 int coroutine_mixed_fn GRAPH_RDLOCK bdrv_has_zero_init(BlockDriverState *bs);
 BlockDriverState *bdrv_find_node(const char *node_name);
+#if 0
 BlockDeviceInfoList *bdrv_named_nodes_list(bool flat, Error **errp);
 XDbgBlockGraph * GRAPH_RDLOCK bdrv_get_xdbg_block_graph(Error **errp);
+#endif
 BlockDriverState *bdrv_lookup_bs(const char *device,
                                  const char *node_name,
                                  Error **errp);
diff --git a/include/block/block_int-common.h b/include/block/block_int-common.h
index ebb4e56a..c6d8b950 100644
--- a/include/block/block_int-common.h
+++ b/include/block/block_int-common.h
@@ -1253,7 +1253,7 @@ struct BlockDriverState {
     BdrvBlockStatusCache *block_status_cache;
 
     /* array of write pointers' location of each zone in the zoned device. */
-    BlockZoneWps *wps;
+    //BlockZoneWps *wps;
 };
 
 struct BlockBackendRootState {
diff --git a/include/block/block_int-global-state.h b/include/block/block_int-global-state.h
index eb2d92a2..2d91fb96 100644
--- a/include/block/block_int-global-state.h
+++ b/include/block/block_int-global-state.h
@@ -37,6 +37,7 @@
  * the GS API.
  */
 
+#if 0
 /**
  * stream_start:
  * @job_id: The id of the newly-created job, or %NULL to use the
@@ -72,6 +73,7 @@ void stream_start(const char *job_id, BlockDriverState *bs,
                   BlockdevOnError on_error,
                   const char *filter_node_name,
                   Error **errp);
+#endif
 
 /**
  * commit_start:
@@ -124,6 +126,7 @@ BlockJob *commit_active_start(const char *job_id, BlockDriverState *bs,
                               const char *filter_node_name,
                               BlockCompletionFunc *cb, void *opaque,
                               bool auto_complete, Error **errp);
+#if 0
 /*
  * mirror_start:
  * @job_id: The id of the newly-created job, or %NULL to use the
@@ -201,6 +204,7 @@ BlockJob *backup_job_create(const char *job_id, BlockDriverState *bs,
                             int creation_flags,
                             BlockCompletionFunc *cb, void *opaque,
                             JobTxn *txn, Error **errp);
+#endif
 
 BdrvChild * GRAPH_WRLOCK
 bdrv_root_attach_child(BlockDriverState *child_bs, const char *child_name,
@@ -247,18 +251,24 @@ void bdrv_default_perms(BlockDriverState *bs, BdrvChild *c,
                         uint64_t perm, uint64_t shared,
                         uint64_t *nperm, uint64_t *nshared);
 
+#if 0
 void blk_dev_change_media_cb(BlockBackend *blk, bool load, Error **errp);
+#endif
 bool blk_dev_has_removable_media(BlockBackend *blk);
+#if 0
 void blk_dev_eject_request(BlockBackend *blk, bool force);
+#endif
 bool blk_dev_is_medium_locked(BlockBackend *blk);
 
 void bdrv_restore_dirty_bitmap(BdrvDirtyBitmap *bitmap, HBitmap *backup);
 
+#if 0
 void bdrv_set_monitor_owned(BlockDriverState *bs);
 
 void blockdev_close_all_bdrv_states(void);
 
 BlockDriverState *bds_tree_init(QDict *bs_opts, Error **errp);
+#endif
 
 /**
  * Simple implementation of bdrv_co_create_opts for protocol drivers
@@ -270,6 +280,7 @@ int coroutine_fn bdrv_co_create_opts_simple(BlockDriver *drv,
                                             QemuOpts *opts,
                                             Error **errp);
 
+#if 0
 BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,
                                            const char *name,
                                            BlockDriverState **pbs,
@@ -281,6 +292,7 @@ BdrvDirtyBitmap *block_dirty_bitmap_remove(const char *node, const char *name,
                                            bool release,
                                            BlockDriverState **bitmap_bs,
                                            Error **errp);
+#endif
 
 
 BlockDriverState * GRAPH_RDLOCK
diff --git a/include/compiler.h b/include/compiler.h
index 57ab2367..9ab73c76 100644
--- a/include/compiler.h
+++ b/include/compiler.h
@@ -32,9 +32,11 @@
 #define _BLKTAP_COMPILER_H
 
 #ifdef __GNUC__
+#ifndef likely
 #define likely(_cond)           __builtin_expect(!!(_cond), 1)
 #define unlikely(_cond)         __builtin_expect(!!(_cond), 0)
 #endif
+#endif
 
 #ifndef likely
 #define likely(_cond)           (_cond)
diff --git a/include/crypto/hash.h b/include/crypto/hash.h
index 54d87aa2..1178ad29 100644
--- a/include/crypto/hash.h
+++ b/include/crypto/hash.h
@@ -21,9 +21,27 @@
 #ifndef QCRYPTO_HASH_H
 #define QCRYPTO_HASH_H
 
-#include "qapi/qapi-types-crypto.h"
+//#include "qapi/qapi-types-crypto.h"
 
 /* See also "QCryptoHashAlgorithm" defined in qapi/crypto.json */
+typedef enum QCryptoHashAlgorithm {
+    QCRYPTO_HASH_ALG_MD5 = 0,
+    QCRYPTO_HASH_ALG_SHA1 = 1,
+    QCRYPTO_HASH_ALG_SHA224 = 2,
+    QCRYPTO_HASH_ALG_SHA256 = 3,
+    QCRYPTO_HASH_ALG_SHA384 = 4,
+    QCRYPTO_HASH_ALG_SHA512 = 5,
+    QCRYPTO_HASH_ALG_RIPEMD160 = 6,
+    QCRYPTO_HASH_ALG__MAX = 7,
+} QCryptoHashAlgorithm;
+
+#define QCRYPTO_HASH_DIGEST_LEN_MD5       16
+#define QCRYPTO_HASH_DIGEST_LEN_SHA1      20
+#define QCRYPTO_HASH_DIGEST_LEN_SHA224    28
+#define QCRYPTO_HASH_DIGEST_LEN_SHA256    32
+#define QCRYPTO_HASH_DIGEST_LEN_SHA384    48
+#define QCRYPTO_HASH_DIGEST_LEN_SHA512    64
+#define QCRYPTO_HASH_DIGEST_LEN_RIPEMD160 20
 
 /**
  * qcrypto_hash_supports:
diff --git a/include/hw/block/block.h b/include/hw/block/block.h
index de3946a5..7d533173 100644
--- a/include/hw/block/block.h
+++ b/include/hw/block/block.h
@@ -13,7 +13,7 @@
 
 #include "exec/hwaddr.h"
 #include "qapi/qapi-types-block-core.h"
-#include "hw/qdev-properties-system.h"
+//#include "hw/qdev-properties-system.h"
 
 /* Configuration */
 
diff --git a/include/list.h b/include/list.h
index 01923d91..874e88a3 100644
--- a/include/list.h
+++ b/include/list.h
@@ -211,11 +211,13 @@ list_del_init(struct list_head *node)
 #define container_off(containing_type, member)	\
 	offsetof(containing_type, member)
 
+#ifndef container_of
 #define container_of(member_ptr, containing_type, member)		\
 	 ((containing_type *)						\
 	  ((char *)(member_ptr)						\
 	   - container_off(containing_type, member))			\
 	  + check_types_match(*(member_ptr), ((containing_type *)0)->member))
+#endif
 
 #define list_entry(PTR, TYPE, FIELD)    container_of(PTR, TYPE, FIELD)
 #define list_first_entry(PTR, TYPE, FIELD)              \
diff --git a/include/qapi/qapi-commands-block-core.h b/include/qapi/qapi-commands-block-core.h
index e698e23c..84c2dfa9 100644
--- a/include/qapi/qapi-commands-block-core.h
+++ b/include/qapi/qapi-commands-block-core.h
@@ -14,9 +14,9 @@
 #define QAPI_COMMANDS_BLOCK_CORE_H
 
 #include "qapi-commands-common.h"
-#include "qapi-commands-crypto.h"
-#include "qapi-commands-job.h"
-#include "qapi-commands-sockets.h"
+//#include "qapi-commands-crypto.h"
+//#include "qapi-commands-job.h"
+//#include "qapi-commands-sockets.h"
 #include "qapi-types-block-core.h"
 
 BlockInfoList *qmp_query_block(Error **errp);
diff --git a/include/qapi/qapi-commands-block.h b/include/qapi/qapi-commands-block.h
index 2c1adc60..4f072d47 100644
--- a/include/qapi/qapi-commands-block.h
+++ b/include/qapi/qapi-commands-block.h
@@ -13,7 +13,7 @@
 #ifndef QAPI_COMMANDS_BLOCK_H
 #define QAPI_COMMANDS_BLOCK_H
 
-#include "qapi-commands-block-core.h"
+#include "qapi/qapi-commands-block-core.h"
 #include "qapi-types-block.h"
 
 PRManagerInfoList *qmp_query_pr_managers(Error **errp);
diff --git a/include/qapi/qapi-events-block-core.h b/include/qapi/qapi-events-block-core.h
index 7f12beff..e9830b25 100644
--- a/include/qapi/qapi-events-block-core.h
+++ b/include/qapi/qapi-events-block-core.h
@@ -14,9 +14,9 @@
 #define QAPI_EVENTS_BLOCK_CORE_H
 
 #include "qapi-events-common.h"
-#include "qapi-events-crypto.h"
+//#include "qapi-events-crypto.h"
 #include "qapi-events-job.h"
-#include "qapi-events-sockets.h"
+//#include "qapi-events-sockets.h"
 #include "qapi/util.h"
 #include "qapi-types-block-core.h"
 
diff --git a/include/qapi/qapi-types-block-core.h b/include/qapi/qapi-types-block-core.h
index 26585893..a2c2f2e2 100644
--- a/include/qapi/qapi-types-block-core.h
+++ b/include/qapi/qapi-types-block-core.h
@@ -14,10 +14,10 @@
 #define QAPI_TYPES_BLOCK_CORE_H
 
 #include "qapi/qapi-builtin-types.h"
-#include "qapi-types-common.h"
-#include "qapi-types-crypto.h"
+#include "qapi/qapi-types-common.h"
+//#include "qapi-types-crypto.h"
 #include "qapi-types-job.h"
-#include "qapi-types-sockets.h"
+//#include "qapi-types-sockets.h"
 
 typedef struct SnapshotInfo SnapshotInfo;
 
@@ -41,9 +41,11 @@ typedef struct ImageInfoSpecificFile ImageInfoSpecificFile;
 
 typedef enum ImageInfoSpecificKind {
     IMAGE_INFO_SPECIFIC_KIND_QCOW2,
+#if 0
     IMAGE_INFO_SPECIFIC_KIND_VMDK,
     IMAGE_INFO_SPECIFIC_KIND_LUKS,
     IMAGE_INFO_SPECIFIC_KIND_RBD,
+#endif
     IMAGE_INFO_SPECIFIC_KIND_FILE,
     IMAGE_INFO_SPECIFIC_KIND__MAX,
 } ImageInfoSpecificKind;
@@ -1007,6 +1009,7 @@ struct SnapshotInfo {
 void qapi_free_SnapshotInfo(SnapshotInfo *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(SnapshotInfo, qapi_free_SnapshotInfo)
 
+#if 0
 struct ImageInfoSpecificQCow2EncryptionBase {
     BlockdevQcow2EncryptionFormat format;
 };
@@ -1030,6 +1033,7 @@ static inline ImageInfoSpecificQCow2EncryptionBase *qapi_ImageInfoSpecificQCow2E
 
 void qapi_free_ImageInfoSpecificQCow2Encryption(ImageInfoSpecificQCow2Encryption *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(ImageInfoSpecificQCow2Encryption, qapi_free_ImageInfoSpecificQCow2Encryption)
+#endif
 
 struct Qcow2BitmapInfoList {
     Qcow2BitmapInfoList *next;
@@ -1114,6 +1118,7 @@ struct ImageInfoSpecificQCow2Wrapper {
 void qapi_free_ImageInfoSpecificQCow2Wrapper(ImageInfoSpecificQCow2Wrapper *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(ImageInfoSpecificQCow2Wrapper, qapi_free_ImageInfoSpecificQCow2Wrapper)
 
+#if 0
 struct ImageInfoSpecificVmdkWrapper {
     ImageInfoSpecificVmdk *data;
 };
@@ -1134,6 +1139,7 @@ struct ImageInfoSpecificRbdWrapper {
 
 void qapi_free_ImageInfoSpecificRbdWrapper(ImageInfoSpecificRbdWrapper *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(ImageInfoSpecificRbdWrapper, qapi_free_ImageInfoSpecificRbdWrapper)
+#endif
 
 struct ImageInfoSpecificFileWrapper {
     ImageInfoSpecificFile *data;
@@ -1150,9 +1156,11 @@ struct ImageInfoSpecific {
     ImageInfoSpecificKind type;
     union { /* union tag is @type */
         ImageInfoSpecificQCow2Wrapper qcow2;
+#if 0
         ImageInfoSpecificVmdkWrapper vmdk;
         ImageInfoSpecificLUKSWrapper luks;
         ImageInfoSpecificRbdWrapper rbd;
+#endif
         ImageInfoSpecificFileWrapper file;
     } u;
 };
@@ -2186,6 +2194,7 @@ struct BlockJobChangeOptionsMirror {
 void qapi_free_BlockJobChangeOptionsMirror(BlockJobChangeOptionsMirror *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockJobChangeOptionsMirror, qapi_free_BlockJobChangeOptionsMirror)
 
+#if 0
 struct q_obj_BlockJobChangeOptions_base {
     char *id;
     JobType type;
@@ -2201,6 +2210,7 @@ struct BlockJobChangeOptions {
 
 void qapi_free_BlockJobChangeOptions(BlockJobChangeOptions *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockJobChangeOptions, qapi_free_BlockJobChangeOptions)
+#endif
 
 struct BlockdevCacheOptions {
     bool has_direct;
@@ -2341,6 +2351,7 @@ struct Qcow2OverlapChecks {
 void qapi_free_Qcow2OverlapChecks(Qcow2OverlapChecks *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(Qcow2OverlapChecks, qapi_free_Qcow2OverlapChecks)
 
+#if 0
 struct q_obj_BlockdevQcowEncryption_base {
     BlockdevQcowEncryptionFormat format;
 };
@@ -2385,6 +2396,7 @@ struct BlockdevQcow2Encryption {
 
 void qapi_free_BlockdevQcow2Encryption(BlockdevQcow2Encryption *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevQcow2Encryption, qapi_free_BlockdevQcow2Encryption)
+#endif
 
 struct BlockdevOptionsPreallocate {
     /* Members inherited from BlockdevOptionsGenericFormat: */
@@ -2442,6 +2454,7 @@ static inline BlockdevOptionsGenericCOWFormat *qapi_BlockdevOptionsQcow2_base(co
 void qapi_free_BlockdevOptionsQcow2(BlockdevOptionsQcow2 *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevOptionsQcow2, qapi_free_BlockdevOptionsQcow2)
 
+#if 0
 struct SshHostKeyHash {
     SshHostKeyCheckHashType type;
     char *hash;
@@ -2575,6 +2588,7 @@ struct BlockdevOptionsBlkreplay {
 
 void qapi_free_BlockdevOptionsBlkreplay(BlockdevOptionsBlkreplay *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevOptionsBlkreplay, qapi_free_BlockdevOptionsBlkreplay)
+#endif
 
 struct BlockdevRefList {
     BlockdevRefList *next;
@@ -2598,6 +2612,7 @@ struct BlockdevOptionsQuorum {
 void qapi_free_BlockdevOptionsQuorum(BlockdevOptionsQuorum *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevOptionsQuorum, qapi_free_BlockdevOptionsQuorum)
 
+#if 0
 struct BlockdevOptionsGluster {
     char *volume;
     char *path;
@@ -2609,6 +2624,7 @@ struct BlockdevOptionsGluster {
 
 void qapi_free_BlockdevOptionsGluster(BlockdevOptionsGluster *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevOptionsGluster, qapi_free_BlockdevOptionsGluster)
+#endif
 
 #if defined(CONFIG_BLKIO)
 struct BlockdevOptionsIoUring {
@@ -2683,6 +2699,7 @@ struct BlockdevOptionsIscsi {
 void qapi_free_BlockdevOptionsIscsi(BlockdevOptionsIscsi *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevOptionsIscsi, qapi_free_BlockdevOptionsIscsi)
 
+#if 0
 struct RbdEncryptionOptionsLUKSBase {
     char *key_secret;
 };
@@ -2848,6 +2865,7 @@ struct BlockdevOptionsReplication {
     char *top_id;
 };
 #endif /* defined(CONFIG_REPLICATION) */
+#endif
 
 #if defined(CONFIG_REPLICATION)
 static inline BlockdevOptionsGenericFormat *qapi_BlockdevOptionsReplication_base(const BlockdevOptionsReplication *obj)
@@ -2998,6 +3016,7 @@ static inline BlockdevOptionsCurlBase *qapi_BlockdevOptionsCurlFtps_base(const B
 void qapi_free_BlockdevOptionsCurlFtps(BlockdevOptionsCurlFtps *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevOptionsCurlFtps, qapi_free_BlockdevOptionsCurlFtps)
 
+#if 0
 struct BlockdevOptionsNbd {
     SocketAddress *server;
     char *export;
@@ -3012,6 +3031,7 @@ struct BlockdevOptionsNbd {
 
 void qapi_free_BlockdevOptionsNbd(BlockdevOptionsNbd *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevOptionsNbd, qapi_free_BlockdevOptionsNbd)
+#endif
 
 struct BlockdevOptionsRaw {
     /* Members inherited from BlockdevOptionsGenericFormat: */
@@ -3105,26 +3125,31 @@ struct BlockdevOptions {
     bool has_detect_zeroes;
     BlockdevDetectZeroesOptions detect_zeroes;
     union { /* union tag is @driver */
-        BlockdevOptionsBlkdebug blkdebug;
-        BlockdevOptionsBlklogwrites blklogwrites;
-        BlockdevOptionsBlkverify blkverify;
-        BlockdevOptionsBlkreplay blkreplay;
-        BlockdevOptionsGenericFormat bochs;
-        BlockdevOptionsGenericFormat cloop;
-        BlockdevOptionsGenericFormat compress;
-        BlockdevOptionsCbw copy_before_write;
-        BlockdevOptionsCor copy_on_read;
-        BlockdevOptionsGenericFormat dmg;
+#if 0
+        //BlockdevOptionsBlkdebug blkdebug;
+        //BlockdevOptionsBlklogwrites blklogwrites;
+        //BlockdevOptionsBlkverify blkverify;
+        //BlockdevOptionsBlkreplay blkreplay;
+        //BlockdevOptionsGenericFormat bochs;
+        //BlockdevOptionsGenericFormat cloop;
+        //BlockdevOptionsGenericFormat compress;
+        //BlockdevOptionsCbw copy_before_write;
+        //BlockdevOptionsCor copy_on_read;
+        //BlockdevOptionsGenericFormat dmg;
+#endif
         BlockdevOptionsFile file;
-        BlockdevOptionsCurlFtp ftp;
-        BlockdevOptionsCurlFtps ftps;
-        BlockdevOptionsGluster gluster;
+#if 0
+        //BlockdevOptionsCurlFtp ftp;
+        //BlockdevOptionsCurlFtps ftps;
+        //BlockdevOptionsGluster gluster;
+#endif
 #if defined(HAVE_HOST_BLOCK_DEVICE)
         BlockdevOptionsFile host_cdrom;
 #endif /* defined(HAVE_HOST_BLOCK_DEVICE) */
 #if defined(HAVE_HOST_BLOCK_DEVICE)
         BlockdevOptionsFile host_device;
 #endif /* defined(HAVE_HOST_BLOCK_DEVICE) */
+#if 0
         BlockdevOptionsCurlHttp http;
         BlockdevOptionsCurlHttps https;
 #if defined(CONFIG_BLKIO)
@@ -3141,8 +3166,10 @@ struct BlockdevOptions {
         BlockdevOptionsNvmeIoUring nvme_io_uring;
 #endif /* defined(CONFIG_BLKIO) */
         BlockdevOptionsGenericFormat parallels;
+#endif
         BlockdevOptionsPreallocate preallocate;
         BlockdevOptionsQcow2 qcow2;
+#if 0
         BlockdevOptionsQcow qcow;
         BlockdevOptionsGenericCOWFormat qed;
         BlockdevOptionsQuorum quorum;
@@ -3168,6 +3195,7 @@ struct BlockdevOptions {
         BlockdevOptionsGenericCOWFormat vmdk;
         BlockdevOptionsGenericFormat vpc;
         BlockdevOptionsVVFAT vvfat;
+#endif
     } u;
 };
 
@@ -3227,6 +3255,7 @@ struct BlockdevCreateOptionsFile {
 void qapi_free_BlockdevCreateOptionsFile(BlockdevCreateOptionsFile *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevCreateOptionsFile, qapi_free_BlockdevCreateOptionsFile)
 
+#if 0
 struct BlockdevCreateOptionsGluster {
     BlockdevOptionsGluster *location;
     uint64_t size;
@@ -3295,6 +3324,7 @@ struct BlockdevCreateOptionsQcow {
 
 void qapi_free_BlockdevCreateOptionsQcow(BlockdevCreateOptionsQcow *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevCreateOptionsQcow, qapi_free_BlockdevCreateOptionsQcow)
+#endif
 
 struct BlockdevCreateOptionsQcow2 {
     BlockdevRef *file;
@@ -3309,7 +3339,7 @@ struct BlockdevCreateOptionsQcow2 {
     char *backing_file;
     bool has_backing_fmt;
     BlockdevDriver backing_fmt;
-    QCryptoBlockCreateOptions *encrypt;
+    //QCryptoBlockCreateOptions *encrypt;
     bool has_cluster_size;
     uint64_t cluster_size;
     bool has_preallocation;
@@ -3424,12 +3454,15 @@ struct BlockdevCreateOptions {
     BlockdevDriver driver;
     union { /* union tag is @driver */
         BlockdevCreateOptionsFile file;
+#if 0
         BlockdevCreateOptionsGluster gluster;
         BlockdevCreateOptionsLUKS luks;
         BlockdevCreateOptionsNfs nfs;
         BlockdevCreateOptionsParallels parallels;
         BlockdevCreateOptionsQcow qcow;
+#endif
         BlockdevCreateOptionsQcow2 qcow2;
+#if 0
         BlockdevCreateOptionsQed qed;
         BlockdevCreateOptionsRbd rbd;
         BlockdevCreateOptionsSsh ssh;
@@ -3437,6 +3470,7 @@ struct BlockdevCreateOptions {
         BlockdevCreateOptionsVhdx vhdx;
         BlockdevCreateOptionsVmdk vmdk;
         BlockdevCreateOptionsVpc vpc;
+#endif
     } u;
 };
 
@@ -3448,6 +3482,7 @@ struct q_obj_blockdev_create_arg {
     BlockdevCreateOptions *options;
 };
 
+#if 0
 struct BlockdevAmendOptionsLUKS {
     /* Members inherited from QCryptoBlockAmendOptionsLUKS: */
     QCryptoBlockLUKSKeyslotState state;
@@ -3468,9 +3503,10 @@ static inline QCryptoBlockAmendOptionsLUKS *qapi_BlockdevAmendOptionsLUKS_base(c
 
 void qapi_free_BlockdevAmendOptionsLUKS(BlockdevAmendOptionsLUKS *obj);
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(BlockdevAmendOptionsLUKS, qapi_free_BlockdevAmendOptionsLUKS)
+#endif
 
 struct BlockdevAmendOptionsQcow2 {
-    QCryptoBlockAmendOptions *encrypt;
+    //QCryptoBlockAmendOptions *encrypt;
 };
 
 void qapi_free_BlockdevAmendOptionsQcow2(BlockdevAmendOptionsQcow2 *obj);
@@ -3483,7 +3519,7 @@ struct q_obj_BlockdevAmendOptions_base {
 struct BlockdevAmendOptions {
     BlockdevDriver driver;
     union { /* union tag is @driver */
-        BlockdevAmendOptionsLUKS luks;
+        //BlockdevAmendOptionsLUKS luks;
         BlockdevAmendOptionsQcow2 qcow2;
     } u;
 };
@@ -3573,12 +3609,14 @@ struct q_obj_x_blockdev_change_arg {
     char *node;
 };
 
+#if 0
 struct q_obj_x_blockdev_set_iothread_arg {
     char *node_name;
     StrOrNull *iothread;
     bool has_force;
     bool force;
 };
+#endif
 
 struct q_obj_QUORUM_FAILURE_arg {
     char *reference;
diff --git a/include/qapi/qapi-visit-block-core.h b/include/qapi/qapi-visit-block-core.h
index 9462b281..e689a244 100644
--- a/include/qapi/qapi-visit-block-core.h
+++ b/include/qapi/qapi-visit-block-core.h
@@ -17,9 +17,9 @@
 #include "qapi-types-block-core.h"
 
 #include "qapi-visit-common.h"
-#include "qapi-visit-crypto.h"
-#include "qapi-visit-job.h"
-#include "qapi-visit-sockets.h"
+//#include "qapi-visit-crypto.h"
+#include "qapi/qapi-visit-job.h"
+//#include "qapi-visit-sockets.h"
 
 bool visit_type_SnapshotInfo_members(Visitor *v, SnapshotInfo *obj, Error **errp);
 
diff --git a/include/qapi/qmp/dispatch.h b/include/qapi/qmp/dispatch.h
index f2e95681..0a0c8361 100644
--- a/include/qapi/qmp/dispatch.h
+++ b/include/qapi/qmp/dispatch.h
@@ -14,7 +14,7 @@
 #ifndef QAPI_QMP_DISPATCH_H
 #define QAPI_QMP_DISPATCH_H
 
-#include "monitor/monitor.h"
+//#include "monitor/monitor.h"
 #include "qemu/queue.h"
 
 typedef void (QmpCommandFunc)(QDict *, QObject **, Error **);
diff --git a/include/qcow2.h b/include/qcow2.h
index a9e3481c..5d606fc9 100644
--- a/include/qcow2.h
+++ b/include/qcow2.h
@@ -25,7 +25,7 @@
 #ifndef BLOCK_QCOW2_H
 #define BLOCK_QCOW2_H
 
-#include "crypto/block.h"
+//#include "crypto/block.h"
 #include "qemu/coroutine.h"
 #include "qemu/units.h"
 #include "block/block_int.h"
@@ -231,10 +231,12 @@ typedef struct QCowSnapshot {
 struct Qcow2Cache;
 typedef struct Qcow2Cache Qcow2Cache;
 
+#if 0
 typedef struct Qcow2CryptoHeaderExtension {
     uint64_t offset;
     uint64_t length;
 } QEMU_PACKED Qcow2CryptoHeaderExtension;
+#endif
 
 typedef struct Qcow2UnknownHeaderExtension {
     uint32_t magic;
@@ -359,12 +361,12 @@ typedef struct BDRVQcow2State {
 
     CoMutex lock;
 
-    Qcow2CryptoHeaderExtension crypto_header; /* QCow2 header extension */
-    QCryptoBlockOpenOptions *crypto_opts; /* Disk encryption runtime options */
-    QCryptoBlock *crypto; /* Disk encryption format driver */
-    bool crypt_physical_offset; /* Whether to use virtual or physical offset
-                                   for encryption initialization vector tweak */
-    uint32_t crypt_method_header;
+    //Qcow2CryptoHeaderExtension crypto_header; /* QCow2 header extension */
+    //QCryptoBlockOpenOptions *crypto_opts; /* Disk encryption runtime options */
+    //QCryptoBlock *crypto; /* Disk encryption format driver */
+    //bool crypt_physical_offset; /* Whether to use virtual or physical offset
+    //                               for encryption initialization vector tweak */
+    //uint32_t crypt_method_header;
     uint64_t snapshots_offset;
     int snapshots_size;
     unsigned int nb_snapshots;
@@ -892,9 +894,11 @@ int coroutine_fn qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *re
 
 void GRAPH_RDLOCK qcow2_process_discards(BlockDriverState *bs, int ret);
 
+#if 0
 int GRAPH_RDLOCK
 qcow2_check_metadata_overlap(BlockDriverState *bs, int ign, int64_t offset,
                              int64_t size);
+#endif
 int GRAPH_RDLOCK
 qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,
                               int64_t size, bool data_file);
@@ -924,9 +928,11 @@ int coroutine_fn GRAPH_RDLOCK
 qcow2_shrink_l1_table(BlockDriverState *bs, uint64_t max_size);
 
 int GRAPH_RDLOCK qcow2_write_l1_entry(BlockDriverState *bs, int l1_index);
+#if 0
 int qcow2_encrypt_sectors(BDRVQcow2State *s, int64_t sector_num,
                           uint8_t *buf, int nb_sectors, bool enc, Error **errp);
 
+#endif
 int GRAPH_RDLOCK
 qcow2_get_host_offset(BlockDriverState *bs, uint64_t offset,
                       unsigned int *bytes, uint64_t *host_offset,
@@ -1064,11 +1070,13 @@ qcow2_co_compress(BlockDriverState *bs, void *dest, size_t dest_size,
 ssize_t coroutine_fn
 qcow2_co_decompress(BlockDriverState *bs, void *dest, size_t dest_size,
                     const void *src, size_t src_size);
+#if 0
 int coroutine_fn
 qcow2_co_encrypt(BlockDriverState *bs, uint64_t host_offset,
                  uint64_t guest_offset, void *buf, size_t len);
 int coroutine_fn
 qcow2_co_decrypt(BlockDriverState *bs, uint64_t host_offset,
                  uint64_t guest_offset, void *buf, size_t len);
+#endif
 
 #endif
diff --git a/include/qemu/atomic.h b/include/qemu/atomic.h
index 7a3f2e65..9e392dcd 100644
--- a/include/qemu/atomic.h
+++ b/include/qemu/atomic.h
@@ -15,7 +15,7 @@
 #ifndef QEMU_ATOMIC_H
 #define QEMU_ATOMIC_H
 
-#include "compiler.h"
+#include "qemu/compiler.h"
 
 /* Compiler barrier */
 #define barrier()   ({ asm volatile("" ::: "memory"); (void)0; })
diff --git a/include/qemu/bitops.h b/include/qemu/bitops.h
index 2c0a2fe7..df735fa7 100644
--- a/include/qemu/bitops.h
+++ b/include/qemu/bitops.h
@@ -12,9 +12,8 @@
 #ifndef BITOPS_H
 #define BITOPS_H
 
-
-#include "host-utils.h"
-#include "atomic.h"
+#include "qemu/host-utils.h"
+#include "qemu/atomic.h"
 
 #define BITS_PER_BYTE           CHAR_BIT
 #define BITS_PER_LONG           (sizeof (unsigned long) * BITS_PER_BYTE)
@@ -41,6 +40,7 @@ static inline void set_bit(long nr, unsigned long *addr)
     *p  |= mask;
 }
 
+#if 0
 /**
  * set_bit_atomic - Set a bit in memory atomically
  * @nr: the bit to set
@@ -53,6 +53,7 @@ static inline void set_bit_atomic(long nr, unsigned long *addr)
 
     qatomic_or(p, mask);
 }
+#endif
 
 /**
  * clear_bit - Clears a bit in memory
@@ -67,6 +68,7 @@ static inline void clear_bit(long nr, unsigned long *addr)
     *p &= ~mask;
 }
 
+#if 0
 /**
  * clear_bit_atomic - Clears a bit in memory atomically
  * @nr: Bit to clear
@@ -79,6 +81,7 @@ static inline void clear_bit_atomic(long nr, unsigned long *addr)
 
     return qatomic_and(p, ~mask);
 }
+#endif
 
 /**
  * change_bit - Toggle a bit in memory
diff --git a/include/qemu/config-host.h b/include/qemu/config-host.h
new file mode 100644
index 00000000..feb0f0ed
--- /dev/null
+++ b/include/qemu/config-host.h
@@ -0,0 +1,495 @@
+/*
+ * Autogenerated by the Meson build system.
+ * Do not edit, your changes will be lost.
+ */
+
+#pragma once
+
+#define CONFIG_ACCEPT4
+
+#undef CONFIG_AF_ALG
+
+#define CONFIG_AF_VSOCK
+
+#undef CONFIG_AF_XDP
+
+#undef CONFIG_ALIGNED_MALLOC
+
+#undef CONFIG_ARM_AES_BUILTIN
+
+#define CONFIG_ASAN_IFACE_FIBER
+
+#undef CONFIG_ASM_HWPROBE_H
+
+#undef CONFIG_ATOMIC128
+
+#undef CONFIG_ATOMIC128_OPT
+
+#define CONFIG_ATOMIC64
+
+#define CONFIG_ATTR
+
+#define CONFIG_AUDIO_ALSA
+
+#undef CONFIG_AUDIO_COREAUDIO
+
+#define CONFIG_AUDIO_DRIVERS "pa", "oss", 
+
+#undef CONFIG_AUDIO_DSOUND
+
+#undef CONFIG_AUDIO_JACK
+
+#define CONFIG_AUDIO_OSS
+
+#define CONFIG_AUDIO_PA
+
+#define CONFIG_AUDIO_PIPEWIRE
+
+#define CONFIG_AUDIO_SDL
+
+#undef CONFIG_AUDIO_SNDIO
+
+#define CONFIG_AVX2_OPT
+
+#define CONFIG_AVX512BW_OPT
+
+#define CONFIG_BDRV_RO_WHITELIST 
+
+#define CONFIG_BDRV_RW_WHITELIST 
+
+#undef CONFIG_BDRV_WHITELIST_TOOLS
+
+#define CONFIG_BINDIR "/usr/local/bin"
+
+#undef CONFIG_BLKIO
+
+//#define CONFIG_BLKZONED
+
+#undef CONFIG_BRLAPI
+
+#undef CONFIG_BSD
+
+#define CONFIG_CAPSTONE
+
+#undef CONFIG_CFI
+
+#define CONFIG_CLOCK_ADJTIME
+
+#define CONFIG_CLOSE_RANGE
+
+#define CONFIG_CMPXCHG128
+
+#undef CONFIG_COCOA
+
+#define CONFIG_COROUTINE_POOL
+
+#define CONFIG_CPUID_H
+
+#undef CONFIG_CRYPTO_SM4
+
+#define CONFIG_CURL
+
+#define CONFIG_CURSES
+
+#undef CONFIG_DARWIN
+
+#define CONFIG_DBUS_DISPLAY
+
+#define CONFIG_DEBUG_GRAPH_LOCK
+
+#define CONFIG_DEBUG_MUTEX
+
+#undef CONFIG_DEBUG_REMAP
+
+#undef CONFIG_DEBUG_STACK_USAGE
+
+//#define CONFIG_DEBUG_TCG
+
+#define CONFIG_DUP3
+
+#undef CONFIG_EBPF
+
+#undef CONFIG_ELF_AUX_INFO
+
+#define CONFIG_EPOLL
+
+#define CONFIG_EPOLL_CREATE1
+
+#define CONFIG_EVENTFD
+
+#define CONFIG_FALLOCATE
+
+#define CONFIG_FALLOCATE_PUNCH_HOLE
+
+#define CONFIG_FALLOCATE_ZERO_RANGE
+
+#define CONFIG_FDATASYNC
+
+#define CONFIG_FDT
+
+#define CONFIG_FIEMAP
+
+#undef CONFIG_FREEBSD
+
+#define CONFIG_FSFREEZE
+
+#define CONFIG_FSTRIM
+
+#define CONFIG_FUSE
+
+#define CONFIG_FUSE_LSEEK
+
+#undef CONFIG_FUZZ
+
+#define CONFIG_GBM
+
+#undef CONFIG_GCOV
+
+#undef CONFIG_GCRYPT
+
+#define CONFIG_GETAUXVAL
+
+#define CONFIG_GETCPU
+
+#define CONFIG_GETRANDOM
+
+#define CONFIG_GETTID
+
+#define CONFIG_GIO
+
+#undef CONFIG_GLUSTERFS
+
+#define CONFIG_GNUTLS
+
+#define CONFIG_GNUTLS_CRYPTO
+
+#define CONFIG_GTK
+
+#undef CONFIG_GTK_CLIPBOARD
+
+#define CONFIG_HEXAGON_IDEF_PARSER
+
+#undef CONFIG_HOGWEED
+
+#define CONFIG_HOST_DSOSUF ".so"
+
+#define CONFIG_IASL "/usr/bin/iasl"
+
+#define CONFIG_INOTIFY
+
+#define CONFIG_INOTIFY1
+
+#define CONFIG_INT128
+
+#define CONFIG_INT128_TYPE
+
+#define CONFIG_IOVEC
+
+#define CONFIG_KEYUTILS
+
+#define CONFIG_KVM_TARGETS "i386-softmmu" ,"x86_64-softmmu"
+
+#define CONFIG_L2TPV3
+
+#undef CONFIG_LIBATTR
+
+#define CONFIG_LIBCAP_NG
+
+#undef CONFIG_LIBDAXCTL
+
+#define CONFIG_LIBDW
+
+#undef CONFIG_LIBISCSI
+
+#undef CONFIG_LIBNFS
+
+#undef CONFIG_LIBPMEM
+
+#undef CONFIG_LIBSSH
+
+#define CONFIG_LIBUDEV
+
+#define CONFIG_LINUX
+
+#define CONFIG_LINUX_AIO
+
+#undef CONFIG_LINUX_IO_URING
+
+#define CONFIG_LINUX_MAGIC_H
+
+#define CONFIG_LZO
+
+#define CONFIG_MADVISE
+
+#define CONFIG_MALLOC_TRIM
+
+#define CONFIG_MEMALIGN
+
+#undef CONFIG_MEMBARRIER
+
+#define CONFIG_MEMFD
+
+#undef CONFIG_MODULES
+
+#undef CONFIG_MODULE_UPGRADES
+
+#undef CONFIG_MPATH
+
+#undef CONFIG_NETMAP
+
+#undef CONFIG_NETTLE
+
+#undef CONFIG_NUMA
+
+#define CONFIG_OPENGL
+
+#define CONFIG_OPEN_BY_HANDLE
+
+#define CONFIG_PIXMAN
+
+#define CONFIG_PLUGIN
+
+#define CONFIG_PNG
+
+#define CONFIG_POSIX
+
+#define CONFIG_POSIX_FALLOCATE
+
+#define CONFIG_POSIX_MADVISE
+
+#define CONFIG_POSIX_MEMALIGN
+
+#define CONFIG_PPOLL
+
+#define CONFIG_PRCTL_PR_SET_TIMERSLACK
+
+#define CONFIG_PREADV
+
+#define CONFIG_PREFIX "/usr/local"
+
+#define CONFIG_PTHREAD_AFFINITY_NP
+
+#undef CONFIG_PTHREAD_CONDATTR_SETCLOCK
+
+#undef CONFIG_PTHREAD_FCHDIR_NP
+
+#undef CONFIG_PTHREAD_SETNAME_NP_WO_TID
+
+#define CONFIG_PTHREAD_SETNAME_NP_W_TID
+
+#undef CONFIG_PTHREAD_SET_NAME_NP
+
+#define CONFIG_QEMU_CONFDIR "/usr/local/etc/qemu"
+
+#define CONFIG_QEMU_DATADIR "/usr/local/share/qemu"
+
+#define CONFIG_QEMU_DESKTOPDIR "/usr/local/share/applications"
+
+#define CONFIG_QEMU_FIRMWAREPATH "/usr/local/share/qemu-firmware", 
+
+#define CONFIG_QEMU_HELPERDIR "/usr/local/libexec"
+
+#define CONFIG_QEMU_ICONDIR "/usr/local/share/icons"
+
+#define CONFIG_QEMU_LOCALEDIR "/usr/local/share/locale"
+
+#define CONFIG_QEMU_LOCALSTATEDIR "/var/local"
+
+#define CONFIG_QEMU_MODDIR "/usr/local/lib64/qemu"
+
+#undef CONFIG_QEMU_PRIVATE_XTS
+
+#define CONFIG_QOM_CAST_DEBUG
+
+#undef CONFIG_QPL
+
+#undef CONFIG_RBD
+
+#undef CONFIG_RDMA
+
+#define CONFIG_RELOCATABLE
+
+#define CONFIG_REPLICATION
+
+#define CONFIG_RTNETLINK
+
+#undef CONFIG_SAFESTACK
+
+#undef CONFIG_SCHED_GETCPU
+
+#define CONFIG_SDL
+
+#undef CONFIG_SDL_IMAGE
+
+#define CONFIG_SECCOMP
+
+#define CONFIG_SECCOMP_SYSRAWRC
+
+#define CONFIG_SECRET_KEYRING
+
+#undef CONFIG_SELINUX
+
+#define CONFIG_SENDFILE
+
+#define CONFIG_SETNS
+
+#define CONFIG_SIGNALFD
+
+#define CONFIG_SLIRP
+
+#define CONFIG_SMBD_COMMAND "/usr/sbin/smbd"
+
+#define CONFIG_SNAPPY
+
+#undef CONFIG_SOLARIS
+
+#undef CONFIG_SPICE
+
+#undef CONFIG_SPICE_PROTOCOL
+
+#define CONFIG_SPLICE
+
+#define CONFIG_STATX
+
+#define CONFIG_STATX_MNT_ID
+
+#define CONFIG_SYNCFS
+
+#define CONFIG_SYNC_FILE_RANGE
+
+#define CONFIG_SYSCONFDIR "/usr/local/etc"
+
+#define CONFIG_SYSMACROS
+
+#define CONFIG_TASN1
+
+//#define CONFIG_TCG 1
+
+//#undef CONFIG_TCG_INTERPRETER
+
+#define CONFIG_TIMERFD
+
+#define CONFIG_TLS_PRIORITY "NORMAL"
+
+#define CONFIG_TPM
+
+#define CONFIG_TRACE_FILE "trace"
+
+#define CONFIG_TRACE_LOG
+
+#undef CONFIG_TSAN
+
+#undef CONFIG_UADK
+
+#undef CONFIG_USBFS
+
+#define CONFIG_USB_LIBUSB
+
+//#define CONFIG_VALGRIND_H
+
+#define CONFIG_VALLOC
+
+#undef CONFIG_VDE
+
+#define CONFIG_VDUSE_BLK_EXPORT
+
+#define CONFIG_VHOST
+
+#define CONFIG_VHOST_CRYPTO
+
+#define CONFIG_VHOST_KERNEL
+
+#define CONFIG_VHOST_NET
+
+#define CONFIG_VHOST_NET_USER
+
+#define CONFIG_VHOST_NET_VDPA
+
+#define CONFIG_VHOST_USER
+
+#define CONFIG_VHOST_USER_BLK_SERVER
+
+#define CONFIG_VHOST_VDPA
+
+#define CONFIG_VIRTFS
+
+#undef CONFIG_VMNET
+
+#define CONFIG_VNC
+
+#define CONFIG_VNC_JPEG
+
+#define CONFIG_VNC_SASL
+
+#define CONFIG_VTE
+
+#undef CONFIG_WIN32
+
+#define CONFIG_X11
+
+#define CONFIG_XEN_BACKEND
+
+#define CONFIG_XEN_CTRL_INTERFACE_VERSION 41700
+
+#define CONFIG_XKBCOMMON
+
+#define CONFIG_ZSTD
+
+#define HAVE_BLK_ZONE_REP_CAPACITY
+
+#undef HAVE_BROKEN_SIZE_MAX
+
+#define HAVE_BTRFS_H
+
+#define HAVE_COPY_FILE_RANGE
+
+#define HAVE_DRM_H
+
+#define HAVE_FSXATTR
+
+#define HAVE_GETIFADDRS
+
+#undef HAVE_GLIB_WITH_SLICE_ALLOCATOR
+
+#define HAVE_HOST_BLOCK_DEVICE
+
+#define HAVE_IPPROTO_MPTCP
+
+#undef HAVE_MADVISE_WITHOUT_PROTOTYPE
+
+#define HAVE_MLOCKALL
+
+#define HAVE_OPENPTY
+
+#undef HAVE_OPTRESET
+
+#define HAVE_PTY_H
+
+#undef HAVE_SIGEV_NOTIFY_THREAD_ID
+
+#define HAVE_STRCHRNUL
+
+#define HAVE_STRUCT_STAT_ST_ATIM
+
+#define HAVE_SYSTEM_FUNCTION
+
+#undef HAVE_SYS_DISK_H
+
+#undef HAVE_SYS_IOCCOM_H
+
+#undef HAVE_SYS_KCOV_H
+
+#define HAVE_UTMPX
+
+#undef HAVE_VSS_SDK
+
+#define HOST_X86_64 1
+
+#define QEMU_VERSION "9.1.1"
+
+#define QEMU_VERSION_MAJOR 9
+
+#define QEMU_VERSION_MICRO 1
+
+#define QEMU_VERSION_MINOR 1
+
diff --git a/include/qemu/hbitmap.h b/include/qemu/hbitmap.h
index 8136e336..ef8eb355 100644
--- a/include/qemu/hbitmap.h
+++ b/include/qemu/hbitmap.h
@@ -12,8 +12,8 @@
 #ifndef HBITMAP_H
 #define HBITMAP_H
 
-#include "bitops.h"
-#include "host-utils.h"
+#include "qemu/bitops.h"
+#include "qemu/host-utils.h"
 
 typedef struct HBitmap HBitmap;
 typedef struct HBitmapIter HBitmapIter;
diff --git a/include/qemu/host-utils.h b/include/qemu/host-utils.h
index ead97d35..12ae37af 100644
--- a/include/qemu/host-utils.h
+++ b/include/qemu/host-utils.h
@@ -31,7 +31,7 @@
 #define HOST_UTILS_H
 
 #include "qemu/bswap.h"
-#include "qemu/int128.h"
+//#include "qemu/int128.h"
 
 #ifdef CONFIG_INT128
 static inline void mulu64(uint64_t *plow, uint64_t *phigh,
@@ -856,6 +856,6 @@ static inline uint64_t udiv_qrnnd(uint64_t *r, uint64_t n1,
 #endif
 }
 
-Int128 divu256(Int128 *plow, Int128 *phigh, Int128 divisor);
-Int128 divs256(Int128 *plow, Int128 *phigh, Int128 divisor);
+//Int128 divu256(Int128 *plow, Int128 *phigh, Int128 divisor);
+//Int128 divs256(Int128 *plow, Int128 *phigh, Int128 divisor);
 #endif
diff --git a/include/qemu/main-loop.h b/include/qemu/main-loop.h
index 5764db15..e0a0be44 100644
--- a/include/qemu/main-loop.h
+++ b/include/qemu/main-loop.h
@@ -26,11 +26,12 @@
 #define QEMU_MAIN_LOOP_H
 
 #include "block/aio.h"
-#include "qom/object.h"
-#include "sysemu/event-loop-base.h"
+//#include "qom/object.h"
+//#include "sysemu/event-loop-base.h"
 
 #define SIG_IPI SIGUSR1
 
+#if 0
 #define TYPE_MAIN_LOOP  "main-loop"
 OBJECT_DECLARE_TYPE(MainLoop, MainLoopClass, MAIN_LOOP)
 
@@ -38,6 +39,9 @@ struct MainLoop {
     EventLoopBase parent_obj;
 };
 typedef struct MainLoop MainLoop;
+#endif
+
+void qemu_init_cpu_loop(void);
 
 /**
  * qemu_init_main_loop: Set up the process so that it can run the main loop.
@@ -110,6 +114,7 @@ AioContext *qemu_get_aio_context(void);
  */
 void qemu_notify_event(void);
 
+#if 0
 #ifdef _WIN32
 /* return TRUE if no sleep should be done afterwards */
 typedef int PollingFunc(void *opaque);
@@ -195,6 +200,7 @@ typedef void IOReadHandler(void *opaque, const uint8_t *buf, int size);
  * the event loop.
  */
 typedef int IOCanReadHandler(void *opaque);
+#endif
 
 /**
  * qemu_set_fd_handler: Register a file descriptor with the main loop
@@ -342,6 +348,7 @@ void bql_lock_impl(const char *file, int line);
  */
 void bql_unlock(void);
 
+#if 0
 /**
  * BQL_LOCK_GUARD
  *
@@ -369,6 +376,7 @@ G_DEFINE_AUTOPTR_CLEANUP_FUNC(BQLLockAuto, bql_auto_unlock)
 #define BQL_LOCK_GUARD() \
     g_autoptr(BQLLockAuto) _bql_lock_auto __attribute__((unused)) \
         = bql_auto_lock(__FILE__, __LINE__)
+#endif
 
 /*
  * qemu_cond_wait_bql: Wait on condition for the Big QEMU Lock (BQL)
diff --git a/include/qemu/option_int.h b/include/qemu/option_int.h
index 5dd9a516..f88dd33b 100644
--- a/include/qemu/option_int.h
+++ b/include/qemu/option_int.h
@@ -46,7 +46,7 @@ struct QemuOpt {
 struct QemuOpts {
     char *id;
     QemuOptsList *list;
-    Location loc;
+    //Location loc;
     QTAILQ_HEAD(, QemuOpt) head;
     QTAILQ_ENTRY(QemuOpts) next;
 };
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index fe7c3c5f..bdc90246 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -35,7 +35,7 @@
 #ifdef COMPILING_PER_TARGET
 #include CONFIG_TARGET
 #else
-#include "exec/poison.h"
+//#include "exec/poison.h"
 #endif
 
 /*
diff --git a/include/qemu/range.h b/include/qemu/range.h
index d446ad88..c0122683 100644
--- a/include/qemu/range.h
+++ b/include/qemu/range.h
@@ -234,6 +234,7 @@ static inline int range_get_last_bit(Range *range)
  */
 int range_compare(Range *a, Range *b);
 
+#if 0
 GList *range_list_insert(GList *list, Range *data);
 
 /*
@@ -243,5 +244,6 @@ GList *range_list_insert(GList *list, Range *data);
 void range_inverse_array(GList *in_ranges,
                          GList **out_ranges,
                          uint64_t low, uint64_t high);
+#endif
 
 #endif
diff --git a/include/qemu/timer.h b/include/qemu/timer.h
index fa56ec94..f877974c 100644
--- a/include/qemu/timer.h
+++ b/include/qemu/timer.h
@@ -842,19 +842,21 @@ static inline int64_t get_clock(void)
 
 #else
 
-extern int use_rt_clock;
+//extern int use_rt_clock;
 
 static inline int64_t get_clock(void)
 {
+#if 0
     if (use_rt_clock) {
         struct timespec ts;
         clock_gettime(CLOCK_MONOTONIC, &ts);
         return ts.tv_sec * 1000000000LL + ts.tv_nsec;
     } else {
+#endif
         /* XXX: using gettimeofday leads to problems if the date
            changes, so it should be avoided. */
         return get_clock_realtime();
-    }
+    //}
 }
 #endif
 
diff --git a/include/sysemu/block-backend-common.h b/include/sysemu/block-backend-common.h
index 780cea73..6b77d20d 100644
--- a/include/sysemu/block-backend-common.h
+++ b/include/sysemu/block-backend-common.h
@@ -14,7 +14,7 @@
 #define BLOCK_BACKEND_COMMON_H
 
 #include "qemu/iov.h"
-#include "block/throttle-groups.h"
+//#include "block/throttle-groups.h"
 
 /*
  * TODO Have to include block/block.h for a bunch of block layer
@@ -97,7 +97,7 @@ typedef struct BlockDevOps {
  * friends so that BlockBackends can be kept in lists outside block-backend.c
  */
 typedef struct BlockBackendPublic {
-    ThrottleGroupMember throttle_group_member;
+    //ThrottleGroupMember throttle_group_member;
 } BlockBackendPublic;
 
 #endif /* BLOCK_BACKEND_COMMON_H */
diff --git a/include/sysemu/block-backend-global-state.h b/include/sysemu/block-backend-global-state.h
index 49c12b0f..8c557f0d 100644
--- a/include/sysemu/block-backend-global-state.h
+++ b/include/sysemu/block-backend-global-state.h
@@ -117,7 +117,7 @@ int blk_load_vmstate(BlockBackend *blk, uint8_t *buf, int64_t pos, int size);
 int blk_probe_blocksizes(BlockBackend *blk, BlockSizes *bsz);
 int blk_probe_geometry(BlockBackend *blk, HDGeometry *geo);
 
-void blk_set_io_limits(BlockBackend *blk, ThrottleConfig *cfg);
+//void blk_set_io_limits(BlockBackend *blk, ThrottleConfig *cfg);
 void blk_io_limits_disable(BlockBackend *blk);
 void blk_io_limits_enable(BlockBackend *blk, const char *group);
 void blk_io_limits_update_group(BlockBackend *blk, const char *group);
diff --git a/include/sysemu/block-backend-io.h b/include/sysemu/block-backend-io.h
index d174275a..040efc7c 100644
--- a/include/sysemu/block-backend-io.h
+++ b/include/sysemu/block-backend-io.h
@@ -46,6 +46,7 @@ BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,
                             BlockCompletionFunc *cb, void *opaque);
 BlockAIOCB *blk_aio_flush(BlockBackend *blk,
                           BlockCompletionFunc *cb, void *opaque);
+#if 0
 BlockAIOCB *blk_aio_zone_report(BlockBackend *blk, int64_t offset,
                                 unsigned int *nr_zones,
                                 BlockZoneDescriptor *zones,
@@ -56,6 +57,7 @@ BlockAIOCB *blk_aio_zone_mgmt(BlockBackend *blk, BlockZoneOp op,
 BlockAIOCB *blk_aio_zone_append(BlockBackend *blk, int64_t *offset,
                                 QEMUIOVector *qiov, BdrvRequestFlags flags,
                                 BlockCompletionFunc *cb, void *opaque);
+#endif
 BlockAIOCB *blk_aio_pdiscard(BlockBackend *blk, int64_t offset, int64_t bytes,
                              BlockCompletionFunc *cb, void *opaque);
 void blk_aio_cancel_async(BlockAIOCB *acb);
@@ -92,11 +94,13 @@ void *blk_blockalign(BlockBackend *blk, size_t size);
 bool blk_is_writable(BlockBackend *blk);
 bool blk_enable_write_cache(BlockBackend *blk);
 BlockdevOnError blk_get_on_error(BlockBackend *blk, bool is_read);
+#if 0
 BlockErrorAction blk_get_error_action(BlockBackend *blk, bool is_read,
                                       int error);
 void blk_error_action(BlockBackend *blk, BlockErrorAction action,
                       bool is_read, int error);
 void blk_iostatus_set_err(BlockBackend *blk, int error);
+#endif
 int blk_get_max_iov(BlockBackend *blk);
 int blk_get_max_hw_iov(BlockBackend *blk);
 
diff --git a/qcow2/Makefile.am b/qcow2/Makefile.am
new file mode 100644
index 00000000..69460e08
--- /dev/null
+++ b/qcow2/Makefile.am
@@ -0,0 +1,21 @@
+
+SUBDIRS = lib
+
+AM_CFLAGS  = -Wall
+AM_CFLAGS += -Werror
+AM_CFLAGS += $(if $(GCOV),-fprofile-dir=/tmp/coverage/blktap/qcow2 -fprofile-arcs -ftest-coverage)
+
+AM_CPPFLAGS  = -D_GNU_SOURCE
+AM_CPPFLAGS += -I$(top_srcdir)/include
+AM_CPPFLAGS += $(GLIB_CFLAGS)
+
+bin_PROGRAMS = qemu-img
+
+qemu_img_LDADD  = lib/libqcow2.la
+
+qemu_img_SOURCES = qemu-img.c
+qemu_img_SOURCES += qemu-config.c
+qemu_img_SOURCES += qemu-progress.c
+
+clean-local:
+	-rm -rf *.gc??
diff --git a/qcow2/lib/Makefile.am b/qcow2/lib/Makefile.am
new file mode 100644
index 00000000..764486e8
--- /dev/null
+++ b/qcow2/lib/Makefile.am
@@ -0,0 +1,136 @@
+AUTOMAKE_OPTIONS = subdir-objects
+
+SUBDIRS = .
+#$(MAYBE_test)
+
+AM_CFLAGS  = -Wall
+AM_CFLAGS += -Werror
+AM_CFLAGS += $(if $(GCOV),-fprofile-dir=/tmp/coverage/blktap/qcow2/lib -fprofile-arcs -ftest-coverage)
+
+AM_CPPFLAGS  = -D_GNU_SOURCE
+AM_CPPFLAGS += -I$(top_srcdir)/include
+AM_CPPFLAGS += -I$(top_srcdir)/lvm
+AM_CPPFLAGS += -I$(top_srcdir)/part
+AM_CPPFLAGS += $(GLIB_CFLAGS)
+AM_CPPFLAGS += $(ZLIB_CFLAGS)
+AM_CPPFLAGS += $(GNUTLS_CFLAGS)
+
+lib_LTLIBRARIES  = libqcow2.la
+lib_LTLIBRARIES += $(MAYBE_libqcow2io_la)
+
+libqcow2_la_SOURCES  = qcow2.c
+libqcow2_la_SOURCES += qcow2-refcount.c
+libqcow2_la_SOURCES += qcow2-cache.c
+libqcow2_la_SOURCES += qcow2-cluster.c
+libqcow2_la_SOURCES += qcow2-bitmap.c
+libqcow2_la_SOURCES += qcow2-threads.c
+libqcow2_la_SOURCES += qcow2-snapshot.c
+libqcow2_la_SOURCES += block.c
+libqcow2_la_SOURCES += blockdev.c
+libqcow2_la_SOURCES += blockjob.c
+libqcow2_la_SOURCES += block/accounting.c
+libqcow2_la_SOURCES += block/aio_task.c
+libqcow2_la_SOURCES += block/block-backend.c
+libqcow2_la_SOURCES += block/block-gen.c
+libqcow2_la_SOURCES += block/commit.c
+libqcow2_la_SOURCES += block/dirty-bitmap.c
+libqcow2_la_SOURCES += block/file-posix.c
+libqcow2_la_SOURCES += block/graph-lock.c
+libqcow2_la_SOURCES += block/io.c
+libqcow2_la_SOURCES += block/linux-aio.c
+libqcow2_la_SOURCES += block/mirror.c
+libqcow2_la_SOURCES += block/monitor/bitmap-qmp-cmds.c
+libqcow2_la_SOURCES += block/progress_meter.c
+libqcow2_la_SOURCES += block/qapi.c
+libqcow2_la_SOURCES += block/raw-format.c
+libqcow2_la_SOURCES += block/snapshot.c
+libqcow2_la_SOURCES += crypto/hash.c
+libqcow2_la_SOURCES += hw/block/block.c
+libqcow2_la_SOURCES += hw/block/hd-geometry.c
+libqcow2_la_SOURCES += job.c
+libqcow2_la_SOURCES += job-qmp.c
+libqcow2_la_SOURCES += qapi/qapi-dealloc-visitor.c
+libqcow2_la_SOURCES += qapi/qapi-events-block-core.c
+libqcow2_la_SOURCES += qapi/qapi-events-job.c
+libqcow2_la_SOURCES += qapi/qapi-types-block-core.c
+libqcow2_la_SOURCES += qapi/qapi-types-common.c
+libqcow2_la_SOURCES += qapi/qapi-types-job.c
+libqcow2_la_SOURCES += qapi/qapi-util.c
+libqcow2_la_SOURCES += qapi/qapi-visit-block-core.c
+libqcow2_la_SOURCES += qapi/qapi-visit-common.c
+libqcow2_la_SOURCES += qapi/qapi-visit-core.c
+libqcow2_la_SOURCES += qapi/qapi-visit-job.c
+libqcow2_la_SOURCES += qapi/qmp-dispatch.c
+libqcow2_la_SOURCES += qapi/qmp-event.c
+libqcow2_la_SOURCES += qapi/qobject-input-visitor.c
+libqcow2_la_SOURCES += qapi/qobject-output-visitor.c
+libqcow2_la_SOURCES += qobject/block-qdict.c
+libqcow2_la_SOURCES += qobject/json-lexer.c
+libqcow2_la_SOURCES += qobject/json-parser.c
+libqcow2_la_SOURCES += qobject/json-streamer.c
+libqcow2_la_SOURCES += qobject/json-writer.c
+libqcow2_la_SOURCES += qobject/qbool.c
+libqcow2_la_SOURCES += qobject/qdict.c
+libqcow2_la_SOURCES += qobject/qjson.c
+libqcow2_la_SOURCES += qobject/qlist.c
+libqcow2_la_SOURCES += qobject/qnull.c
+libqcow2_la_SOURCES += qobject/qnum.c
+libqcow2_la_SOURCES += qobject/qobject.c
+libqcow2_la_SOURCES += qobject/qstring.c
+libqcow2_la_SOURCES += system/cpus.c
+libqcow2_la_SOURCES += util/aio-posix.c
+libqcow2_la_SOURCES += util/aio-wait.c
+libqcow2_la_SOURCES += util/aiocb.c
+libqcow2_la_SOURCES += util/async.c
+libqcow2_la_SOURCES += util/bitmap.c
+libqcow2_la_SOURCES += util/bitops.c
+libqcow2_la_SOURCES += util/bufferiszero.c
+libqcow2_la_SOURCES += util/compatfd.c
+libqcow2_la_SOURCES += util/coroutine-ucontext.c
+libqcow2_la_SOURCES += util/cutils.c
+libqcow2_la_SOURCES += util/defer-call.c
+libqcow2_la_SOURCES += util/error.c
+libqcow2_la_SOURCES += util/error-report.c
+libqcow2_la_SOURCES += util/event_notifier-posix.c
+libqcow2_la_SOURCES += util/fdmon-epoll.c
+libqcow2_la_SOURCES += util/fdmon-poll.c
+libqcow2_la_SOURCES += util/hbitmap.c
+libqcow2_la_SOURCES += util/host-utils.c
+libqcow2_la_SOURCES += util/id.c
+libqcow2_la_SOURCES += util/iov.c
+libqcow2_la_SOURCES += util/lockcnt.c
+libqcow2_la_SOURCES += util/main-loop.c
+libqcow2_la_SOURCES += util/memalign.c
+libqcow2_la_SOURCES += util/module.c
+libqcow2_la_SOURCES += util/notify.c
+libqcow2_la_SOURCES += util/osdep.c
+libqcow2_la_SOURCES += util/oslib-posix.c
+libqcow2_la_SOURCES += util/qemu-coroutine.c
+libqcow2_la_SOURCES += util/qemu-coroutine-lock.c
+libqcow2_la_SOURCES += util/qemu-option.c
+libqcow2_la_SOURCES += util/qemu-print.c
+libqcow2_la_SOURCES += util/qemu-thread-posix.c
+libqcow2_la_SOURCES += util/qemu-timer.c
+libqcow2_la_SOURCES += util/qsp.c
+libqcow2_la_SOURCES += util/rcu.c
+libqcow2_la_SOURCES += util/stats64.c
+libqcow2_la_SOURCES += util/thread-pool.c
+libqcow2_la_SOURCES += util/timed-average.c
+libqcow2_la_SOURCES += util/transactions.c
+libqcow2_la_SOURCES += util/unicode.c
+
+
+libqcow2_la_LDFLAGS = -version-info 1:1:1
+
+libqcow2_la_LIBADD = -lpthread -luuid -laio -ldl $(LIBICONV)  $(top_srcdir)/lvm/liblvmutil.la
+libqcow2_la_LIBADD += $(GLIB_LIBS)
+libqcow2_la_LIBADD += $(ZLIB_LIBS)
+libqcow2_la_LIBADD += $(GNUTLS_LIBS)
+libqcow2_la_LIBADD += $(LIBZSTD_LIBS)
+
+#if ENABLE_TESTS
+#MAYBE_test = test
+#endif
+
+clean-local:
+	-rm -rf *.gc??
diff --git a/qcow2/lib/block.c b/qcow2/lib/block.c
index c317de9e..e823b462 100644
--- a/qcow2/lib/block.c
+++ b/qcow2/lib/block.c
@@ -24,12 +24,12 @@
  */
 
 #include "qemu/osdep.h"
-#include "block/trace.h"
+//#include "block/trace.h"
 #include "block/block_int.h"
 #include "block/blockjob.h"
 #include "block/dirty-bitmap.h"
-#include "block/fuse.h"
-#include "block/nbd.h"
+//#include "block/fuse.h"
+//#include "block/nbd.h"
 #include "block/qdict.h"
 #include "qemu/error-report.h"
 #include "block/module_block.h"
@@ -1917,8 +1917,8 @@ static int bdrv_open_common(BlockDriverState *bs, BlockBackend *file,
         goto fail_opts;
     }
 
-    trace_bdrv_open_common(bs, filename ?: "", bs->open_flags,
-                           drv->format_name);
+    //trace_bdrv_open_common(bs, filename ?: "", bs->open_flags,
+    //                       drv->format_name);
 
     ro = bdrv_is_read_only(bs);
 
@@ -5114,7 +5114,6 @@ static void GRAPH_UNLOCKED bdrv_reopen_abort(BDRVReopenState *reopen_state)
     }
 }
 
-
 static void bdrv_close(BlockDriverState *bs)
 {
     BdrvAioNotifier *ban, *ban_next;
@@ -5180,6 +5179,7 @@ static void bdrv_close(BlockDriverState *bs)
     }
 }
 
+#if 0
 void bdrv_close_all(void)
 {
     GLOBAL_STATE_CODE();
@@ -5194,6 +5194,7 @@ void bdrv_close_all(void)
 
     assert(QTAILQ_EMPTY(&all_bdrv_states));
 }
+#endif
 
 static bool GRAPH_RDLOCK should_update_child(BdrvChild *c, BlockDriverState *to)
 {
@@ -5423,6 +5424,7 @@ int bdrv_replace_node(BlockDriverState *from, BlockDriverState *to,
     return bdrv_replace_node_common(from, to, true, false, errp);
 }
 
+#if 0
 int bdrv_drop_filter(BlockDriverState *bs, Error **errp)
 {
     BlockDriverState *child_bs;
@@ -5442,6 +5444,7 @@ int bdrv_drop_filter(BlockDriverState *bs, Error **errp)
 
     return ret;
 }
+#endif
 
 /*
  * Add new bs contents at the top of an image chain while the chain is
@@ -5499,6 +5502,7 @@ out:
     return ret;
 }
 
+#if 0
 /* Not for empty child */
 int bdrv_replace_child_bs(BdrvChild *child, BlockDriverState *new_bs,
                           Error **errp)
@@ -5531,6 +5535,7 @@ int bdrv_replace_child_bs(BdrvChild *child, BlockDriverState *new_bs,
 
     return ret;
 }
+#endif
 
 static void bdrv_delete(BlockDriverState *bs)
 {
@@ -5551,7 +5556,7 @@ static void bdrv_delete(BlockDriverState *bs)
     g_free(bs);
 }
 
-
+#if 0
 /*
  * Replace @bs by newly created block node.
  *
@@ -5625,6 +5630,7 @@ fail:
     bdrv_unref(new_node_bs);
     return NULL;
 }
+#endif
 
 /*
  * Run consistency checks on an image
@@ -6113,6 +6119,7 @@ bool bdrv_is_sg(BlockDriverState *bs)
     return bs->sg;
 }
 
+#if 0
 /**
  * Return whether the given node supports compressed writes.
  */
@@ -6136,6 +6143,7 @@ bool bdrv_supports_compressed_writes(BlockDriverState *bs)
 
     return true;
 }
+#endif
 
 const char *bdrv_get_format_name(BlockDriverState *bs)
 {
@@ -6226,6 +6234,7 @@ BlockDriverState *bdrv_find_node(const char *node_name)
     return NULL;
 }
 
+#if 0
 /* Put this QMP function here so it can access the static graph_bdrv_states. */
 BlockDeviceInfoList *bdrv_named_nodes_list(bool flat,
                                            Error **errp)
@@ -6382,6 +6391,7 @@ XDbgBlockGraph *bdrv_get_xdbg_block_graph(Error **errp)
 
     return xdbg_graph_finalize(gr);
 }
+#endif
 
 BlockDriverState *bdrv_lookup_bs(const char *device,
                                  const char *node_name,
@@ -7095,7 +7105,7 @@ void coroutine_fn bdrv_co_lock_medium(BlockDriverState *bs, bool locked)
     BlockDriver *drv = bs->drv;
     IO_CODE();
     assert_bdrv_graph_readable();
-    trace_bdrv_lock_medium(bs, locked);
+    //trace_bdrv_lock_medium(bs, locked);
 
     if (drv && drv->bdrv_co_lock_medium) {
         drv->bdrv_co_lock_medium(bs, locked);
@@ -7425,6 +7435,7 @@ AioContext *bdrv_get_aio_context(BlockDriverState *bs)
     return bs ? bs->aio_context : qemu_get_aio_context();
 }
 
+#if 0
 AioContext *coroutine_fn bdrv_co_enter(BlockDriverState *bs)
 {
     Coroutine *self = qemu_coroutine_self();
@@ -7449,6 +7460,7 @@ void coroutine_fn bdrv_co_leave(BlockDriverState *bs, AioContext *old_ctx)
     aio_co_reschedule_self(old_ctx);
     bdrv_dec_in_flight(bs);
 }
+#endif
 
 static void bdrv_do_remove_aio_context_notifier(BdrvAioNotifier *ban)
 {
diff --git a/qcow2/lib/block/accounting.c b/qcow2/lib/block/accounting.c
index 28297453..dea4f667 100644
--- a/qcow2/lib/block/accounting.c
+++ b/qcow2/lib/block/accounting.c
@@ -27,7 +27,8 @@
 #include "block/accounting.h"
 #include "block/block_int.h"
 #include "qemu/timer.h"
-#include "sysemu/qtest.h"
+//#include "sysemu/qtest.h"
+#define qtest_enabled() 0
 
 static QEMUClockType clock_type = QEMU_CLOCK_REALTIME;
 static const int qtest_latency_ns = NANOSECONDS_PER_SECOND / 1000;
diff --git a/qcow2/lib/block/block-backend.c b/qcow2/lib/block/block-backend.c
index db6f9b92..d15da172 100644
--- a/qcow2/lib/block/block-backend.c
+++ b/qcow2/lib/block/block-backend.c
@@ -15,18 +15,18 @@
 #include "block/block_int.h"
 #include "block/blockjob.h"
 #include "block/coroutines.h"
-#include "block/throttle-groups.h"
-#include "hw/qdev-core.h"
-#include "sysemu/blockdev.h"
-#include "sysemu/runstate.h"
-#include "sysemu/replay.h"
+//#include "block/throttle-groups.h"
+//#include "hw/qdev-core.h"
+//#include "sysemu/blockdev.h"
+//#include "sysemu/runstate.h"
+//#include "sysemu/replay.h"
 #include "qapi/error.h"
-#include "qapi/qapi-events-block.h"
+//#include "qapi/qapi-events-block.h"
 #include "qemu/id.h"
 #include "qemu/main-loop.h"
 #include "qemu/option.h"
-#include "trace.h"
-#include "migration/misc.h"
+//#include "trace.h"
+//#include "migration/misc.h"
 
 /* Number of coroutines to reserve per attached device model */
 #define COROUTINE_POOL_RESERVATION 64
@@ -48,7 +48,7 @@ struct BlockBackend {
     DriveInfo *legacy_dinfo;    /* null unless created by drive_new() */
     QTAILQ_ENTRY(BlockBackend) link;         /* for block_backends */
     QTAILQ_ENTRY(BlockBackend) monitor_link; /* for monitor_block_backends */
-    BlockBackendPublic public;
+    //BlockBackendPublic public;
 
     DeviceState *dev;           /* attached device model, if any */
     const BlockDevOps *dev_ops;
@@ -163,6 +163,7 @@ static const char *blk_root_get_name(BdrvChild *child)
     return blk_name(child->opaque);
 }
 
+#if 0
 static void blk_vm_state_changed(void *opaque, bool running, RunState state)
 {
     Error *local_err = NULL;
@@ -179,6 +180,7 @@ static void blk_vm_state_changed(void *opaque, bool running, RunState state)
         error_report_err(local_err);
     }
 }
+#endif
 
 /*
  * Notifies the user of the BlockBackend that migration has completed. qdev
@@ -216,6 +218,7 @@ static void GRAPH_RDLOCK blk_root_activate(BdrvChild *child, Error **errp)
     }
     blk->shared_perm = saved_shared_perm;
 
+#if 0
     if (runstate_check(RUN_STATE_INMIGRATE)) {
         /* Activation can happen when migration process is still active, for
          * example when nbd_server_add is called during non-shared storage
@@ -226,6 +229,7 @@ static void GRAPH_RDLOCK blk_root_activate(BdrvChild *child, Error **errp)
         }
         return;
     }
+#endif
 
     blk_set_perm_locked(blk, blk->perm, blk->shared_perm, &local_err);
     if (local_err) {
@@ -285,7 +289,7 @@ static void blk_root_attach(BdrvChild *child)
     BlockBackend *blk = child->opaque;
     BlockBackendAioNotifier *notifier;
 
-    trace_blk_root_attach(child, blk, child->bs);
+    //trace_blk_root_attach(child, blk, child->bs);
 
     QLIST_FOREACH(notifier, &blk->aio_notifiers, list) {
         bdrv_add_aio_context_notifier(child->bs,
@@ -300,7 +304,7 @@ static void blk_root_detach(BdrvChild *child)
     BlockBackend *blk = child->opaque;
     BlockBackendAioNotifier *notifier;
 
-    trace_blk_root_detach(child, blk, child->bs);
+    //trace_blk_root_detach(child, blk, child->bs);
 
     QLIST_FOREACH(notifier, &blk->aio_notifiers, list) {
         bdrv_remove_aio_context_notifier(child->bs,
@@ -480,16 +484,20 @@ static void blk_delete(BlockBackend *blk)
     assert(!blk->refcnt);
     assert(!blk->name);
     assert(!blk->dev);
+#if 0
     if (blk->public.throttle_group_member.throttle_state) {
         blk_io_limits_disable(blk);
     }
+#endif
     if (blk->root) {
         blk_remove_bs(blk);
     }
+#if 0
     if (blk->vmsh) {
         qemu_del_vm_change_state_handler(blk->vmsh);
         blk->vmsh = NULL;
     }
+#endif
     assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
     assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
     assert(QLIST_EMPTY(&blk->aio_notifiers));
@@ -506,7 +514,7 @@ static void drive_info_del(DriveInfo *dinfo)
     if (!dinfo) {
         return;
     }
-    qemu_opts_del(dinfo->opts);
+    //qemu_opts_del(dinfo->opts);
     g_free(dinfo);
 }
 
@@ -630,7 +638,7 @@ BlockDriverState *bdrv_next(BdrvNextIterator *it)
      * BDSes that are attached to a BlockBackend here; they have been handled
      * by the above block already */
     do {
-        it->bs = bdrv_next_monitor_owned(it->bs);
+        it->bs = NULL /*bdrv_next_monitor_owned(it->bs)*/;
         bs = it->bs;
     } while (bs && bdrv_has_blk(bs));
 
@@ -672,6 +680,7 @@ void bdrv_next_cleanup(BdrvNextIterator *it)
     bdrv_next_reset(it);
 }
 
+#if 0
 /*
  * Add a BlockBackend into the list of backends referenced by the monitor, with
  * the given @name acting as the handle for the monitor.
@@ -724,6 +733,7 @@ void monitor_remove_blk(BlockBackend *blk)
     g_free(blk->name);
     blk->name = NULL;
 }
+#endif
 
 /*
  * Return @blk's name, a non-null string.
@@ -806,6 +816,7 @@ bool bdrv_is_root_node(BlockDriverState *bs)
     return true;
 }
 
+#if 0
 /*
  * Return @blk's DriveInfo if any, else null.
  */
@@ -861,18 +872,20 @@ BlockBackend *blk_by_public(BlockBackendPublic *public)
     GLOBAL_STATE_CODE();
     return container_of(public, BlockBackend, public);
 }
+#endif
 
 /*
  * Disassociates the currently associated BlockDriverState from @blk.
  */
 void blk_remove_bs(BlockBackend *blk)
 {
-    ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
+    //ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
     BdrvChild *root;
 
     GLOBAL_STATE_CODE();
 
     notifier_list_notify(&blk->remove_bs_notifiers, blk);
+#if 0
     if (tgm->throttle_state) {
         BlockDriverState *bs = blk_bs(blk);
 
@@ -887,6 +900,7 @@ void blk_remove_bs(BlockBackend *blk)
         bdrv_drained_end(bs);
         bdrv_unref(bs);
     }
+#endif
 
     blk_update_root_state(blk);
 
@@ -908,7 +922,7 @@ void blk_remove_bs(BlockBackend *blk)
  */
 int blk_insert_bs(BlockBackend *blk, BlockDriverState *bs, Error **errp)
 {
-    ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
+    //ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
 
     GLOBAL_STATE_CODE();
     bdrv_ref(bs);
@@ -923,14 +937,17 @@ int blk_insert_bs(BlockBackend *blk, BlockDriverState *bs, Error **errp)
     }
 
     notifier_list_notify(&blk->insert_bs_notifiers, blk);
+#if 0
     if (tgm->throttle_state) {
         throttle_group_detach_aio_context(tgm);
         throttle_group_attach_aio_context(tgm, bdrv_get_aio_context(bs));
     }
+#endif
 
     return 0;
 }
 
+#if 0
 /*
  * Change BlockDriverState associated with @blk.
  */
@@ -939,6 +956,7 @@ int blk_replace_bs(BlockBackend *blk, BlockDriverState *new_bs, Error **errp)
     GLOBAL_STATE_CODE();
     return bdrv_replace_child_bs(blk->root, new_bs, errp);
 }
+#endif
 
 /*
  * Sets the permission bitmasks that the user of the BlockBackend needs.
@@ -972,6 +990,7 @@ int blk_set_perm(BlockBackend *blk, uint64_t perm, uint64_t shared_perm,
     return blk_set_perm_locked(blk, perm, shared_perm, errp);
 }
 
+#if 0
 void blk_get_perm(BlockBackend *blk, uint64_t *perm, uint64_t *shared_perm)
 {
     GLOBAL_STATE_CODE();
@@ -1018,6 +1037,7 @@ void blk_detach_dev(BlockBackend *blk, DeviceState *dev)
     blk_set_perm(blk, 0, BLK_PERM_ALL, &error_abort);
     blk_unref(blk);
 }
+#endif
 
 /*
  * Return the device model attached to @blk if any, else null.
@@ -1032,18 +1052,19 @@ DeviceState *blk_get_attached_dev(BlockBackend *blk)
  * device attached to the BlockBackend. */
 char *blk_get_attached_dev_id(BlockBackend *blk)
 {
-    DeviceState *dev = blk->dev;
+    //DeviceState *dev = blk->dev;
     IO_CODE();
 
-    if (!dev) {
+    //if (!dev) {
         return g_strdup("");
-    } else if (dev->id) {
-        return g_strdup(dev->id);
-    }
+    //} else if (dev->id) {
+    //    return g_strdup(dev->id);
+    //}
 
-    return object_get_canonical_path(OBJECT(dev)) ?: g_strdup("");
+    //return object_get_canonical_path(OBJECT(dev)) ?: g_strdup("");
 }
 
+#if 0
 /*
  * Return the BlockBackend which has the device model @dev attached if it
  * exists, else null.
@@ -1082,6 +1103,7 @@ void blk_set_dev_ops(BlockBackend *blk, const BlockDevOps *ops,
         ops->drained_begin(opaque);
     }
 }
+#endif
 
 /*
  * Notify @blk's attached device model of media change.
@@ -1111,7 +1133,7 @@ void blk_dev_change_media_cb(BlockBackend *blk, bool load, Error **errp)
 
         if (tray_was_open != tray_is_open) {
             char *id = blk_get_attached_dev_id(blk);
-            qapi_event_send_device_tray_moved(blk_name(blk), id, tray_is_open);
+            //qapi_event_send_device_tray_moved(blk_name(blk), id, tray_is_open);
             g_free(id);
         }
     }
@@ -1190,12 +1212,14 @@ static void blk_root_resize(BdrvChild *child)
     }
 }
 
+#if 0
 void blk_iostatus_enable(BlockBackend *blk)
 {
     GLOBAL_STATE_CODE();
     blk->iostatus_enabled = true;
     blk->iostatus = BLOCK_DEVICE_IO_STATUS_OK;
 }
+#endif
 
 /* The I/O status is only enabled if the drive explicitly
  * enables it _and_ the VM is configured to stop on errors */
@@ -1214,6 +1238,7 @@ BlockDeviceIoStatus blk_iostatus(const BlockBackend *blk)
     return blk->iostatus;
 }
 
+#if 0
 void blk_iostatus_disable(BlockBackend *blk)
 {
     GLOBAL_STATE_CODE();
@@ -1237,6 +1262,7 @@ void blk_iostatus_set_err(BlockBackend *blk, int error)
                                           BLOCK_DEVICE_IO_STATUS_FAILED;
     }
 }
+#endif
 
 void blk_set_allow_write_beyond_eof(BlockBackend *blk, bool allow)
 {
@@ -1329,7 +1355,7 @@ blk_co_do_preadv_part(BlockBackend *blk, int64_t offset, int64_t bytes,
 
     /* Call blk_bs() only after waiting, the graph may have changed */
     bs = blk_bs(blk);
-    trace_blk_co_preadv(blk, bs, offset, bytes, flags);
+    //trace_blk_co_preadv(blk, bs, offset, bytes, flags);
 
     ret = blk_check_byte_request(blk, offset, bytes);
     if (ret < 0) {
@@ -1338,11 +1364,13 @@ blk_co_do_preadv_part(BlockBackend *blk, int64_t offset, int64_t bytes,
 
     bdrv_inc_in_flight(bs);
 
+#if 0
     /* throttling disk I/O */
     if (blk->public.throttle_group_member.throttle_state) {
         throttle_group_co_io_limits_intercept(&blk->public.throttle_group_member,
                 bytes, THROTTLE_READ);
     }
+#endif
 
     ret = bdrv_co_preadv_part(blk->root, offset, bytes, qiov, qiov_offset,
                               flags);
@@ -1404,7 +1432,7 @@ blk_co_do_pwritev_part(BlockBackend *blk, int64_t offset, int64_t bytes,
 
     /* Call blk_bs() only after waiting, the graph may have changed */
     bs = blk_bs(blk);
-    trace_blk_co_pwritev(blk, bs, offset, bytes, flags);
+    //trace_blk_co_pwritev(blk, bs, offset, bytes, flags);
 
     ret = blk_check_byte_request(blk, offset, bytes);
     if (ret < 0) {
@@ -1412,11 +1440,13 @@ blk_co_do_pwritev_part(BlockBackend *blk, int64_t offset, int64_t bytes,
     }
 
     bdrv_inc_in_flight(bs);
+#if 0
     /* throttling disk I/O */
     if (blk->public.throttle_group_member.throttle_state) {
         throttle_group_co_io_limits_intercept(&blk->public.throttle_group_member,
                 bytes, THROTTLE_WRITE);
     }
+#endif
 
     if (!blk->enable_write_cache) {
         flags |= BDRV_REQ_FUA;
@@ -1861,6 +1891,7 @@ int coroutine_fn blk_co_flush(BlockBackend *blk)
     return ret;
 }
 
+#if 0
 static void coroutine_fn blk_aio_zone_report_entry(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -2058,6 +2089,7 @@ int coroutine_fn blk_co_zone_append(BlockBackend *blk, int64_t *offset,
     blk_dec_in_flight(blk);
     return ret;
 }
+#endif
 
 void blk_drain(BlockBackend *blk)
 {
@@ -2109,6 +2141,7 @@ BlockdevOnError blk_get_on_error(BlockBackend *blk, bool is_read)
     return is_read ? blk->on_read_error : blk->on_write_error;
 }
 
+#if 0
 BlockErrorAction blk_get_error_action(BlockBackend *blk, bool is_read,
                                       int error)
 {
@@ -2203,6 +2236,7 @@ bool blk_is_writable(BlockBackend *blk)
     IO_CODE();
     return blk->perm & BLK_PERM_WRITE;
 }
+#endif
 
 bool blk_is_sg(BlockBackend *blk)
 {
@@ -2228,6 +2262,7 @@ void blk_set_enable_write_cache(BlockBackend *blk, bool wce)
     blk->enable_write_cache = wce;
 }
 
+#if 0
 void blk_activate(BlockBackend *blk, Error **errp)
 {
     BlockDriverState *bs = blk_bs(blk);
@@ -2249,6 +2284,7 @@ void blk_activate(BlockBackend *blk, Error **errp)
         bdrv_activate(bs, errp);
     }
 }
+#endif
 
 bool coroutine_fn blk_co_is_inserted(BlockBackend *blk)
 {
@@ -2279,7 +2315,7 @@ void coroutine_fn blk_co_lock_medium(BlockBackend *blk, bool locked)
 void coroutine_fn blk_co_eject(BlockBackend *blk, bool eject_flag)
 {
     BlockDriverState *bs = blk_bs(blk);
-    char *id;
+    //char *id;
     IO_CODE();
     GRAPH_RDLOCK_GUARD();
 
@@ -2289,12 +2325,15 @@ void coroutine_fn blk_co_eject(BlockBackend *blk, bool eject_flag)
 
     /* Whether or not we ejected on the backend,
      * the frontend experienced a tray event. */
+#if 0
     id = blk_get_attached_dev_id(blk);
     qapi_event_send_device_tray_moved(blk_name(blk), id,
                                       eject_flag);
     g_free(id);
+#endif
 }
 
+#if 0
 int blk_get_flags(BlockBackend *blk)
 {
     BlockDriverState *bs = blk_bs(blk);
@@ -2354,6 +2393,7 @@ int blk_get_max_iov(BlockBackend *blk)
     IO_CODE();
     return blk->root->bs->bl.max_iov;
 }
+#endif
 
 void *blk_try_blockalign(BlockBackend *blk, size_t size)
 {
@@ -2367,6 +2407,7 @@ void *blk_blockalign(BlockBackend *blk, size_t size)
     return qemu_blockalign(blk ? blk_bs(blk) : NULL, size);
 }
 
+#if 0
 bool blk_op_is_blocked(BlockBackend *blk, BlockOpType op, Error **errp)
 {
     BlockDriverState *bs = blk_bs(blk);
@@ -2409,6 +2450,7 @@ void blk_op_unblock_all(BlockBackend *blk, Error *reason)
         bdrv_op_unblock_all(bs, reason);
     }
 }
+#endif
 
 /**
  * Return BB's current AioContext.  Note that this context may change
@@ -2465,13 +2507,15 @@ static void blk_root_set_aio_ctx_commit(void *opaque)
     BdrvStateBlkRootContext *s = opaque;
     BlockBackend *blk = s->blk;
     AioContext *new_context = s->new_ctx;
-    ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
+    //ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
 
     qatomic_set(&blk->ctx, new_context);
+#if 0
     if (tgm->throttle_state) {
         throttle_group_detach_aio_context(tgm);
         throttle_group_attach_aio_context(tgm, new_context);
     }
+#endif
 }
 
 static TransactionActionDrv set_blk_root_context = {
@@ -2614,6 +2658,7 @@ int coroutine_fn blk_co_truncate(BlockBackend *blk, int64_t offset, bool exact,
     return bdrv_co_truncate(blk->root, offset, exact, prealloc, flags, errp);
 }
 
+#if 0
 int blk_save_vmstate(BlockBackend *blk, const uint8_t *buf,
                      int64_t pos, int size)
 {
@@ -2645,6 +2690,7 @@ int blk_load_vmstate(BlockBackend *blk, uint8_t *buf, int64_t pos, int size)
 
     return bdrv_load_vmstate(blk_bs(blk), buf, pos, size);
 }
+#endif
 
 int blk_probe_blocksizes(BlockBackend *blk, BlockSizes *bsz)
 {
@@ -2681,6 +2727,7 @@ void blk_update_root_state(BlockBackend *blk)
     blk->root_state.detect_zeroes = blk->root->bs->detect_zeroes;
 }
 
+#if 0
 /*
  * Returns the detect-zeroes setting to be used for bdrv_open() of a
  * BlockDriverState which is supposed to inherit the root state.
@@ -2780,11 +2827,12 @@ void blk_io_limits_update_group(BlockBackend *blk, const char *group)
     blk_io_limits_disable(blk);
     blk_io_limits_enable(blk, group);
 }
+#endif
 
 static void blk_root_drained_begin(BdrvChild *child)
 {
     BlockBackend *blk = child->opaque;
-    ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
+    //ThrottleGroupMember *tgm = &blk->public.throttle_group_member;
 
     if (qatomic_fetch_inc(&blk->quiesce_counter) == 0) {
         if (blk->dev_ops && blk->dev_ops->drained_begin) {
@@ -2795,9 +2843,11 @@ static void blk_root_drained_begin(BdrvChild *child)
     /* Note that blk->root may not be accessible here yet if we are just
      * attaching to a BlockDriverState that is drained. Use child instead. */
 
+#if 0
     if (qatomic_fetch_inc(&tgm->io_limits_disabled) == 0) {
         throttle_group_restart_tgm(tgm);
     }
+#endif
 }
 
 static bool blk_root_drained_poll(BdrvChild *child)
@@ -2817,8 +2867,8 @@ static void blk_root_drained_end(BdrvChild *child)
     BlockBackend *blk = child->opaque;
     assert(qatomic_read(&blk->quiesce_counter));
 
-    assert(blk->public.throttle_group_member.io_limits_disabled);
-    qatomic_dec(&blk->public.throttle_group_member.io_limits_disabled);
+    //assert(blk->public.throttle_group_member.io_limits_disabled);
+    //qatomic_dec(&blk->public.throttle_group_member.io_limits_disabled);
 
     if (qatomic_fetch_dec(&blk->quiesce_counter) == 1) {
         if (blk->dev_ops && blk->dev_ops->drained_end) {
diff --git a/qcow2/lib/block/block-gen.c b/qcow2/lib/block/block-gen.c
index ff2832fa..a9d7a648 100644
--- a/qcow2/lib/block/block-gen.c
+++ b/qcow2/lib/block/block-gen.c
@@ -2190,6 +2190,7 @@ int blk_pwrite_zeroes(BlockBackend *blk, int64_t offset, int64_t bytes, BdrvRequ
 }
 
 
+#if 0
 /*
  * Wrappers for blk_co_zone_report
  */
@@ -2335,6 +2336,7 @@ int blk_zone_append(BlockBackend *blk, int64_t *offset, QEMUIOVector *qiov, Bdrv
         return s.ret;
     }
 }
+#endif
 
 
 /*
@@ -2589,6 +2591,7 @@ int bdrv_common_block_status_above(BlockDriverState *bs, BlockDriverState *base,
 }
 
 
+#if 0
 /*
  * Wrappers for nbd_co_do_establish_connection
  */
@@ -2634,3 +2637,4 @@ int nbd_do_establish_connection(BlockDriverState *bs, bool blocking, Error **err
         return s.ret;
     }
 }
+#endif
diff --git a/qcow2/lib/block/commit.c b/qcow2/lib/block/commit.c
index 7c3fdcb0..6b96a4c6 100644
--- a/qcow2/lib/block/commit.c
+++ b/qcow2/lib/block/commit.c
@@ -14,7 +14,7 @@
 
 #include "qemu/osdep.h"
 #include "qemu/cutils.h"
-#include "trace.h"
+//#include "trace.h"
 #include "block/block_int.h"
 #include "block/blockjob_int.h"
 #include "qapi/error.h"
@@ -170,7 +170,7 @@ static int coroutine_fn commit_run(Job *job, Error **errp)
         ret = blk_co_is_allocated_above(s->top, s->base_overlay, true,
                                         offset, COMMIT_BUFFER_SIZE, &n);
         copy = (ret > 0);
-        trace_commit_one_iteration(s, offset, n, ret);
+        //trace_commit_one_iteration(s, offset, n, ret);
         if (copy) {
             assert(n < SIZE_MAX);
 
@@ -414,7 +414,7 @@ void commit_start(const char *job_id, BlockDriverState *bs,
     s->backing_mask_protocol = backing_mask_protocol;
     s->on_error = on_error;
 
-    trace_commit_start(bs, base, top, s);
+    //trace_commit_start(bs, base, top, s);
     job_start(&s->common.job);
     return;
 
diff --git a/qcow2/lib/block/dirty-bitmap.c b/qcow2/lib/block/dirty-bitmap.c
index 13a19797..df6a3c30 100644
--- a/qcow2/lib/block/dirty-bitmap.c
+++ b/qcow2/lib/block/dirty-bitmap.c
@@ -23,7 +23,7 @@
  */
 #include "qemu/osdep.h"
 #include "qapi/error.h"
-#include "trace.h"
+//#include "trace.h"
 #include "block/block-io.h"
 #include "block/block_int.h"
 #include "block/blockjob.h"
diff --git a/qcow2/lib/block/file-posix.c b/qcow2/lib/block/file-posix.c
index ff928b5e..852f0222 100644
--- a/qcow2/lib/block/file-posix.c
+++ b/qcow2/lib/block/file-posix.c
@@ -32,15 +32,15 @@
 #include "qemu/option.h"
 #include "qemu/units.h"
 #include "qemu/memalign.h"
-#include "trace.h"
+//#include "trace.h"
 #include "block/thread-pool.h"
 #include "qemu/iov.h"
 #include "block/raw-aio.h"
 #include "qapi/qmp/qdict.h"
 #include "qapi/qmp/qstring.h"
 
-#include "scsi/pr-manager.h"
-#include "scsi/constants.h"
+//#include "scsi/pr-manager.h"
+//#include "scsi/constants.h"
 
 #if defined(__APPLE__) && (__MACH__)
 #include <sys/ioctl.h>
@@ -173,7 +173,7 @@ typedef struct BDRVRawState {
         uint64_t discard_bytes_ok;
     } stats;
 
-    PRManager *pr_mgr;
+    //PRManager *pr_mgr;
 } BDRVRawState;
 
 typedef struct BDRVRawReopenState {
@@ -317,6 +317,7 @@ static int probe_logical_blocksize(int fd, unsigned int *sector_size_p)
     return success ? 0 : -errno;
 }
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 /**
  * Get physical block size of @fd.
  * On success, store it in @blk_size and return 0.
@@ -333,6 +334,7 @@ static int probe_physical_blocksize(int fd, unsigned int *blk_size)
     return -ENOTSUP;
 #endif
 }
+#endif
 
 /*
  * Returns true if no alignment restrictions are necessary even for files
@@ -597,7 +599,7 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
     QemuOpts *opts;
     Error *local_err = NULL;
     const char *filename = NULL;
-    const char *str;
+    //const char *str;
     BlockdevAioOptions aio, aio_default;
     int fd, ret;
     struct stat st;
@@ -670,6 +672,7 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
         abort();
     }
 
+#if 0
     str = qemu_opt_get(opts, "pr-manager");
     if (str) {
         s->pr_mgr = pr_manager_lookup(str, &local_err);
@@ -679,6 +682,7 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
             goto fail;
         }
     }
+#endif
 
     s->drop_cache = qemu_opt_get_bool(opts, "drop-cache", true);
     s->check_cache_dropped = qemu_opt_get_bool(opts, "x-check-cache-dropped",
@@ -1522,6 +1526,7 @@ static void raw_refresh_limits(BlockDriverState *bs, Error **errp)
     raw_refresh_zoned_limits(bs, &st, errp);
 }
 
+#if defined(HAVE_HOST_BLOCK_DEVICE)
 static int check_for_dasd(int fd)
 {
 #ifdef BIODASDINFO2
@@ -1597,8 +1602,9 @@ static int hdev_probe_geometry(BlockDriverState *bs, HDGeometry *geo)
     return -ENOTSUP;
 }
 #endif
+#endif
 
-#if defined(__linux__)
+#if defined(__linux__) && defined(HAVE_HOST_BLOCK_DEVICE)
 static int handle_aiocb_ioctl(void *opaque)
 {
     RawPosixAIOData *aiocb = opaque;
@@ -1627,7 +1633,7 @@ static int handle_aiocb_flush(void *opaque)
 
     ret = qemu_fdatasync(aiocb->aio_fildes);
     if (ret == -1) {
-        trace_file_flush_fdatasync_failed(errno);
+        //trace_file_flush_fdatasync_failed(errno);
 
         /* There is no clear definition of the semantics of a failing fsync(),
          * so we may have to assume the worst. The sad truth is that this
@@ -2168,9 +2174,9 @@ static int handle_aiocb_copy_range(void *opaque)
         ssize_t ret = copy_file_range(aiocb->aio_fildes, &in_off,
                                       aiocb->copy_range.aio_fd2, &out_off,
                                       bytes, 0);
-        trace_file_copy_file_range(aiocb->bs, aiocb->aio_fildes, in_off,
-                                   aiocb->copy_range.aio_fd2, out_off, bytes,
-                                   0, ret);
+        //trace_file_copy_file_range(aiocb->bs, aiocb->aio_fildes, in_off,
+        //                           aiocb->copy_range.aio_fd2, out_off, bytes,
+        //                           0, ret);
         if (ret == 0) {
             /* No progress (e.g. when beyond EOF), let the caller fall back to
              * buffer I/O. */
@@ -2546,8 +2552,8 @@ out:
             if (!BDRV_ZT_IS_CONV(*wp)) {
                 if (type & QEMU_AIO_ZONE_APPEND) {
                     *offset_ptr = *wp;
-                    trace_zbd_zone_append_complete(bs, *offset_ptr
-                        >> BDRV_SECTOR_BITS);
+                    //trace_zbd_zone_append_complete(bs, *offset_ptr
+                    //    >> BDRV_SECTOR_BITS);
                 }
                 /* Advance the wp if needed */
                 if (offset + bytes > *wp) {
@@ -3404,7 +3410,7 @@ static int coroutine_fn raw_co_zone_report(BlockDriverState *bs, int64_t offset,
         },
     };
 
-    trace_zbd_zone_report(bs, *nr_zones, offset >> BDRV_SECTOR_BITS);
+    //trace_zbd_zone_report(bs, *nr_zones, offset >> BDRV_SECTOR_BITS);
     return raw_thread_pool_submit(handle_aiocb_zone_report, &acb);
 }
 #endif
@@ -3480,8 +3486,8 @@ static int coroutine_fn raw_co_zone_mgmt(BlockDriverState *bs, BlockZoneOp op,
         },
     };
 
-    trace_zbd_zone_mgmt(bs, op_name, offset >> BDRV_SECTOR_BITS,
-                        len >> BDRV_SECTOR_BITS);
+    //trace_zbd_zone_mgmt(bs, op_name, offset >> BDRV_SECTOR_BITS,
+    //                    len >> BDRV_SECTOR_BITS);
     ret = raw_thread_pool_submit(handle_aiocb_zone_mgmt, &acb);
     if (ret != 0) {
         update_zones_wp(bs, s->fd, offset, nrz);
@@ -3539,7 +3545,7 @@ static int coroutine_fn raw_co_zone_append(BlockDriverState *bs,
         len += iov_len;
     }
 
-    trace_zbd_zone_append(bs, *offset >> BDRV_SECTOR_BITS);
+    //trace_zbd_zone_append(bs, *offset >> BDRV_SECTOR_BITS);
     return raw_co_prw(bs, offset, len, qiov, QEMU_AIO_ZONE_APPEND);
 }
 #endif
@@ -3962,7 +3968,7 @@ static char *FindEjectableOpticalMedia(io_iterator_t *mediaIterator)
 
         /* If a match was found, leave the loop */
         if (*mediaIterator != 0) {
-            trace_file_FindEjectableOpticalMedia(matching_array[index]);
+            //trace_file_FindEjectableOpticalMedia(matching_array[index]);
             mediaType = g_strdup(matching_array[index]);
             break;
         }
@@ -4022,7 +4028,7 @@ static bool setup_cdrom(char *bsd_path, Error **errp)
     if (partition_found == false) {
         error_setg(errp, "Failed to find a working partition on disc");
     } else {
-        trace_file_setup_cdrom(test_partition);
+        //trace_file_setup_cdrom(test_partition);
         pstrcpy(bsd_path, MAXPATHLEN, test_partition);
     }
     return partition_found;
@@ -4084,7 +4090,7 @@ static bool hdev_is_sg(BlockDriverState *bs)
 
     ret = ioctl(s->fd, SG_GET_SCSI_ID, &scsiid);
     if (ret >= 0) {
-        trace_file_hdev_is_sg(scsiid.scsi_type, sg_version);
+        //trace_file_hdev_is_sg(scsiid.scsi_type, sg_version);
         return true;
     }
 
@@ -4194,6 +4200,7 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
         return ret;
     }
 
+#if 0
     if (req == SG_IO && s->pr_mgr) {
         struct sg_io_hdr *io_hdr = buf;
         if (io_hdr->cmdp[0] == PERSISTENT_RESERVE_OUT ||
@@ -4202,6 +4209,7 @@ hdev_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
                                       s->fd, io_hdr);
         }
     }
+#endif
 
     acb = (RawPosixAIOData) {
         .bs         = bs,
diff --git a/qcow2/lib/block/io.c b/qcow2/lib/block/io.c
index 301514c8..ae2adc51 100644
--- a/qcow2/lib/block/io.c
+++ b/qcow2/lib/block/io.c
@@ -23,21 +23,23 @@
  */
 
 #include "qemu/osdep.h"
-#include "trace.h"
+//#include "trace.h"
 #include "sysemu/block-backend.h"
 #include "block/aio-wait.h"
 #include "block/blockjob.h"
-#include "block/blockjob_int.h"
+//#include "block/blockjob_int.h"
 #include "block/block_int.h"
 #include "block/coroutines.h"
 #include "block/dirty-bitmap.h"
-#include "block/write-threshold.h"
+//#include "block/write-threshold.h"
 #include "qemu/cutils.h"
 #include "qemu/memalign.h"
 #include "qapi/error.h"
 #include "qemu/error-report.h"
 #include "qemu/main-loop.h"
-#include "sysemu/replay.h"
+//#include "sysemu/replay.h"
+
+#define replay_events_enabled() 0
 
 /* Maximum bounce buffer for copy-on-read and write zeroes, in bytes */
 #define MAX_BOUNCE_BUFFER (32768 << BDRV_SECTOR_BITS)
@@ -1209,8 +1211,8 @@ bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t offset, int64_t bytes,
     bdrv_round_to_subclusters(bs, offset, bytes, &align_offset, &align_bytes);
     skip_bytes = offset - align_offset;
 
-    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,
-                                   align_offset, align_bytes);
+    //trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,
+    //                               align_offset, align_bytes);
 
     while (align_bytes) {
         int64_t pnum;
@@ -1263,7 +1265,7 @@ bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t offset, int64_t bytes,
                 goto err;
             }
 
-            bdrv_co_debug_event(bs, BLKDBG_COR_WRITE);
+            //bdrv_co_debug_event(bs, BLKDBG_COR_WRITE);
             if (drv->bdrv_co_pwrite_zeroes &&
                 buffer_is_zero(bounce_buffer, pnum)) {
                 /* FIXME: Should we (perhaps conditionally) be setting
@@ -1524,10 +1526,10 @@ bdrv_padding_rmw_read(BdrvChild *child, BdrvTrackedRequest *req,
         qemu_iovec_init_buf(&local_qiov, pad->buf, bytes);
 
         if (pad->head) {
-            bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_HEAD);
+            //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_HEAD);
         }
         if (pad->merge_reads && pad->tail) {
-            bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
+            //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
         }
         ret = bdrv_aligned_preadv(child, req, req->overlap_offset, bytes,
                                   align, &local_qiov, 0, 0);
@@ -1535,10 +1537,10 @@ bdrv_padding_rmw_read(BdrvChild *child, BdrvTrackedRequest *req,
             return ret;
         }
         if (pad->head) {
-            bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);
+            //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_HEAD);
         }
         if (pad->merge_reads && pad->tail) {
-            bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
+            //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
         }
 
         if (pad->merge_reads) {
@@ -1549,7 +1551,7 @@ bdrv_padding_rmw_read(BdrvChild *child, BdrvTrackedRequest *req,
     if (pad->tail) {
         qemu_iovec_init_buf(&local_qiov, pad->tail_buf, align);
 
-        bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
+        //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_TAIL);
         ret = bdrv_aligned_preadv(
                 child, req,
                 req->overlap_offset + req->overlap_bytes - align,
@@ -1557,7 +1559,7 @@ bdrv_padding_rmw_read(BdrvChild *child, BdrvTrackedRequest *req,
         if (ret < 0) {
             return ret;
         }
-        bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
+        //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_RMW_AFTER_TAIL);
     }
 
 zero_mem:
@@ -1779,7 +1781,7 @@ int coroutine_fn bdrv_co_preadv_part(BdrvChild *child,
     int ret;
     IO_CODE();
 
-    trace_bdrv_co_preadv_part(bs, offset, bytes, flags);
+    //trace_bdrv_co_preadv_part(bs, offset, bytes, flags);
 
     if (!bdrv_co_is_inserted(bs)) {
         return -ENOMEDIUM;
@@ -2001,7 +2003,7 @@ bdrv_co_write_req_prepare(BdrvChild *child, int64_t offset, int64_t bytes,
         } else {
             assert(child->perm & BLK_PERM_WRITE);
         }
-        bdrv_write_threshold_check_write(bs, offset, bytes);
+        //bdrv_write_threshold_check_write(bs, offset, bytes);
         return 0;
     case BDRV_TRACKED_TRUNCATE:
         assert(child->perm & BLK_PERM_RESIZE);
@@ -2101,16 +2103,16 @@ bdrv_aligned_pwritev(BdrvChild *child, BdrvTrackedRequest *req,
     if (ret < 0) {
         /* Do nothing, write notifier decided to fail this request */
     } else if (flags & BDRV_REQ_ZERO_WRITE) {
-        bdrv_co_debug_event(bs, BLKDBG_PWRITEV_ZERO);
+        //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_ZERO);
         ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);
     } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {
         ret = bdrv_driver_pwritev_compressed(bs, offset, bytes,
                                              qiov, qiov_offset);
     } else if (bytes <= max_transfer) {
-        bdrv_co_debug_event(bs, BLKDBG_PWRITEV);
+        //bdrv_co_debug_event(bs, BLKDBG_PWRITEV);
         ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, qiov_offset, flags);
     } else {
-        bdrv_co_debug_event(bs, BLKDBG_PWRITEV);
+        //bdrv_co_debug_event(bs, BLKDBG_PWRITEV);
         while (bytes_remaining) {
             int num = MIN(bytes_remaining, max_transfer);
             int local_flags = flags;
@@ -2133,7 +2135,7 @@ bdrv_aligned_pwritev(BdrvChild *child, BdrvTrackedRequest *req,
             bytes_remaining -= num;
         }
     }
-    bdrv_co_debug_event(bs, BLKDBG_PWRITEV_DONE);
+    //bdrv_co_debug_event(bs, BLKDBG_PWRITEV_DONE);
 
     if (ret >= 0) {
         ret = 0;
@@ -2233,7 +2235,7 @@ int coroutine_fn bdrv_co_pwritev_part(BdrvChild *child,
     bool padded = false;
     IO_CODE();
 
-    trace_bdrv_co_pwritev_part(child->bs, offset, bytes, flags);
+    //trace_bdrv_co_pwritev_part(child->bs, offset, bytes, flags);
 
     if (!bdrv_co_is_inserted(bs)) {
         return -ENOMEDIUM;
@@ -2317,13 +2319,14 @@ int coroutine_fn bdrv_co_pwrite_zeroes(BdrvChild *child, int64_t offset,
                                        int64_t bytes, BdrvRequestFlags flags)
 {
     IO_CODE();
-    trace_bdrv_co_pwrite_zeroes(child->bs, offset, bytes, flags);
+    //trace_bdrv_co_pwrite_zeroes(child->bs, offset, bytes, flags);
     assert_bdrv_graph_readable();
 
     return bdrv_co_pwritev(child, offset, bytes, NULL,
                            BDRV_REQ_ZERO_WRITE | flags);
 }
 
+#if 0
 /*
  * Flush ALL BDSes regardless of if they are reachable via a BlkBackend or not.
  */
@@ -2354,6 +2357,7 @@ int bdrv_flush_all(void)
 
     return result;
 }
+#endif
 
 /*
  * Returns the allocation status of the specified sectors.
@@ -2892,6 +2896,7 @@ bdrv_co_writev_vmstate(BlockDriverState *bs, QEMUIOVector *qiov, int64_t pos)
     return ret;
 }
 
+#if 0
 int bdrv_save_vmstate(BlockDriverState *bs, const uint8_t *buf,
                       int64_t pos, int size)
 {
@@ -2911,6 +2916,7 @@ int bdrv_load_vmstate(BlockDriverState *bs, uint8_t *buf,
 
     return ret < 0 ? ret : size;
 }
+#endif
 
 /**************************************************************/
 /* async I/Os */
@@ -3221,6 +3227,7 @@ out:
     return co.ret;
 }
 
+#if 0
 int coroutine_fn bdrv_co_zone_report(BlockDriverState *bs, int64_t offset,
                         unsigned int *nr_zones,
                         BlockZoneDescriptor *zones)
@@ -3288,6 +3295,7 @@ out:
     bdrv_dec_in_flight(bs);
     return co.ret;
 }
+#endif
 
 void *qemu_blockalign(BlockDriverState *bs, size_t size)
 {
@@ -3478,8 +3486,8 @@ int coroutine_fn bdrv_co_copy_range_from(BdrvChild *src, int64_t src_offset,
 {
     IO_CODE();
     assert_bdrv_graph_readable();
-    trace_bdrv_co_copy_range_from(src, src_offset, dst, dst_offset, bytes,
-                                  read_flags, write_flags);
+    //trace_bdrv_co_copy_range_from(src, src_offset, dst, dst_offset, bytes,
+    //                              read_flags, write_flags);
     return bdrv_co_copy_range_internal(src, src_offset, dst, dst_offset,
                                        bytes, read_flags, write_flags, true);
 }
@@ -3496,8 +3504,8 @@ int coroutine_fn bdrv_co_copy_range_to(BdrvChild *src, int64_t src_offset,
 {
     IO_CODE();
     assert_bdrv_graph_readable();
-    trace_bdrv_co_copy_range_to(src, src_offset, dst, dst_offset, bytes,
-                                read_flags, write_flags);
+    //trace_bdrv_co_copy_range_to(src, src_offset, dst, dst_offset, bytes,
+    //                            read_flags, write_flags);
     return bdrv_co_copy_range_internal(src, src_offset, dst, dst_offset,
                                        bytes, read_flags, write_flags, false);
 }
@@ -3679,6 +3687,7 @@ void bdrv_cancel_in_flight(BlockDriverState *bs)
     }
 }
 
+#if 0
 int coroutine_fn
 bdrv_co_preadv_snapshot(BdrvChild *child, int64_t offset, int64_t bytes,
                         QEMUIOVector *qiov, size_t qiov_offset)
@@ -3753,3 +3762,4 @@ bdrv_co_pdiscard_snapshot(BlockDriverState *bs, int64_t offset, int64_t bytes)
 
     return ret;
 }
+#endif
diff --git a/qcow2/lib/block/mirror.c b/qcow2/lib/block/mirror.c
index 61f0a717..4b75f105 100644
--- a/qcow2/lib/block/mirror.c
+++ b/qcow2/lib/block/mirror.c
@@ -15,7 +15,7 @@
 #include "qemu/cutils.h"
 #include "qemu/coroutine.h"
 #include "qemu/range.h"
-#include "trace.h"
+//#include "trace.h"
 #include "block/blockjob_int.h"
 #include "block/block_int.h"
 #include "block/dirty-bitmap.h"
@@ -201,7 +201,9 @@ static void coroutine_fn mirror_iteration_done(MirrorOp *op, int ret)
     int64_t chunk_num;
     int i, nb_chunks;
 
+#if 0
     trace_mirror_iteration_done(s, op->offset, op->bytes, ret);
+#endif
 
     s->in_flight--;
     s->bytes_in_flight -= op->bytes;
@@ -375,7 +377,9 @@ static void coroutine_fn mirror_co_read(void *opaque)
     nb_chunks = DIV_ROUND_UP(op->bytes, s->granularity);
 
     while (s->buf_free_count < nb_chunks) {
+#if 0
         trace_mirror_yield_in_flight(s, op->offset, s->in_flight);
+#endif
         mirror_wait_for_free_in_flight_slot(s);
     }
 
@@ -396,7 +400,9 @@ static void coroutine_fn mirror_co_read(void *opaque)
     s->in_flight++;
     s->bytes_in_flight += op->bytes;
     op->is_in_flight = true;
+#if 0
     trace_mirror_one_iteration(s, op->offset, op->bytes);
+#endif
 
     WITH_GRAPH_RDLOCK_GUARD() {
         ret = bdrv_co_preadv(s->mirror_top_bs->backing, op->offset, op->bytes,
@@ -499,7 +505,9 @@ static void coroutine_fn GRAPH_UNLOCKED mirror_iteration(MirrorBlockJob *s)
     if (offset < 0) {
         bdrv_set_dirty_iter(s->dbi, 0);
         offset = bdrv_dirty_iter_next(s->dbi);
+#if 0
         trace_mirror_restart_iter(s, bdrv_get_dirty_count(s->dirty_bitmap));
+#endif
         assert(offset >= 0);
     }
     bdrv_dirty_bitmap_unlock(s->dirty_bitmap);
@@ -601,7 +609,9 @@ static void coroutine_fn GRAPH_UNLOCKED mirror_iteration(MirrorBlockJob *s)
         }
 
         while (s->in_flight >= MAX_IN_FLIGHT) {
+#if 0
             trace_mirror_yield_in_flight(s, offset, s->in_flight);
+#endif
             mirror_wait_for_free_in_flight_slot(s);
         }
 
@@ -867,8 +877,10 @@ static int coroutine_fn GRAPH_UNLOCKED mirror_dirty_init(MirrorBlockJob *s)
             }
 
             if (s->in_flight >= MAX_IN_FLIGHT) {
+#if 0
                 trace_mirror_yield(s, UINT64_MAX, s->buf_free_count,
                                    s->in_flight);
+#endif
                 mirror_wait_for_free_in_flight_slot(s);
                 continue;
             }
@@ -1071,7 +1083,9 @@ static int coroutine_fn mirror_run(Job *job, Error **errp)
             iostatus == BLOCK_DEVICE_IO_STATUS_OK) {
             if (s->in_flight >= MAX_IN_FLIGHT || s->buf_free_count == 0 ||
                 (cnt == 0 && s->in_flight > 0)) {
+#if 0
                 trace_mirror_yield(s, cnt, s->buf_free_count, s->in_flight);
+#endif
                 mirror_wait_for_free_in_flight_slot(s);
                 continue;
             } else if (cnt != 0) {
@@ -1081,7 +1095,9 @@ static int coroutine_fn mirror_run(Job *job, Error **errp)
 
         should_complete = false;
         if (s->in_flight == 0 && cnt == 0) {
+#if 0
             trace_mirror_before_flush(s);
+#endif
             if (!job_is_ready(&s->common.job)) {
                 if (mirror_flush(s) < 0) {
                     /* Go check s->ret.  */
@@ -1114,7 +1130,9 @@ static int coroutine_fn mirror_run(Job *job, Error **errp)
              * whether to switch to target check one last time if I/O has
              * come in the meanwhile, and if not flush the data to disk.
              */
+#if 0
             trace_mirror_before_drain(s, cnt);
+#endif
 
             s->in_drain = true;
             bdrv_drained_begin(bs);
@@ -1139,8 +1157,10 @@ static int coroutine_fn mirror_run(Job *job, Error **errp)
 
         if (job_is_ready(&s->common.job) && !should_complete) {
             if (s->in_flight == 0 && cnt == 0) {
+#if 0
                 trace_mirror_before_sleep(s, cnt, job_is_ready(&s->common.job),
                                           BLOCK_JOB_SLICE_TIME);
+#endif
                 job_sleep_ns(&s->common.job, BLOCK_JOB_SLICE_TIME);
             }
         } else {
@@ -1235,6 +1255,7 @@ static bool mirror_drained_poll(BlockJob *job)
     return !!s->in_flight;
 }
 
+#if 0
 static bool mirror_cancel(Job *job, bool force)
 {
     MirrorBlockJob *s = container_of(job, MirrorBlockJob, common.job);
@@ -1251,6 +1272,7 @@ static bool mirror_cancel(Job *job, bool force)
     }
     return force;
 }
+#endif
 
 static bool commit_active_cancel(Job *job, bool force)
 {
@@ -1258,6 +1280,7 @@ static bool commit_active_cancel(Job *job, bool force)
     return force || !job_is_ready(job);
 }
 
+#if 0
 static void mirror_change(BlockJob *job, BlockJobChangeOptions *opts,
                           Error **errp)
 {
@@ -1317,6 +1340,7 @@ static const BlockJobDriver mirror_job_driver = {
     .change                 = mirror_change,
     .query                  = mirror_query,
 };
+#endif
 
 static const BlockJobDriver commit_active_job_driver = {
     .job_driver = {
@@ -1969,7 +1993,7 @@ static BlockJob *mirror_start_job(
 
     QTAILQ_INIT(&s->ops_in_flight);
 
-    trace_mirror_start(bs, s, opaque);
+    //trace_mirror_start(bs, s, opaque);
     job_start(&s->common.job);
 
     return &s->common;
@@ -2004,6 +2028,7 @@ fail:
     return NULL;
 }
 
+#if 0
 void mirror_start(const char *job_id, BlockDriverState *bs,
                   BlockDriverState *target, const char *replaces,
                   int creation_flags, int64_t speed,
@@ -2038,6 +2063,7 @@ void mirror_start(const char *job_id, BlockDriverState *bs,
                      &mirror_job_driver, is_none_mode, base, false,
                      filter_node_name, true, copy_mode, false, errp);
 }
+#endif
 
 BlockJob *commit_active_start(const char *job_id, BlockDriverState *bs,
                               BlockDriverState *base, int creation_flags,
diff --git a/qcow2/lib/block/qapi.c b/qcow2/lib/block/qapi.c
index 2b5793f1..82e12895 100644
--- a/qcow2/lib/block/qapi.c
+++ b/qcow2/lib/block/qapi.c
@@ -27,8 +27,8 @@
 #include "block/qapi.h"
 #include "block/block_int.h"
 #include "block/dirty-bitmap.h"
-#include "block/throttle-groups.h"
-#include "block/write-threshold.h"
+//#include "block/throttle-groups.h"
+//#include "block/write-threshold.h"
 #include "qapi/error.h"
 #include "qapi/qapi-commands-block-core.h"
 #include "qapi/qobject-output-visitor.h"
@@ -88,6 +88,7 @@ BlockDeviceInfo *bdrv_block_device_info(BlockBackend *blk,
 
     info->detect_zeroes = bs->detect_zeroes;
 
+#if 0
     if (blk && blk_get_public(blk)->throttle_group_member.throttle_state) {
         ThrottleConfig cfg;
         BlockBackendPublic *blkp = blk_get_public(blk);
@@ -144,6 +145,7 @@ BlockDeviceInfo *bdrv_block_device_info(BlockBackend *blk,
     }
 
     info->write_threshold = bdrv_write_threshold_get(bs);
+#endif
 
     p_image_info = &info->image;
     info->backing_file_depth = 0;
diff --git a/qcow2/lib/block/raw-format.c b/qcow2/lib/block/raw-format.c
index ac7e8495..f3343e98 100644
--- a/qcow2/lib/block/raw-format.c
+++ b/qcow2/lib/block/raw-format.c
@@ -319,6 +319,7 @@ raw_co_pdiscard(BlockDriverState *bs, int64_t offset, int64_t bytes)
     return bdrv_co_pdiscard(bs->file, offset, bytes);
 }
 
+#if 0
 static int coroutine_fn GRAPH_RDLOCK
 raw_co_zone_report(BlockDriverState *bs, int64_t offset,
                    unsigned int *nr_zones,
@@ -340,6 +341,7 @@ raw_co_zone_append(BlockDriverState *bs,int64_t *offset, QEMUIOVector *qiov,
 {
     return bdrv_co_zone_append(bs->file->bs, offset, qiov, flags);
 }
+#endif
 
 static int64_t coroutine_fn GRAPH_RDLOCK
 raw_co_getlength(BlockDriverState *bs)
@@ -650,9 +652,11 @@ BlockDriver bdrv_raw = {
     .bdrv_co_pwritev      = &raw_co_pwritev,
     .bdrv_co_pwrite_zeroes = &raw_co_pwrite_zeroes,
     .bdrv_co_pdiscard     = &raw_co_pdiscard,
+#if 0
     .bdrv_co_zone_report  = &raw_co_zone_report,
     .bdrv_co_zone_mgmt  = &raw_co_zone_mgmt,
     .bdrv_co_zone_append = &raw_co_zone_append,
+#endif
     .bdrv_co_block_status = &raw_co_block_status,
     .bdrv_co_copy_range_from = &raw_co_copy_range_from,
     .bdrv_co_copy_range_to  = &raw_co_copy_range_to,
diff --git a/qcow2/lib/blockdev.c b/qcow2/lib/blockdev.c
index 835064ed..53279249 100644
--- a/qcow2/lib/blockdev.c
+++ b/qcow2/lib/blockdev.c
@@ -37,14 +37,14 @@
 #include "block/blockjob.h"
 #include "block/dirty-bitmap.h"
 #include "block/qdict.h"
-#include "block/throttle-groups.h"
-#include "monitor/monitor.h"
+//#include "block/throttle-groups.h"
+//#include "monitor/monitor.h"
 #include "qemu/error-report.h"
 #include "qemu/option.h"
 #include "qemu/qemu-print.h"
 #include "qemu/config-file.h"
 #include "qapi/qapi-commands-block.h"
-#include "qapi/qapi-commands-transaction.h"
+//#include "qapi/qapi-commands-transaction.h"
 #include "qapi/qapi-visit-block-core.h"
 #include "qapi/qmp/qdict.h"
 #include "qapi/qmp/qnum.h"
@@ -53,17 +53,18 @@
 #include "qapi/qmp/qerror.h"
 #include "qapi/qmp/qlist.h"
 #include "qapi/qobject-output-visitor.h"
-#include "sysemu/sysemu.h"
-#include "sysemu/iothread.h"
+//#include "sysemu/sysemu.h"
+//#include "sysemu/iothread.h"
 #include "block/block_int.h"
-#include "block/trace.h"
-#include "sysemu/runstate.h"
-#include "sysemu/replay.h"
+//#include "block/trace.h"
+//#include "sysemu/runstate.h"
+//#include "sysemu/replay.h"
 #include "qemu/cutils.h"
 #include "qemu/help_option.h"
 #include "qemu/main-loop.h"
-#include "qemu/throttle-options.h"
+//#include "qemu/throttle-options.h"
 
+#if 0
 /* Protected by BQL */
 QTAILQ_HEAD(, BlockDriverState) monitor_bdrv_states =
     QTAILQ_HEAD_INITIALIZER(monitor_bdrv_states);
@@ -1035,6 +1036,7 @@ fail:
     qobject_unref(bs_opts);
     return dinfo;
 }
+#endif
 
 static BlockDriverState *qmp_get_root_bs(const char *name, Error **errp)
 {
@@ -1060,6 +1062,7 @@ static BlockDriverState *qmp_get_root_bs(const char *name, Error **errp)
     return bs;
 }
 
+#if 0
 static void blockdev_do_action(TransactionAction *action, Error **errp)
 {
     TransactionActionList list;
@@ -2422,6 +2425,7 @@ void qmp_block_stream(const char *job_id, const char *device,
 out_rdlock:
     bdrv_graph_rdunlock_main_loop();
 }
+#endif
 
 void qmp_block_commit(const char *job_id, const char *device,
                       const char *base_node,
@@ -2614,6 +2618,7 @@ void qmp_block_commit(const char *job_id, const char *device,
     }
 }
 
+#if 0
 /* Common QMP interface for drive-backup and blockdev-backup */
 static BlockJob *do_backup_common(BackupCommon *backup,
                                   BlockDriverState *bs,
@@ -3510,6 +3515,7 @@ void qmp_x_blockdev_change(const char *parent, const char *child,
 out:
     bdrv_graph_wrunlock();
 }
+#endif
 
 BlockJobInfoList *qmp_query_block_jobs(Error **errp)
 {
@@ -3536,6 +3542,7 @@ BlockJobInfoList *qmp_query_block_jobs(Error **errp)
     return head;
 }
 
+#if 0
 void qmp_x_blockdev_set_iothread(const char *node_name, StrOrNull *iothread,
                                  bool has_force, bool force, Error **errp)
 {
@@ -3647,3 +3654,4 @@ QemuOptsList qemu_drive_opts = {
         { /* end of list */ }
     },
 };
+#endif
diff --git a/qcow2/lib/blockjob.c b/qcow2/lib/blockjob.c
index d5f29e14..b739a1ca 100644
--- a/qcow2/lib/blockjob.c
+++ b/qcow2/lib/blockjob.c
@@ -28,7 +28,7 @@
 #include "block/block.h"
 #include "block/blockjob_int.h"
 #include "block/block_int.h"
-#include "block/trace.h"
+//#include "block/trace.h"
 #include "sysemu/block-backend.h"
 #include "qapi/error.h"
 #include "qapi/qapi-events-block-core.h"
@@ -213,6 +213,7 @@ void block_job_remove_all_bdrv(BlockJob *job)
     bdrv_graph_wrunlock();
 }
 
+#if 0
 bool block_job_has_bdrv(BlockJob *job, BlockDriverState *bs)
 {
     GSList *el;
@@ -227,6 +228,7 @@ bool block_job_has_bdrv(BlockJob *job, BlockDriverState *bs)
 
     return false;
 }
+#endif
 
 int block_job_add_bdrv(BlockJob *job, const char *name, BlockDriverState *bs,
                        uint64_t perm, uint64_t shared_perm, Error **errp)
@@ -312,6 +314,7 @@ static bool block_job_set_speed(BlockJob *job, int64_t speed, Error **errp)
     return block_job_set_speed_locked(job, speed, errp);
 }
 
+#if 0
 void block_job_change_locked(BlockJob *job, BlockJobChangeOptions *opts,
                              Error **errp)
 {
@@ -331,6 +334,7 @@ void block_job_change_locked(BlockJob *job, BlockJobChangeOptions *opts,
         error_setg(errp, "Job type does not support change");
     }
 }
+#endif
 
 void block_job_ratelimit_processed_bytes(BlockJob *job, uint64_t n)
 {
diff --git a/qcow2/lib/crypto/hash.c b/qcow2/lib/crypto/hash.c
index b0f8228b..a282cf74 100644
--- a/qcow2/lib/crypto/hash.c
+++ b/qcow2/lib/crypto/hash.c
@@ -18,20 +18,92 @@
  *
  */
 
+#include <gnutls/crypto.h>
+
 #include "qemu/osdep.h"
 #include "crypto/hash.h"
-#include "hashpriv.h"
+//#include "hashpriv.h"
 
 static size_t qcrypto_hash_alg_size[QCRYPTO_HASH_ALG__MAX] = {
-    [QCRYPTO_HASH_ALG_MD5] = 16,
-    [QCRYPTO_HASH_ALG_SHA1] = 20,
-    [QCRYPTO_HASH_ALG_SHA224] = 28,
-    [QCRYPTO_HASH_ALG_SHA256] = 32,
-    [QCRYPTO_HASH_ALG_SHA384] = 48,
-    [QCRYPTO_HASH_ALG_SHA512] = 64,
-    [QCRYPTO_HASH_ALG_RIPEMD160] = 20,
+    [QCRYPTO_HASH_ALG_MD5]       = QCRYPTO_HASH_DIGEST_LEN_MD5,
+    [QCRYPTO_HASH_ALG_SHA1]      = QCRYPTO_HASH_DIGEST_LEN_SHA1,
+    [QCRYPTO_HASH_ALG_SHA224]    = QCRYPTO_HASH_DIGEST_LEN_SHA224,
+    [QCRYPTO_HASH_ALG_SHA256]    = QCRYPTO_HASH_DIGEST_LEN_SHA256,
+    [QCRYPTO_HASH_ALG_SHA384]    = QCRYPTO_HASH_DIGEST_LEN_SHA384,
+    [QCRYPTO_HASH_ALG_SHA512]    = QCRYPTO_HASH_DIGEST_LEN_SHA512,
+    [QCRYPTO_HASH_ALG_RIPEMD160] = QCRYPTO_HASH_DIGEST_LEN_RIPEMD160,
+};
+
+static int qcrypto_hash_alg_map[QCRYPTO_HASH_ALG__MAX] = {
+    [QCRYPTO_HASH_ALG_MD5] = GNUTLS_DIG_MD5,
+    [QCRYPTO_HASH_ALG_SHA1] = GNUTLS_DIG_SHA1,
+    [QCRYPTO_HASH_ALG_SHA224] = GNUTLS_DIG_SHA224,
+    [QCRYPTO_HASH_ALG_SHA256] = GNUTLS_DIG_SHA256,
+    [QCRYPTO_HASH_ALG_SHA384] = GNUTLS_DIG_SHA384,
+    [QCRYPTO_HASH_ALG_SHA512] = GNUTLS_DIG_SHA512,
+    [QCRYPTO_HASH_ALG_RIPEMD160] = GNUTLS_DIG_RMD160,
 };
 
+gboolean qcrypto_hash_supports(QCryptoHashAlgorithm alg)
+{
+    size_t i;
+    const gnutls_digest_algorithm_t *algs;
+    if (alg >= QCRYPTO_HASH_ALG__MAX ||
+        qcrypto_hash_alg_map[alg] == GNUTLS_DIG_UNKNOWN) {
+        return false;
+    }
+    algs = gnutls_digest_list();
+    for (i = 0; algs[i] != GNUTLS_DIG_UNKNOWN; i++) {
+        if (algs[i] == qcrypto_hash_alg_map[alg]) {
+            return true;
+        }
+    }
+    return false;
+}
+
+static int
+qcrypto_gnutls_hash_bytesv(QCryptoHashAlgorithm alg,
+                           const struct iovec *iov,
+                           size_t niov,
+                           uint8_t **result,
+                           size_t *resultlen,
+                           Error **errp)
+{
+    int i, ret;
+    gnutls_hash_hd_t hash;
+
+    if (!qcrypto_hash_supports(alg)) {
+        fprintf(stderr, "Unknown hash algorithm %d.\n", alg);
+        return -1;
+    }
+
+    ret = gnutls_hash_get_len(qcrypto_hash_alg_map[alg]);
+    if (*resultlen == 0) {
+        *resultlen = ret;
+        *result = calloc(sizeof(uint8_t), *resultlen);
+    } else if (*resultlen != ret) {
+        fprintf(stderr,
+                "Result buffer size %zu is smaller than hash %d.\n",
+                *resultlen, ret);
+        return -1;
+    }
+
+    ret = gnutls_hash_init(&hash, qcrypto_hash_alg_map[alg]);
+    if (ret < 0) {
+        fprintf(stderr,
+                "Unable to initialize hash algorithm: %s.\n",
+                gnutls_strerror(ret));
+        return -1;
+    }
+
+    for (i = 0; i < niov; i++) {
+        gnutls_hash(hash, iov[i].iov_base, iov[i].iov_len);
+    }
+
+    gnutls_hash_deinit(hash, *result);
+    return 0;
+}
+
 size_t qcrypto_hash_digest_len(QCryptoHashAlgorithm alg)
 {
     assert(alg < G_N_ELEMENTS(qcrypto_hash_alg_size));
@@ -59,9 +131,9 @@ int qcrypto_hash_bytesv(QCryptoHashAlgorithm alg,
     }
 #endif
 
-    return qcrypto_hash_lib_driver.hash_bytesv(alg, iov, niov,
-                                               result, resultlen,
-                                               errp);
+    return qcrypto_gnutls_hash_bytesv(alg, iov, niov,
+                                      result, resultlen,
+                                      errp);
 }
 
 
@@ -114,6 +186,7 @@ int qcrypto_hash_digest(QCryptoHashAlgorithm alg,
     return qcrypto_hash_digestv(alg, &iov, 1, digest, errp);
 }
 
+#if 0
 int qcrypto_hash_base64v(QCryptoHashAlgorithm alg,
                          const struct iovec *iov,
                          size_t niov,
@@ -142,3 +215,4 @@ int qcrypto_hash_base64(QCryptoHashAlgorithm alg,
 
     return qcrypto_hash_base64v(alg, &iov, 1, base64, errp);
 }
+#endif
diff --git a/qcow2/lib/hw/block/block.c b/qcow2/lib/hw/block/block.c
index 3ceca7dc..9a0da1e6 100644
--- a/qcow2/lib/hw/block/block.c
+++ b/qcow2/lib/hw/block/block.c
@@ -9,12 +9,13 @@
 
 #include "qemu/osdep.h"
 #include "block/block_int-common.h"
-#include "sysemu/blockdev.h"
+//#include "sysemu/blockdev.h"
 #include "sysemu/block-backend.h"
 #include "hw/block/block.h"
 #include "qapi/error.h"
 #include "qapi/qapi-types-block.h"
 
+#if 0
 /*
  * Read the non-zeroes parts of @blk into @buf
  * Reading all of the @blk is expensive if the zeroes parts of @blk
@@ -99,6 +100,7 @@ bool blk_check_size_and_read_all(BlockBackend *blk, DeviceState *dev,
     }
     return true;
 }
+#endif
 
 bool blkconf_blocksizes(BlockConf *conf, Error **errp)
 {
@@ -257,8 +259,8 @@ bool blkconf_geometry(BlockConf *conf, int *ptrans,
         hd_geometry_guess(conf->blk,
                           &conf->cyls, &conf->heads, &conf->secs,
                           ptrans);
-    } else if (ptrans && *ptrans == BIOS_ATA_TRANSLATION_AUTO) {
-        *ptrans = hd_bios_chs_auto_trans(conf->cyls, conf->heads, conf->secs);
+    //} else if (ptrans && *ptrans == BIOS_ATA_TRANSLATION_AUTO) {
+    //    *ptrans = hd_bios_chs_auto_trans(conf->cyls, conf->heads, conf->secs);
     }
     if (conf->cyls || conf->heads || conf->secs) {
         if (conf->cyls < 1 || conf->cyls > cyls_max) {
diff --git a/qcow2/lib/hw/block/hd-geometry.c b/qcow2/lib/hw/block/hd-geometry.c
index 2b0af443..498f7a81 100644
--- a/qcow2/lib/hw/block/hd-geometry.c
+++ b/qcow2/lib/hw/block/hd-geometry.c
@@ -35,7 +35,7 @@
 #include "qapi/qapi-types-block.h"
 #include "qemu/bswap.h"
 #include "hw/block/block.h"
-#include "trace.h"
+//#include "trace.h"
 
 struct partition {
         uint8_t boot_ind;           /* 0x80 - active */
@@ -88,7 +88,7 @@ static int guess_disk_lchs(BlockBackend *blk,
             *pheads = heads;
             *psectors = sectors;
             *pcylinders = cylinders;
-            trace_hd_geometry_lchs_guess(blk, cylinders, heads, sectors);
+            //trace_hd_geometry_lchs_guess(blk, cylinders, heads, sectors);
             return 0;
         }
     }
@@ -157,7 +157,7 @@ void hd_geometry_guess(BlockBackend *blk,
             translation = *ptrans;
         }
     }
-    trace_hd_geometry_guess(blk, *pcyls, *pheads, *psecs, translation);
+    //trace_hd_geometry_guess(blk, *pcyls, *pheads, *psecs, translation);
 }
 
 int hd_bios_chs_auto_trans(uint32_t cyls, uint32_t heads, uint32_t secs)
diff --git a/qcow2/lib/job-qmp.c b/qcow2/lib/job-qmp.c
index 9e26fa89..3b9cb0aa 100644
--- a/qcow2/lib/job-qmp.c
+++ b/qcow2/lib/job-qmp.c
@@ -27,7 +27,7 @@
 #include "qemu/job.h"
 #include "qapi/qapi-commands-job.h"
 #include "qapi/error.h"
-#include "trace/trace-root.h"
+//#include "trace/trace-root.h"
 
 /*
  * Get a job using its ID. Called with job_mutex held.
@@ -56,7 +56,7 @@ void qmp_job_cancel(const char *id, Error **errp)
         return;
     }
 
-    trace_qmp_job_cancel(job);
+    //trace_qmp_job_cancel(job);
     job_user_cancel_locked(job, true, errp);
 }
 
@@ -71,7 +71,7 @@ void qmp_job_pause(const char *id, Error **errp)
         return;
     }
 
-    trace_qmp_job_pause(job);
+    //trace_qmp_job_pause(job);
     job_user_pause_locked(job, errp);
 }
 
@@ -86,7 +86,7 @@ void qmp_job_resume(const char *id, Error **errp)
         return;
     }
 
-    trace_qmp_job_resume(job);
+    //trace_qmp_job_resume(job);
     job_user_resume_locked(job, errp);
 }
 
@@ -101,7 +101,7 @@ void qmp_job_complete(const char *id, Error **errp)
         return;
     }
 
-    trace_qmp_job_complete(job);
+    //trace_qmp_job_complete(job);
     job_complete_locked(job, errp);
 }
 
@@ -116,7 +116,7 @@ void qmp_job_finalize(const char *id, Error **errp)
         return;
     }
 
-    trace_qmp_job_finalize(job);
+    //trace_qmp_job_finalize(job);
     job_ref_locked(job);
     job_finalize_locked(job, errp);
 
@@ -134,7 +134,7 @@ void qmp_job_dismiss(const char *id, Error **errp)
         return;
     }
 
-    trace_qmp_job_dismiss(job);
+    //trace_qmp_job_dismiss(job);
     job_dismiss_locked(&job, errp);
 }
 
diff --git a/qcow2/lib/job.c b/qcow2/lib/job.c
index 660ce22c..63223a10 100644
--- a/qcow2/lib/job.c
+++ b/qcow2/lib/job.c
@@ -29,7 +29,7 @@
 #include "qemu/id.h"
 #include "qemu/main-loop.h"
 #include "block/aio-wait.h"
-#include "trace/trace-root.h"
+//#include "trace/trace-root.h"
 #include "qapi/qapi-events-job.h"
 
 /*
@@ -209,9 +209,9 @@ static void job_state_transition_locked(Job *job, JobStatus s1)
 {
     JobStatus s0 = job->status;
     assert(s1 >= 0 && s1 < JOB_STATUS__MAX);
-    trace_job_state_transition(job, job->ret,
-                               JobSTT[s0][s1] ? "allowed" : "disallowed",
-                               JobStatus_str(s0), JobStatus_str(s1));
+    //trace_job_state_transition(job, job->ret,
+    //                           JobSTT[s0][s1] ? "allowed" : "disallowed",
+    //                           JobStatus_str(s0), JobStatus_str(s1));
     assert(JobSTT[s0][s1]);
     job->status = s1;
 
@@ -224,8 +224,8 @@ int job_apply_verb_locked(Job *job, JobVerb verb, Error **errp)
 {
     JobStatus s0 = job->status;
     assert(verb >= 0 && verb < JOB_VERB__MAX);
-    trace_job_apply_verb(job, JobStatus_str(s0), JobVerb_str(verb),
-                         JobVerbTable[verb][s0] ? "allowed" : "prohibited");
+    //trace_job_apply_verb(job, JobStatus_str(s0), JobVerb_str(verb),
+    //                     JobVerbTable[verb][s0] ? "allowed" : "prohibited");
     if (JobVerbTable[verb][s0]) {
         return 0;
     }
@@ -1060,7 +1060,7 @@ static void job_completed_locked(Job *job)
     assert(job && job->txn && !job_is_completed_locked(job));
 
     job_update_rc_locked(job);
-    trace_job_completed(job, job->ret);
+    //trace_job_completed(job, job->ret);
     if (job->ret) {
         job_completed_txn_abort_locked(job);
     } else {
diff --git a/qcow2/lib/qapi/qapi-events-block-core.c b/qcow2/lib/qapi/qapi-events-block-core.c
index a08a710c..2c8a538c 100644
--- a/qcow2/lib/qapi/qapi-events-block-core.c
+++ b/qcow2/lib/qapi/qapi-events-block-core.c
@@ -12,8 +12,8 @@
 
 #include "qemu/osdep.h"
 #include "qapi-emit-events.h"
-#include "qapi-events-block-core.h"
-#include "qapi-visit-block-core.h"
+#include "qapi/qapi-events-block-core.h"
+#include "qapi/qapi-visit-block-core.h"
 #include "qapi/compat-policy.h"
 #include "qapi/error.h"
 #include "qapi/qmp/qdict.h"
@@ -43,7 +43,7 @@ void qapi_event_send_block_image_corrupted(const char *device, const char *node_
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_IMAGE_CORRUPTED, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_IMAGE_CORRUPTED, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -73,7 +73,7 @@ void qapi_event_send_block_io_error(const char *device, const char *node_name, I
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_IO_ERROR, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_IO_ERROR, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -103,7 +103,7 @@ void qapi_event_send_block_job_completed(JobType type, const char *device, int64
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_JOB_COMPLETED, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_JOB_COMPLETED, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -133,7 +133,7 @@ void qapi_event_send_block_job_cancelled(JobType type, const char *device, int64
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_JOB_CANCELLED, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_JOB_CANCELLED, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -163,7 +163,7 @@ void qapi_event_send_block_job_error(const char *device, IoOperationType operati
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_JOB_ERROR, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_JOB_ERROR, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -193,7 +193,7 @@ void qapi_event_send_block_job_ready(JobType type, const char *device, int64_t l
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_JOB_READY, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_JOB_READY, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -223,7 +223,7 @@ void qapi_event_send_block_job_pending(JobType type, const char *id)
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_JOB_PENDING, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_JOB_PENDING, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -253,7 +253,7 @@ void qapi_event_send_block_write_threshold(const char *node_name, uint64_t amoun
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_BLOCK_WRITE_THRESHOLD, qmp);
+    //qapi_event_emit(QAPI_EVENT_BLOCK_WRITE_THRESHOLD, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -283,7 +283,7 @@ void qapi_event_send_quorum_failure(const char *reference, int64_t sector_num, i
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_QUORUM_FAILURE, qmp);
+    //qapi_event_emit(QAPI_EVENT_QUORUM_FAILURE, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
@@ -313,7 +313,7 @@ void qapi_event_send_quorum_report_bad(QuorumOpType type, const char *error, con
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_QUORUM_REPORT_BAD, qmp);
+    //qapi_event_emit(QAPI_EVENT_QUORUM_REPORT_BAD, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
diff --git a/qcow2/lib/qapi/qapi-events-job.c b/qcow2/lib/qapi/qapi-events-job.c
index cb5c3b45..f96b8a30 100644
--- a/qcow2/lib/qapi/qapi-events-job.c
+++ b/qcow2/lib/qapi/qapi-events-job.c
@@ -12,8 +12,8 @@
 
 #include "qemu/osdep.h"
 #include "qapi-emit-events.h"
-#include "qapi-events-job.h"
-#include "qapi-visit-job.h"
+#include "qapi/qapi-events-job.h"
+#include "qapi/qapi-visit-job.h"
 #include "qapi/compat-policy.h"
 #include "qapi/error.h"
 #include "qapi/qmp/qdict.h"
@@ -43,7 +43,7 @@ void qapi_event_send_job_status_change(const char *id, JobStatus status)
     } else {
         qobject_unref(obj);
     }
-    qapi_event_emit(QAPI_EVENT_JOB_STATUS_CHANGE, qmp);
+    //qapi_event_emit(QAPI_EVENT_JOB_STATUS_CHANGE, qmp);
 
     visit_free(v);
     qobject_unref(qmp);
diff --git a/qcow2/lib/qapi/qapi-types-block-core.c b/qcow2/lib/qapi/qapi-types-block-core.c
index f4ee0d21..7e9cf7c7 100644
--- a/qcow2/lib/qapi/qapi-types-block-core.c
+++ b/qcow2/lib/qapi/qapi-types-block-core.c
@@ -12,8 +12,8 @@
 
 #include "qemu/osdep.h"
 #include "qapi/dealloc-visitor.h"
-#include "qapi-types-block-core.h"
-#include "qapi-visit-block-core.h"
+#include "qapi/qapi-types-block-core.h"
+#include "qapi/qapi-visit-block-core.h"
 
 void qapi_free_SnapshotInfo(SnapshotInfo *obj)
 {
@@ -28,6 +28,7 @@ void qapi_free_SnapshotInfo(SnapshotInfo *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_ImageInfoSpecificQCow2EncryptionBase(ImageInfoSpecificQCow2EncryptionBase *obj)
 {
     Visitor *v;
@@ -53,6 +54,7 @@ void qapi_free_ImageInfoSpecificQCow2Encryption(ImageInfoSpecificQCow2Encryption
     visit_type_ImageInfoSpecificQCow2Encryption(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_Qcow2BitmapInfoList(Qcow2BitmapInfoList *obj)
 {
@@ -80,6 +82,7 @@ void qapi_free_ImageInfoSpecificQCow2(ImageInfoSpecificQCow2 *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_VmdkExtentInfoList(VmdkExtentInfoList *obj)
 {
     Visitor *v;
@@ -131,6 +134,7 @@ void qapi_free_ImageInfoSpecificRbd(ImageInfoSpecificRbd *obj)
     visit_type_ImageInfoSpecificRbd(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_ImageInfoSpecificFile(ImageInfoSpecificFile *obj)
 {
@@ -148,14 +152,17 @@ void qapi_free_ImageInfoSpecificFile(ImageInfoSpecificFile *obj)
 const QEnumLookup ImageInfoSpecificKind_lookup = {
     .array = (const char *const[]) {
         [IMAGE_INFO_SPECIFIC_KIND_QCOW2] = "qcow2",
+#if 0
         [IMAGE_INFO_SPECIFIC_KIND_VMDK] = "vmdk",
         [IMAGE_INFO_SPECIFIC_KIND_LUKS] = "luks",
         [IMAGE_INFO_SPECIFIC_KIND_RBD] = "rbd",
+#endif
         [IMAGE_INFO_SPECIFIC_KIND_FILE] = "file",
     },
     .size = IMAGE_INFO_SPECIFIC_KIND__MAX
 };
 
+#if 0
 void qapi_free_ImageInfoSpecificQCow2Wrapper(ImageInfoSpecificQCow2Wrapper *obj)
 {
     Visitor *v;
@@ -220,6 +227,7 @@ void qapi_free_ImageInfoSpecificFileWrapper(ImageInfoSpecificFileWrapper *obj)
     visit_type_ImageInfoSpecificFileWrapper(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_ImageInfoSpecific(ImageInfoSpecific *obj)
 {
@@ -433,6 +441,7 @@ void qapi_free_Qcow2BitmapInfo(Qcow2BitmapInfo *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockLatencyHistogramInfo(BlockLatencyHistogramInfo *obj)
 {
     Visitor *v;
@@ -445,6 +454,7 @@ void qapi_free_BlockLatencyHistogramInfo(BlockLatencyHistogramInfo *obj)
     visit_type_BlockLatencyHistogramInfo(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockInfo(BlockInfo *obj)
 {
@@ -485,6 +495,7 @@ void qapi_free_BlockInfoList(BlockInfoList *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockDeviceTimedStats(BlockDeviceTimedStats *obj)
 {
     Visitor *v;
@@ -640,6 +651,7 @@ void qapi_free_BlockJobInfoMirror(BlockJobInfoMirror *obj)
     visit_type_BlockJobInfoMirror(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockJobInfo(BlockJobInfo *obj)
 {
@@ -667,6 +679,7 @@ void qapi_free_BlockJobInfoList(BlockJobInfoList *obj)
     visit_free(v);
 }
 
+#if 0
 const QEnumLookup NewImageMode_lookup = {
     .array = (const char *const[]) {
         [NEW_IMAGE_MODE_EXISTING] = "existing",
@@ -752,6 +765,7 @@ void qapi_free_BlockdevBackup(BlockdevBackup *obj)
     visit_type_BlockdevBackup(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockDeviceInfoList(BlockDeviceInfoList *obj)
 {
@@ -766,6 +780,7 @@ void qapi_free_BlockDeviceInfoList(BlockDeviceInfoList *obj)
     visit_free(v);
 }
 
+#if 0
 const QEnumLookup XDbgBlockGraphNodeType_lookup = {
     .array = (const char *const[]) {
         [X_DBG_BLOCK_GRAPH_NODE_TYPE_BLOCK_BACKEND] = "block-backend",
@@ -875,6 +890,7 @@ void qapi_free_DriveMirror(DriveMirror *obj)
     visit_type_DriveMirror(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockDirtyBitmap(BlockDirtyBitmap *obj)
 {
@@ -928,6 +944,7 @@ void qapi_free_BlockDirtyBitmapOrStrList(BlockDirtyBitmapOrStrList *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockDirtyBitmapMerge(BlockDirtyBitmapMerge *obj)
 {
     Visitor *v;
@@ -1018,6 +1035,7 @@ void qapi_free_BlockJobChangeOptions(BlockJobChangeOptions *obj)
     visit_type_BlockJobChangeOptions(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 const QEnumLookup BlockdevDiscardOptions_lookup = {
     .array = (const char *const[]) {
@@ -1142,6 +1160,7 @@ void qapi_free_BlockdevOptionsFile(BlockdevOptionsFile *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockdevOptionsNull(BlockdevOptionsNull *obj)
 {
     Visitor *v;
@@ -1206,6 +1225,7 @@ void qapi_free_BlockdevOptionsLUKS(BlockdevOptionsLUKS *obj)
     visit_type_BlockdevOptionsLUKS(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockdevOptionsGenericCOWFormat(BlockdevOptionsGenericCOWFormat *obj)
 {
@@ -1256,6 +1276,7 @@ void qapi_free_Qcow2OverlapChecks(Qcow2OverlapChecks *obj)
     visit_free(v);
 }
 
+#if 0
 const QEnumLookup BlockdevQcowEncryptionFormat_lookup = {
     .array = (const char *const[]) {
         [BLOCKDEV_QCOW_ENCRYPTION_FORMAT_AES] = "aes",
@@ -1322,6 +1343,7 @@ void qapi_free_BlockdevOptionsPreallocate(BlockdevOptionsPreallocate *obj)
     visit_type_BlockdevOptionsPreallocate(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockdevOptionsQcow2(BlockdevOptionsQcow2 *obj)
 {
@@ -1336,6 +1358,7 @@ void qapi_free_BlockdevOptionsQcow2(BlockdevOptionsQcow2 *obj)
     visit_free(v);
 }
 
+#if 0
 const QEnumLookup SshHostKeyCheckMode_lookup = {
     .array = (const char *const[]) {
         [SSH_HOST_KEY_CHECK_MODE_NONE] = "none",
@@ -2071,6 +2094,7 @@ void qapi_free_BlockdevOptionsCbw(BlockdevOptionsCbw *obj)
     visit_type_BlockdevOptionsCbw(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockdevOptions(BlockdevOptions *obj)
 {
@@ -2111,6 +2135,7 @@ void qapi_free_BlockdevRefOrNull(BlockdevRefOrNull *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockdevOptionsList(BlockdevOptionsList *obj)
 {
     Visitor *v;
@@ -2123,6 +2148,7 @@ void qapi_free_BlockdevOptionsList(BlockdevOptionsList *obj)
     visit_type_BlockdevOptionsList(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockdevCreateOptionsFile(BlockdevCreateOptionsFile *obj)
 {
@@ -2137,6 +2163,7 @@ void qapi_free_BlockdevCreateOptionsFile(BlockdevCreateOptionsFile *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockdevCreateOptionsGluster(BlockdevCreateOptionsGluster *obj)
 {
     Visitor *v;
@@ -2201,6 +2228,7 @@ void qapi_free_BlockdevCreateOptionsQcow(BlockdevCreateOptionsQcow *obj)
     visit_type_BlockdevCreateOptionsQcow(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 const QEnumLookup BlockdevQcow2Version_lookup = {
     .array = (const char *const[]) {
@@ -2233,6 +2261,7 @@ void qapi_free_BlockdevCreateOptionsQcow2(BlockdevCreateOptionsQcow2 *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockdevCreateOptionsQed(BlockdevCreateOptionsQed *obj)
 {
     Visitor *v;
@@ -2360,6 +2389,7 @@ void qapi_free_BlockdevCreateOptionsVpc(BlockdevCreateOptionsVpc *obj)
     visit_type_BlockdevCreateOptionsVpc(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockdevCreateOptions(BlockdevCreateOptions *obj)
 {
@@ -2374,6 +2404,7 @@ void qapi_free_BlockdevCreateOptions(BlockdevCreateOptions *obj)
     visit_free(v);
 }
 
+#if 0
 void qapi_free_BlockdevAmendOptionsLUKS(BlockdevAmendOptionsLUKS *obj)
 {
     Visitor *v;
@@ -2386,6 +2417,7 @@ void qapi_free_BlockdevAmendOptionsLUKS(BlockdevAmendOptionsLUKS *obj)
     visit_type_BlockdevAmendOptionsLUKS(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockdevAmendOptionsQcow2(BlockdevAmendOptionsQcow2 *obj)
 {
@@ -2441,6 +2473,7 @@ const QEnumLookup QuorumOpType_lookup = {
     .size = QUORUM_OP_TYPE__MAX
 };
 
+#if 0
 void qapi_free_BlockdevSnapshotInternal(BlockdevSnapshotInternal *obj)
 {
     Visitor *v;
@@ -2453,6 +2486,7 @@ void qapi_free_BlockdevSnapshotInternal(BlockdevSnapshotInternal *obj)
     visit_type_BlockdevSnapshotInternal(v, NULL, &obj, NULL);
     visit_free(v);
 }
+#endif
 
 void qapi_free_BlockGraphInfoList(BlockGraphInfoList *obj)
 {
diff --git a/qcow2/lib/qapi/qapi-types-common.c b/qcow2/lib/qapi/qapi-types-common.c
index 16045e73..f00b36f1 100644
--- a/qcow2/lib/qapi/qapi-types-common.c
+++ b/qcow2/lib/qapi/qapi-types-common.c
@@ -12,8 +12,8 @@
 
 #include "qemu/osdep.h"
 #include "qapi/dealloc-visitor.h"
-#include "qapi-types-common.h"
-#include "qapi-visit-common.h"
+#include "qapi/qapi-types-common.h"
+#include "qapi/qapi-visit-common.h"
 
 const QEnumLookup IoOperationType_lookup = {
     .array = (const char *const[]) {
diff --git a/qcow2/lib/qapi/qapi-types-job.c b/qcow2/lib/qapi/qapi-types-job.c
index eba27079..64010acb 100644
--- a/qcow2/lib/qapi/qapi-types-job.c
+++ b/qcow2/lib/qapi/qapi-types-job.c
@@ -12,8 +12,8 @@
 
 #include "qemu/osdep.h"
 #include "qapi/dealloc-visitor.h"
-#include "qapi-types-job.h"
-#include "qapi-visit-job.h"
+#include "qapi/qapi-types-job.h"
+#include "qapi/qapi-visit-job.h"
 
 const QEnumLookup JobType_lookup = {
     .array = (const char *const[]) {
diff --git a/qcow2/lib/qapi/qapi-visit-block-core.c b/qcow2/lib/qapi/qapi-visit-block-core.c
index b8d709cb..7e63d3f5 100644
--- a/qcow2/lib/qapi/qapi-visit-block-core.c
+++ b/qcow2/lib/qapi/qapi-visit-block-core.c
@@ -12,7 +12,7 @@
 
 #include "qemu/osdep.h"
 #include "qapi/error.h"
-#include "qapi-visit-block-core.h"
+#include "qapi/qapi-visit-block-core.h"
 
 bool visit_type_SnapshotInfo_members(Visitor *v, SnapshotInfo *obj, Error **errp)
 {
@@ -72,6 +72,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_ImageInfoSpecificQCow2EncryptionBase_members(Visitor *v, ImageInfoSpecificQCow2EncryptionBase *obj, Error **errp)
 {
     if (!visit_type_BlockdevQcow2EncryptionFormat(v, "format", &obj->format, errp)) {
@@ -149,6 +150,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_Qcow2BitmapInfoList(Visitor *v, const char *name,
                  Qcow2BitmapInfoList **obj, Error **errp)
@@ -181,7 +183,7 @@ out_obj:
 bool visit_type_ImageInfoSpecificQCow2_members(Visitor *v, ImageInfoSpecificQCow2 *obj, Error **errp)
 {
     bool has_data_file = !!obj->data_file;
-    bool has_encrypt = !!obj->encrypt;
+    //bool has_encrypt = !!obj->encrypt;
 
     if (!visit_type_str(v, "compat", &obj->compat, errp)) {
         return false;
@@ -214,11 +216,13 @@ bool visit_type_ImageInfoSpecificQCow2_members(Visitor *v, ImageInfoSpecificQCow
     if (!visit_type_int(v, "refcount-bits", &obj->refcount_bits, errp)) {
         return false;
     }
+#if 0
     if (visit_optional(v, "encrypt", &has_encrypt)) {
         if (!visit_type_ImageInfoSpecificQCow2Encryption(v, "encrypt", &obj->encrypt, errp)) {
             return false;
         }
     }
+#endif
     if (visit_optional(v, "bitmaps", &obj->has_bitmaps)) {
         if (!visit_type_Qcow2BitmapInfoList(v, "bitmaps", &obj->bitmaps, errp)) {
             return false;
@@ -257,6 +261,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_VmdkExtentInfoList(Visitor *v, const char *name,
                  VmdkExtentInfoList **obj, Error **errp)
 {
@@ -416,6 +421,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_ImageInfoSpecificFile_members(Visitor *v, ImageInfoSpecificFile *obj, Error **errp)
 {
@@ -471,6 +477,7 @@ bool visit_type_ImageInfoSpecificQCow2Wrapper_members(Visitor *v, ImageInfoSpeci
     return true;
 }
 
+#if 0
 bool visit_type_ImageInfoSpecificQCow2Wrapper(Visitor *v, const char *name,
                  ImageInfoSpecificQCow2Wrapper **obj, Error **errp)
 {
@@ -602,6 +609,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_ImageInfoSpecificFileWrapper_members(Visitor *v, ImageInfoSpecificFileWrapper *obj, Error **errp)
 {
@@ -611,6 +619,7 @@ bool visit_type_ImageInfoSpecificFileWrapper_members(Visitor *v, ImageInfoSpecif
     return true;
 }
 
+#if 0
 bool visit_type_ImageInfoSpecificFileWrapper(Visitor *v, const char *name,
                  ImageInfoSpecificFileWrapper **obj, Error **errp)
 {
@@ -637,6 +646,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_q_obj_ImageInfoSpecific_base_members(Visitor *v, q_obj_ImageInfoSpecific_base *obj, Error **errp)
 {
@@ -654,12 +664,14 @@ bool visit_type_ImageInfoSpecific_members(Visitor *v, ImageInfoSpecific *obj, Er
     switch (obj->type) {
     case IMAGE_INFO_SPECIFIC_KIND_QCOW2:
         return visit_type_ImageInfoSpecificQCow2Wrapper_members(v, &obj->u.qcow2, errp);
+#if 0
     case IMAGE_INFO_SPECIFIC_KIND_VMDK:
         return visit_type_ImageInfoSpecificVmdkWrapper_members(v, &obj->u.vmdk, errp);
     case IMAGE_INFO_SPECIFIC_KIND_LUKS:
         return visit_type_ImageInfoSpecificLUKSWrapper_members(v, &obj->u.luks, errp);
     case IMAGE_INFO_SPECIFIC_KIND_RBD:
         return visit_type_ImageInfoSpecificRbdWrapper_members(v, &obj->u.rbd, errp);
+#endif
     case IMAGE_INFO_SPECIFIC_KIND_FILE:
         return visit_type_ImageInfoSpecificFileWrapper_members(v, &obj->u.file, errp);
     default:
@@ -1497,6 +1509,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockLatencyHistogramInfo_members(Visitor *v, BlockLatencyHistogramInfo *obj, Error **errp)
 {
     if (!visit_type_uint64List(v, "boundaries", &obj->boundaries, errp)) {
@@ -1534,6 +1547,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockInfo_members(Visitor *v, BlockInfo *obj, Error **errp)
 {
@@ -1673,6 +1687,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockDeviceTimedStats_members(Visitor *v, BlockDeviceTimedStats *obj, Error **errp)
 {
     if (!visit_type_int(v, "interval_length", &obj->interval_length, errp)) {
@@ -2323,6 +2338,7 @@ bool visit_type_MirrorCopyMode(Visitor *v, const char *name,
     *obj = value;
     return ok;
 }
+#endif
 
 bool visit_type_BlockJobInfoMirror_members(Visitor *v, BlockJobInfoMirror *obj, Error **errp)
 {
@@ -2332,6 +2348,7 @@ bool visit_type_BlockJobInfoMirror_members(Visitor *v, BlockJobInfoMirror *obj,
     return true;
 }
 
+#if 0
 bool visit_type_BlockJobInfoMirror(Visitor *v, const char *name,
                  BlockJobInfoMirror **obj, Error **errp)
 {
@@ -2358,6 +2375,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_q_obj_BlockJobInfo_base_members(Visitor *v, q_obj_BlockJobInfo_base *obj, Error **errp)
 {
@@ -2492,6 +2510,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_q_obj_block_resize_arg_members(Visitor *v, q_obj_block_resize_arg *obj, Error **errp)
 {
     bool has_device = !!obj->device;
@@ -2977,6 +2996,7 @@ bool visit_type_q_obj_query_named_block_nodes_arg_members(Visitor *v, q_obj_quer
     }
     return true;
 }
+#endif
 
 bool visit_type_BlockDeviceInfoList(Visitor *v, const char *name,
                  BlockDeviceInfoList **obj, Error **errp)
@@ -3006,6 +3026,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_XDbgBlockGraphNodeType(Visitor *v, const char *name,
                  XDbgBlockGraphNodeType *obj, Error **errp)
 {
@@ -3349,6 +3370,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockDirtyBitmap_members(Visitor *v, BlockDirtyBitmap *obj, Error **errp)
 {
@@ -3517,6 +3539,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockDirtyBitmapMerge_members(Visitor *v, BlockDirtyBitmapMerge *obj, Error **errp)
 {
     if (!visit_type_str(v, "node", &obj->node, errp)) {
@@ -4397,6 +4420,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockdevDiscardOptions(Visitor *v, const char *name,
                  BlockdevDiscardOptions *obj, Error **errp)
@@ -4550,6 +4574,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockdevOptionsNull_members(Visitor *v, BlockdevOptionsNull *obj, Error **errp)
 {
     if (visit_optional(v, "size", &obj->has_size)) {
@@ -4691,6 +4716,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockdevOptionsGenericFormat_members(Visitor *v, BlockdevOptionsGenericFormat *obj, Error **errp)
 {
@@ -4700,6 +4726,7 @@ bool visit_type_BlockdevOptionsGenericFormat_members(Visitor *v, BlockdevOptions
     return true;
 }
 
+#if 0
 bool visit_type_BlockdevOptionsGenericFormat(Visitor *v, const char *name,
                  BlockdevOptionsGenericFormat **obj, Error **errp)
 {
@@ -4774,6 +4801,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockdevOptionsGenericCOWFormat_members(Visitor *v, BlockdevOptionsGenericCOWFormat *obj, Error **errp)
 {
@@ -4956,6 +4984,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockdevQcowEncryptionFormat(Visitor *v, const char *name,
                  BlockdevQcowEncryptionFormat *obj, Error **errp)
 {
@@ -5160,11 +5189,12 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockdevOptionsQcow2_members(Visitor *v, BlockdevOptionsQcow2 *obj, Error **errp)
 {
     bool has_overlap_check = !!obj->overlap_check;
-    bool has_encrypt = !!obj->encrypt;
+    //bool has_encrypt = !!obj->encrypt;
     bool has_data_file = !!obj->data_file;
 
     if (!visit_type_BlockdevOptionsGenericCOWFormat_members(v, (BlockdevOptionsGenericCOWFormat *)obj, errp)) {
@@ -5225,11 +5255,13 @@ bool visit_type_BlockdevOptionsQcow2_members(Visitor *v, BlockdevOptionsQcow2 *o
             return false;
         }
     }
+#if 0
     if (visit_optional(v, "encrypt", &has_encrypt)) {
         if (!visit_type_BlockdevQcow2Encryption(v, "encrypt", &obj->encrypt, errp)) {
             return false;
         }
     }
+#endif
     if (visit_optional(v, "data-file", &has_data_file)) {
         if (!visit_type_BlockdevRef(v, "data-file", &obj->data_file, errp)) {
             return false;
@@ -5265,6 +5297,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_SshHostKeyCheckMode(Visitor *v, const char *name,
                  SshHostKeyCheckMode *obj, Error **errp)
 {
@@ -5915,6 +5948,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockdevOptionsGluster_members(Visitor *v, BlockdevOptionsGluster *obj, Error **errp)
 {
     bool has_logfile = !!obj->logfile;
@@ -5967,6 +6001,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 #if defined(CONFIG_BLKIO)
 bool visit_type_BlockdevOptionsIoUring_members(Visitor *v, BlockdevOptionsIoUring *obj, Error **errp)
@@ -6153,6 +6188,7 @@ out_obj:
 }
 #endif /* defined(CONFIG_BLKIO) */
 
+#if 0
 bool visit_type_IscsiTransport(Visitor *v, const char *name,
                  IscsiTransport *obj, Error **errp)
 {
@@ -6739,6 +6775,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 #if defined(CONFIG_REPLICATION)
 bool visit_type_ReplicationMode(Visitor *v, const char *name,
@@ -7159,6 +7196,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockdevOptionsNbd_members(Visitor *v, BlockdevOptionsNbd *obj, Error **errp)
 {
     bool has_export = !!obj->export;
@@ -7233,6 +7271,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockdevOptionsRaw_members(Visitor *v, BlockdevOptionsRaw *obj, Error **errp)
 {
@@ -7422,6 +7461,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_q_obj_BlockdevOptions_base_members(Visitor *v, q_obj_BlockdevOptions_base *obj, Error **errp)
 {
@@ -7475,6 +7515,7 @@ bool visit_type_BlockdevOptions_members(Visitor *v, BlockdevOptions *obj, Error
         return false;
     }
     switch (obj->driver) {
+#if 0
     case BLOCKDEV_DRIVER_BLKDEBUG:
         return visit_type_BlockdevOptionsBlkdebug_members(v, &obj->u.blkdebug, errp);
     case BLOCKDEV_DRIVER_BLKLOGWRITES:
@@ -7495,8 +7536,10 @@ bool visit_type_BlockdevOptions_members(Visitor *v, BlockdevOptions *obj, Error
         return visit_type_BlockdevOptionsCor_members(v, &obj->u.copy_on_read, errp);
     case BLOCKDEV_DRIVER_DMG:
         return visit_type_BlockdevOptionsGenericFormat_members(v, &obj->u.dmg, errp);
+#endif
     case BLOCKDEV_DRIVER_FILE:
         return visit_type_BlockdevOptionsFile_members(v, &obj->u.file, errp);
+#if 0
     case BLOCKDEV_DRIVER_FTP:
         return visit_type_BlockdevOptionsCurlFtp_members(v, &obj->u.ftp, errp);
     case BLOCKDEV_DRIVER_FTPS:
@@ -7541,8 +7584,10 @@ bool visit_type_BlockdevOptions_members(Visitor *v, BlockdevOptions *obj, Error
         return visit_type_BlockdevOptionsGenericFormat_members(v, &obj->u.parallels, errp);
     case BLOCKDEV_DRIVER_PREALLOCATE:
         return visit_type_BlockdevOptionsPreallocate_members(v, &obj->u.preallocate, errp);
+#endif
     case BLOCKDEV_DRIVER_QCOW2:
         return visit_type_BlockdevOptionsQcow2_members(v, &obj->u.qcow2, errp);
+#if 0
     case BLOCKDEV_DRIVER_QCOW:
         return visit_type_BlockdevOptionsQcow_members(v, &obj->u.qcow, errp);
     case BLOCKDEV_DRIVER_QED:
@@ -7585,6 +7630,7 @@ bool visit_type_BlockdevOptions_members(Visitor *v, BlockdevOptions *obj, Error
         return visit_type_BlockdevOptionsGenericFormat_members(v, &obj->u.vpc, errp);
     case BLOCKDEV_DRIVER_VVFAT:
         return visit_type_BlockdevOptionsVVFAT_members(v, &obj->u.vvfat, errp);
+#endif
     default:
         abort();
     }
@@ -7717,6 +7763,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockdevOptionsList(Visitor *v, const char *name,
                  BlockdevOptionsList **obj, Error **errp)
 {
@@ -7760,6 +7807,7 @@ bool visit_type_q_obj_blockdev_del_arg_members(Visitor *v, q_obj_blockdev_del_ar
     }
     return true;
 }
+#endif
 
 bool visit_type_BlockdevCreateOptionsFile_members(Visitor *v, BlockdevCreateOptionsFile *obj, Error **errp)
 {
@@ -7814,6 +7862,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockdevCreateOptionsGluster_members(Visitor *v, BlockdevCreateOptionsGluster *obj, Error **errp)
 {
     if (!visit_type_BlockdevOptionsGluster(v, "location", &obj->location, errp)) {
@@ -8044,6 +8093,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockdevQcow2Version(Visitor *v, const char *name,
                  BlockdevQcow2Version *obj, Error **errp)
@@ -8067,7 +8117,7 @@ bool visit_type_BlockdevCreateOptionsQcow2_members(Visitor *v, BlockdevCreateOpt
 {
     bool has_data_file = !!obj->data_file;
     bool has_backing_file = !!obj->backing_file;
-    bool has_encrypt = !!obj->encrypt;
+    //bool has_encrypt = !!obj->encrypt;
 
     if (!visit_type_BlockdevRef(v, "file", &obj->file, errp)) {
         return false;
@@ -8105,11 +8155,13 @@ bool visit_type_BlockdevCreateOptionsQcow2_members(Visitor *v, BlockdevCreateOpt
             return false;
         }
     }
+#if 0
     if (visit_optional(v, "encrypt", &has_encrypt)) {
         if (!visit_type_QCryptoBlockCreateOptions(v, "encrypt", &obj->encrypt, errp)) {
             return false;
         }
     }
+#endif
     if (visit_optional(v, "cluster-size", &obj->has_cluster_size)) {
         if (!visit_type_size(v, "cluster-size", &obj->cluster_size, errp)) {
             return false;
@@ -8165,6 +8217,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_BlockdevCreateOptionsQed_members(Visitor *v, BlockdevCreateOptionsQed *obj, Error **errp)
 {
     bool has_backing_file = !!obj->backing_file;
@@ -8574,6 +8627,7 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_q_obj_BlockdevCreateOptions_base_members(Visitor *v, q_obj_BlockdevCreateOptions_base *obj, Error **errp)
 {
@@ -8591,6 +8645,7 @@ bool visit_type_BlockdevCreateOptions_members(Visitor *v, BlockdevCreateOptions
     switch (obj->driver) {
     case BLOCKDEV_DRIVER_FILE:
         return visit_type_BlockdevCreateOptionsFile_members(v, &obj->u.file, errp);
+#if 0
     case BLOCKDEV_DRIVER_GLUSTER:
         return visit_type_BlockdevCreateOptionsGluster_members(v, &obj->u.gluster, errp);
     case BLOCKDEV_DRIVER_LUKS:
@@ -8601,8 +8656,10 @@ bool visit_type_BlockdevCreateOptions_members(Visitor *v, BlockdevCreateOptions
         return visit_type_BlockdevCreateOptionsParallels_members(v, &obj->u.parallels, errp);
     case BLOCKDEV_DRIVER_QCOW:
         return visit_type_BlockdevCreateOptionsQcow_members(v, &obj->u.qcow, errp);
+#endif
     case BLOCKDEV_DRIVER_QCOW2:
         return visit_type_BlockdevCreateOptionsQcow2_members(v, &obj->u.qcow2, errp);
+#if 0
     case BLOCKDEV_DRIVER_QED:
         return visit_type_BlockdevCreateOptionsQed_members(v, &obj->u.qed, errp);
     case BLOCKDEV_DRIVER_RBD:
@@ -8699,6 +8756,7 @@ bool visit_type_BlockdevCreateOptions_members(Visitor *v, BlockdevCreateOptions
 #endif /* defined(CONFIG_BLKIO) */
     case BLOCKDEV_DRIVER_VVFAT:
         break;
+#endif
     default:
         abort();
     }
@@ -8732,6 +8790,7 @@ out_obj:
     return ok;
 }
 
+#if 0
 bool visit_type_q_obj_blockdev_create_arg_members(Visitor *v, q_obj_blockdev_create_arg *obj, Error **errp)
 {
     if (!visit_type_str(v, "job-id", &obj->job_id, errp)) {
@@ -8777,9 +8836,11 @@ out_obj:
     }
     return ok;
 }
+#endif
 
 bool visit_type_BlockdevAmendOptionsQcow2_members(Visitor *v, BlockdevAmendOptionsQcow2 *obj, Error **errp)
 {
+#if 0
     bool has_encrypt = !!obj->encrypt;
 
     if (visit_optional(v, "encrypt", &has_encrypt)) {
@@ -8787,6 +8848,7 @@ bool visit_type_BlockdevAmendOptionsQcow2_members(Visitor *v, BlockdevAmendOptio
             return false;
         }
     }
+#endif
     return true;
 }
 
@@ -8831,10 +8893,13 @@ bool visit_type_BlockdevAmendOptions_members(Visitor *v, BlockdevAmendOptions *o
         return false;
     }
     switch (obj->driver) {
+#if 0
     case BLOCKDEV_DRIVER_LUKS:
         return visit_type_BlockdevAmendOptionsLUKS_members(v, &obj->u.luks, errp);
+#endif
     case BLOCKDEV_DRIVER_QCOW2:
         return visit_type_BlockdevAmendOptionsQcow2_members(v, &obj->u.qcow2, errp);
+#if 0
     case BLOCKDEV_DRIVER_BLKDEBUG:
         break;
     case BLOCKDEV_DRIVER_BLKLOGWRITES:
@@ -8855,8 +8920,10 @@ bool visit_type_BlockdevAmendOptions_members(Visitor *v, BlockdevAmendOptions *o
         break;
     case BLOCKDEV_DRIVER_DMG:
         break;
+#endif
     case BLOCKDEV_DRIVER_FILE:
         break;
+#if 0
     case BLOCKDEV_DRIVER_SNAPSHOT_ACCESS:
         break;
     case BLOCKDEV_DRIVER_FTP:
@@ -8941,6 +9008,7 @@ bool visit_type_BlockdevAmendOptions_members(Visitor *v, BlockdevAmendOptions *o
         break;
     case BLOCKDEV_DRIVER_VVFAT:
         break;
+#endif
     default:
         abort();
     }
@@ -9177,6 +9245,7 @@ bool visit_type_q_obj_BLOCK_WRITE_THRESHOLD_arg_members(Visitor *v, q_obj_BLOCK_
     return true;
 }
 
+#if 0
 bool visit_type_q_obj_block_set_write_threshold_arg_members(Visitor *v, q_obj_block_set_write_threshold_arg *obj, Error **errp)
 {
     if (!visit_type_str(v, "node-name", &obj->node_name, errp)) {
@@ -9224,6 +9293,7 @@ bool visit_type_q_obj_x_blockdev_set_iothread_arg_members(Visitor *v, q_obj_x_bl
     }
     return true;
 }
+#endif
 
 bool visit_type_QuorumOpType(Visitor *v, const char *name,
                  QuorumOpType *obj, Error **errp)
@@ -9272,6 +9342,7 @@ bool visit_type_q_obj_QUORUM_REPORT_BAD_arg_members(Visitor *v, q_obj_QUORUM_REP
     return true;
 }
 
+#if 0
 bool visit_type_BlockdevSnapshotInternal_members(Visitor *v, BlockdevSnapshotInternal *obj, Error **errp)
 {
     if (!visit_type_str(v, "device", &obj->device, errp)) {
@@ -9330,6 +9401,7 @@ bool visit_type_q_obj_blockdev_snapshot_delete_internal_sync_arg_members(Visitor
     }
     return true;
 }
+#endif
 
 bool visit_type_BlockGraphInfoList(Visitor *v, const char *name,
                  BlockGraphInfoList **obj, Error **errp)
diff --git a/qcow2/lib/qapi/qapi-visit-common.c b/qcow2/lib/qapi/qapi-visit-common.c
index cacb730a..96e8d05f 100644
--- a/qcow2/lib/qapi/qapi-visit-common.c
+++ b/qcow2/lib/qapi/qapi-visit-common.c
@@ -12,7 +12,7 @@
 
 #include "qemu/osdep.h"
 #include "qapi/error.h"
-#include "qapi-visit-common.h"
+#include "qapi/qapi-visit-common.h"
 
 bool visit_type_IoOperationType(Visitor *v, const char *name,
                  IoOperationType *obj, Error **errp)
diff --git a/qcow2/lib/qapi/qapi-visit-core.c b/qcow2/lib/qapi/qapi-visit-core.c
index 6c13510a..895f89fd 100644
--- a/qcow2/lib/qapi/qapi-visit-core.c
+++ b/qcow2/lib/qapi/qapi-visit-core.c
@@ -18,7 +18,7 @@
 #include "qapi/qmp/qerror.h"
 #include "qapi/visitor.h"
 #include "qapi/visitor-impl.h"
-#include "trace.h"
+//#include "trace.h"
 
 /* Zero-initialization must result in default policy */
 QEMU_BUILD_BUG_ON(COMPAT_POLICY_INPUT_ACCEPT || COMPAT_POLICY_OUTPUT_ACCEPT);
@@ -27,7 +27,7 @@ QEMU_BUILD_BUG_ON(COMPAT_POLICY_INPUT_ACCEPT || COMPAT_POLICY_OUTPUT_ACCEPT);
 void visit_complete(Visitor *v, void *opaque)
 {
     assert(v->type != VISITOR_OUTPUT || v->complete);
-    trace_visit_complete(v, opaque);
+    //trace_visit_complete(v, opaque);
     if (v->complete) {
         v->complete(v, opaque);
     }
@@ -35,7 +35,7 @@ void visit_complete(Visitor *v, void *opaque)
 
 void visit_free(Visitor *v)
 {
-    trace_visit_free(v);
+    //trace_visit_free(v);
     if (v) {
         v->free(v);
     }
@@ -46,7 +46,7 @@ bool visit_start_struct(Visitor *v, const char *name, void **obj,
 {
     bool ok;
 
-    trace_visit_start_struct(v, name, obj, size);
+    //trace_visit_start_struct(v, name, obj, size);
     if (obj) {
         assert(size);
         assert(!(v->type & VISITOR_OUTPUT) || *obj);
@@ -60,13 +60,13 @@ bool visit_start_struct(Visitor *v, const char *name, void **obj,
 
 bool visit_check_struct(Visitor *v, Error **errp)
 {
-    trace_visit_check_struct(v);
+    //trace_visit_check_struct(v);
     return v->check_struct ? v->check_struct(v, errp) : true;
 }
 
 void visit_end_struct(Visitor *v, void **obj)
 {
-    trace_visit_end_struct(v, obj);
+    //trace_visit_end_struct(v, obj);
     v->end_struct(v, obj);
 }
 
@@ -76,7 +76,7 @@ bool visit_start_list(Visitor *v, const char *name, GenericList **list,
     bool ok;
 
     assert(!list || size >= sizeof(GenericList));
-    trace_visit_start_list(v, name, list, size);
+    //trace_visit_start_list(v, name, list, size);
     ok = v->start_list(v, name, list, size, errp);
     if (list && (v->type & VISITOR_INPUT)) {
         assert(ok || !*list);
@@ -87,19 +87,19 @@ bool visit_start_list(Visitor *v, const char *name, GenericList **list,
 GenericList *visit_next_list(Visitor *v, GenericList *tail, size_t size)
 {
     assert(tail && size >= sizeof(GenericList));
-    trace_visit_next_list(v, tail, size);
+    //trace_visit_next_list(v, tail, size);
     return v->next_list(v, tail, size);
 }
 
 bool visit_check_list(Visitor *v, Error **errp)
 {
-    trace_visit_check_list(v);
+    //trace_visit_check_list(v);
     return v->check_list ? v->check_list(v, errp) : true;
 }
 
 void visit_end_list(Visitor *v, void **obj)
 {
-    trace_visit_end_list(v, obj);
+    //trace_visit_end_list(v, obj);
     v->end_list(v, obj);
 }
 
@@ -111,7 +111,7 @@ bool visit_start_alternate(Visitor *v, const char *name,
 
     assert(obj && size >= sizeof(GenericAlternate));
     assert(!(v->type & VISITOR_OUTPUT) || *obj);
-    trace_visit_start_alternate(v, name, obj, size);
+    //trace_visit_start_alternate(v, name, obj, size);
     if (!v->start_alternate) {
         assert(!(v->type & VISITOR_INPUT));
         return true;
@@ -125,7 +125,7 @@ bool visit_start_alternate(Visitor *v, const char *name,
 
 void visit_end_alternate(Visitor *v, void **obj)
 {
-    trace_visit_end_alternate(v, obj);
+    //trace_visit_end_alternate(v, obj);
     if (v->end_alternate) {
         v->end_alternate(v, obj);
     }
@@ -133,7 +133,7 @@ void visit_end_alternate(Visitor *v, void **obj)
 
 bool visit_optional(Visitor *v, const char *name, bool *present)
 {
-    trace_visit_optional(v, name, present);
+    //trace_visit_optional(v, name, present);
     if (v->optional) {
         v->optional(v, name, present);
     }
@@ -143,7 +143,7 @@ bool visit_optional(Visitor *v, const char *name, bool *present)
 bool visit_policy_reject(Visitor *v, const char *name,
                          unsigned special_features, Error **errp)
 {
-    trace_visit_policy_reject(v, name);
+    //trace_visit_policy_reject(v, name);
     if (v->policy_reject) {
         return v->policy_reject(v, name, special_features, errp);
     }
@@ -153,7 +153,7 @@ bool visit_policy_reject(Visitor *v, const char *name,
 bool visit_policy_skip(Visitor *v, const char *name,
                        unsigned special_features)
 {
-    trace_visit_policy_skip(v, name);
+    //trace_visit_policy_skip(v, name);
     if (v->policy_skip) {
         return v->policy_skip(v, name, special_features);
     }
@@ -178,7 +178,7 @@ bool visit_is_dealloc(Visitor *v)
 bool visit_type_int(Visitor *v, const char *name, int64_t *obj, Error **errp)
 {
     assert(obj);
-    trace_visit_type_int(v, name, obj);
+    //trace_visit_type_int(v, name, obj);
     return v->type_int64(v, name, obj, errp);
 }
 
@@ -208,7 +208,7 @@ bool visit_type_uint8(Visitor *v, const char *name, uint8_t *obj,
     uint64_t value;
     bool ok;
 
-    trace_visit_type_uint8(v, name, obj);
+    //trace_visit_type_uint8(v, name, obj);
     value = *obj;
     ok = visit_type_uintN(v, &value, name, UINT8_MAX, "uint8_t", errp);
     *obj = value;
@@ -221,7 +221,7 @@ bool visit_type_uint16(Visitor *v, const char *name, uint16_t *obj,
     uint64_t value;
     bool ok;
 
-    trace_visit_type_uint16(v, name, obj);
+    //trace_visit_type_uint16(v, name, obj);
     value = *obj;
     ok = visit_type_uintN(v, &value, name, UINT16_MAX, "uint16_t", errp);
     *obj = value;
@@ -234,7 +234,7 @@ bool visit_type_uint32(Visitor *v, const char *name, uint32_t *obj,
     uint64_t value;
     bool ok;
 
-    trace_visit_type_uint32(v, name, obj);
+    //trace_visit_type_uint32(v, name, obj);
     value = *obj;
     ok = visit_type_uintN(v, &value, name, UINT32_MAX, "uint32_t", errp);
     *obj = value;
@@ -245,7 +245,7 @@ bool visit_type_uint64(Visitor *v, const char *name, uint64_t *obj,
                        Error **errp)
 {
     assert(obj);
-    trace_visit_type_uint64(v, name, obj);
+    //trace_visit_type_uint64(v, name, obj);
     return v->type_uint64(v, name, obj, errp);
 }
 
@@ -275,7 +275,7 @@ bool visit_type_int8(Visitor *v, const char *name, int8_t *obj, Error **errp)
     int64_t value;
     bool ok;
 
-    trace_visit_type_int8(v, name, obj);
+    //trace_visit_type_int8(v, name, obj);
     value = *obj;
     ok = visit_type_intN(v, &value, name, INT8_MIN, INT8_MAX, "int8_t", errp);
     *obj = value;
@@ -288,7 +288,7 @@ bool visit_type_int16(Visitor *v, const char *name, int16_t *obj,
     int64_t value;
     bool ok;
 
-    trace_visit_type_int16(v, name, obj);
+    //trace_visit_type_int16(v, name, obj);
     value = *obj;
     ok = visit_type_intN(v, &value, name, INT16_MIN, INT16_MAX, "int16_t",
                          errp);
@@ -302,7 +302,7 @@ bool visit_type_int32(Visitor *v, const char *name, int32_t *obj,
     int64_t value;
     bool ok;
 
-    trace_visit_type_int32(v, name, obj);
+    //trace_visit_type_int32(v, name, obj);
     value = *obj;
     ok = visit_type_intN(v, &value, name, INT32_MIN, INT32_MAX, "int32_t",
                         errp);
@@ -314,7 +314,7 @@ bool visit_type_int64(Visitor *v, const char *name, int64_t *obj,
                       Error **errp)
 {
     assert(obj);
-    trace_visit_type_int64(v, name, obj);
+    //trace_visit_type_int64(v, name, obj);
     return v->type_int64(v, name, obj, errp);
 }
 
@@ -322,7 +322,7 @@ bool visit_type_size(Visitor *v, const char *name, uint64_t *obj,
                      Error **errp)
 {
     assert(obj);
-    trace_visit_type_size(v, name, obj);
+    //trace_visit_type_size(v, name, obj);
     if (v->type_size) {
         return v->type_size(v, name, obj, errp);
     }
@@ -332,7 +332,7 @@ bool visit_type_size(Visitor *v, const char *name, uint64_t *obj,
 bool visit_type_bool(Visitor *v, const char *name, bool *obj, Error **errp)
 {
     assert(obj);
-    trace_visit_type_bool(v, name, obj);
+    //trace_visit_type_bool(v, name, obj);
     return v->type_bool(v, name, obj, errp);
 }
 
@@ -345,7 +345,7 @@ bool visit_type_str(Visitor *v, const char *name, char **obj, Error **errp)
      * can enable:
     assert(!(v->type & VISITOR_OUTPUT) || *obj);
      */
-    trace_visit_type_str(v, name, obj);
+    //trace_visit_type_str(v, name, obj);
     ok = v->type_str(v, name, obj, errp);
     if (v->type & VISITOR_INPUT) {
         assert(ok != !*obj);
@@ -357,7 +357,7 @@ bool visit_type_number(Visitor *v, const char *name, double *obj,
                        Error **errp)
 {
     assert(obj);
-    trace_visit_type_number(v, name, obj);
+    //trace_visit_type_number(v, name, obj);
     return v->type_number(v, name, obj, errp);
 }
 
@@ -367,7 +367,7 @@ bool visit_type_any(Visitor *v, const char *name, QObject **obj, Error **errp)
 
     assert(obj);
     assert(v->type != VISITOR_OUTPUT || *obj);
-    trace_visit_type_any(v, name, obj);
+    //trace_visit_type_any(v, name, obj);
     ok = v->type_any(v, name, obj, errp);
     if (v->type == VISITOR_INPUT) {
         assert(ok != !*obj);
@@ -378,7 +378,7 @@ bool visit_type_any(Visitor *v, const char *name, QObject **obj, Error **errp)
 bool visit_type_null(Visitor *v, const char *name, QNull **obj,
                      Error **errp)
 {
-    trace_visit_type_null(v, name, obj);
+    //trace_visit_type_null(v, name, obj);
     return v->type_null(v, name, obj, errp);
 }
 
@@ -425,7 +425,7 @@ bool visit_type_enum(Visitor *v, const char *name, int *obj,
                      const QEnumLookup *lookup, Error **errp)
 {
     assert(obj && lookup);
-    trace_visit_type_enum(v, name, obj);
+    //trace_visit_type_enum(v, name, obj);
     switch (v->type) {
     case VISITOR_INPUT:
         return input_type_enum(v, name, obj, lookup, errp);
diff --git a/qcow2/lib/qapi/qapi-visit-job.c b/qcow2/lib/qapi/qapi-visit-job.c
index 092f9a03..77c6bcd0 100644
--- a/qcow2/lib/qapi/qapi-visit-job.c
+++ b/qcow2/lib/qapi/qapi-visit-job.c
@@ -12,7 +12,7 @@
 
 #include "qemu/osdep.h"
 #include "qapi/error.h"
-#include "qapi-visit-job.h"
+#include "qapi/qapi-visit-job.h"
 
 bool visit_type_JobType(Visitor *v, const char *name,
                  JobType *obj, Error **errp)
diff --git a/qcow2/lib/qapi/qmp-dispatch.c b/qcow2/lib/qapi/qmp-dispatch.c
index 176b5494..1bce84ea 100644
--- a/qcow2/lib/qapi/qmp-dispatch.c
+++ b/qcow2/lib/qapi/qmp-dispatch.c
@@ -41,6 +41,7 @@ Visitor *qobject_output_visitor_new_qmp(QObject **result)
     return v;
 }
 
+#if 0
 static QDict *qmp_dispatch_check_obj(QDict *dict, bool allow_oob,
                                      Error **errp)
 {
@@ -294,3 +295,4 @@ out:
 
     return rsp;
 }
+#endif
diff --git a/qcow2/lib/qapi/qobject-input-visitor.c b/qcow2/lib/qapi/qobject-input-visitor.c
index f110a804..408ade81 100644
--- a/qcow2/lib/qapi/qobject-input-visitor.c
+++ b/qcow2/lib/qapi/qobject-input-visitor.c
@@ -28,7 +28,7 @@
 #include "qapi/qmp/qnum.h"
 #include "qapi/qmp/qstring.h"
 #include "qemu/cutils.h"
-#include "qemu/keyval.h"
+//#include "qemu/keyval.h"
 
 typedef struct StackObject {
     const char *name;            /* Name of @obj in its parent, if any */
@@ -746,6 +746,7 @@ Visitor *qobject_input_visitor_new_keyval(QObject *obj)
     return &v->visitor;
 }
 
+#if 0
 Visitor *qobject_input_visitor_new_str(const char *str,
                                        const char *implied_key,
                                        Error **errp)
@@ -774,3 +775,4 @@ Visitor *qobject_input_visitor_new_str(const char *str,
 
     return v;
 }
+#endif
diff --git a/qcow2/lib/qcow2-cache.c b/qcow2/lib/qcow2-cache.c
index 23d9588b..11453579 100644
--- a/qcow2/lib/qcow2-cache.c
+++ b/qcow2/lib/qcow2-cache.c
@@ -26,7 +26,7 @@
 #include "block/block-io.h"
 #include "qemu/memalign.h"
 #include "qcow2.h"
-#include "trace.h"
+//#include "trace.h"
 
 typedef struct Qcow2CachedTable {
     int64_t  offset;
@@ -189,8 +189,8 @@ qcow2_cache_entry_flush(BlockDriverState *bs, Qcow2Cache *c, int i)
         return 0;
     }
 
-    trace_qcow2_cache_entry_flush(qemu_coroutine_self(),
-                                  c == s->l2_table_cache, i);
+    //trace_qcow2_cache_entry_flush(qemu_coroutine_self(),
+    //                              c == s->l2_table_cache, i);
 
     if (c->depends) {
         ret = qcow2_cache_flush_dependency(bs, c);
@@ -239,12 +239,12 @@ qcow2_cache_entry_flush(BlockDriverState *bs, Qcow2Cache *c, int i)
 
 int qcow2_cache_write(BlockDriverState *bs, Qcow2Cache *c)
 {
-    BDRVQcow2State *s = bs->opaque;
+    //BDRVQcow2State *s = bs->opaque;
     int result = 0;
     int ret;
     int i;
 
-    trace_qcow2_cache_flush(qemu_coroutine_self(), c == s->l2_table_cache);
+    //trace_qcow2_cache_flush(qemu_coroutine_self(), c == s->l2_table_cache);
 
     for (i = 0; i < c->size; i++) {
         ret = qcow2_cache_entry_flush(bs, c, i);
@@ -333,8 +333,8 @@ qcow2_cache_do_get(BlockDriverState *bs, Qcow2Cache *c, uint64_t offset,
 
     assert(offset != 0);
 
-    trace_qcow2_cache_get(qemu_coroutine_self(), c == s->l2_table_cache,
-                          offset, read_from_disk);
+    //trace_qcow2_cache_get(qemu_coroutine_self(), c == s->l2_table_cache,
+    //                      offset, read_from_disk);
 
     if (!QEMU_IS_ALIGNED(offset, c->table_size)) {
         qcow2_signal_corruption(bs, true, -1, -1, "Cannot get entry from %s "
@@ -367,16 +367,16 @@ qcow2_cache_do_get(BlockDriverState *bs, Qcow2Cache *c, uint64_t offset,
 
     /* Cache miss: write a table back and replace it */
     i = min_lru_index;
-    trace_qcow2_cache_get_replace_entry(qemu_coroutine_self(),
-                                        c == s->l2_table_cache, i);
+    //trace_qcow2_cache_get_replace_entry(qemu_coroutine_self(),
+    //                                    c == s->l2_table_cache, i);
 
     ret = qcow2_cache_entry_flush(bs, c, i);
     if (ret < 0) {
         return ret;
     }
 
-    trace_qcow2_cache_get_read(qemu_coroutine_self(),
-                               c == s->l2_table_cache, i);
+    //trace_qcow2_cache_get_read(qemu_coroutine_self(),
+    //                           c == s->l2_table_cache, i);
     c->entries[i].offset = 0;
     if (read_from_disk) {
         if (c == s->l2_table_cache) {
@@ -397,8 +397,8 @@ found:
     c->entries[i].ref++;
     *table = qcow2_cache_get_table_addr(c, i);
 
-    trace_qcow2_cache_get_done(qemu_coroutine_self(),
-                               c == s->l2_table_cache, i);
+    //trace_qcow2_cache_get_done(qemu_coroutine_self(),
+    //                           c == s->l2_table_cache, i);
 
     return 0;
 }
diff --git a/qcow2/lib/qcow2-cluster.c b/qcow2/lib/qcow2-cluster.c
index ce8c0076..f71ff791 100644
--- a/qcow2/lib/qcow2-cluster.c
+++ b/qcow2/lib/qcow2-cluster.c
@@ -30,7 +30,7 @@
 #include "qcow2.h"
 #include "qemu/bswap.h"
 #include "qemu/memalign.h"
-#include "trace.h"
+//#include "trace.h"
 
 int coroutine_fn qcow2_shrink_l1_table(BlockDriverState *bs,
                                        uint64_t exact_size)
@@ -281,7 +281,7 @@ static int GRAPH_RDLOCK l2_allocate(BlockDriverState *bs, int l1_index)
 
     old_l2_offset = s->l1_table[l1_index];
 
-    trace_qcow2_l2_allocate(bs, l1_index);
+    //trace_qcow2_l2_allocate(bs, l1_index);
 
     /* allocate a new l2 entry */
 
@@ -312,7 +312,7 @@ static int GRAPH_RDLOCK l2_allocate(BlockDriverState *bs, int l1_index)
     slice_size2 = s->l2_slice_size * l2_entry_size(s);
     n_slices = s->cluster_size / slice_size2;
 
-    trace_qcow2_l2_allocate_get_empty(bs, l1_index);
+    //trace_qcow2_l2_allocate_get_empty(bs, l1_index);
     for (slice = 0; slice < n_slices; slice++) {
         ret = qcow2_cache_get_empty(bs, s->l2_table_cache,
                                     l2_offset + slice * slice_size2,
@@ -345,7 +345,7 @@ static int GRAPH_RDLOCK l2_allocate(BlockDriverState *bs, int l1_index)
         /* write the l2 slice to the file */
         BLKDBG_EVENT(bs->file, BLKDBG_L2_ALLOC_WRITE);
 
-        trace_qcow2_l2_allocate_write_l2(bs, l1_index);
+        //trace_qcow2_l2_allocate_write_l2(bs, l1_index);
         qcow2_cache_entry_mark_dirty(s->l2_table_cache, l2_slice);
         qcow2_cache_put(s->l2_table_cache, (void **) &l2_slice);
     }
@@ -356,18 +356,18 @@ static int GRAPH_RDLOCK l2_allocate(BlockDriverState *bs, int l1_index)
     }
 
     /* update the L1 entry */
-    trace_qcow2_l2_allocate_write_l1(bs, l1_index);
+    //trace_qcow2_l2_allocate_write_l1(bs, l1_index);
     s->l1_table[l1_index] = l2_offset | QCOW_OFLAG_COPIED;
     ret = qcow2_write_l1_entry(bs, l1_index);
     if (ret < 0) {
         goto fail;
     }
 
-    trace_qcow2_l2_allocate_done(bs, l1_index, 0);
+    //trace_qcow2_l2_allocate_done(bs, l1_index, 0);
     return 0;
 
 fail:
-    trace_qcow2_l2_allocate_done(bs, l1_index, ret);
+    //trace_qcow2_l2_allocate_done(bs, l1_index, ret);
     if (l2_slice != NULL) {
         qcow2_cache_put(s->l2_table_cache, (void **) &l2_slice);
     }
@@ -959,6 +959,7 @@ perform_cow(BlockDriverState *bs, QCowL2Meta *m)
         goto fail;
     }
 
+#if 0
     /* Encrypt the data if necessary before writing it */
     if (bs->encrypted) {
         ret = qcow2_co_encrypt(bs,
@@ -977,6 +978,7 @@ perform_cow(BlockDriverState *bs, QCowL2Meta *m)
             goto fail;
         }
     }
+#endif
 
     /* And now we can write everything. If we have the guest data we
      * can write everything in one single operation */
@@ -1033,7 +1035,7 @@ int coroutine_fn qcow2_alloc_cluster_link_l2(BlockDriverState *bs,
     uint64_t *old_cluster, *l2_slice;
     uint64_t cluster_offset = m->alloc_offset;
 
-    trace_qcow2_cluster_link_l2(qemu_coroutine_self(), m->nb_clusters);
+    //trace_qcow2_cluster_link_l2(qemu_coroutine_self(), m->nb_clusters);
     assert(m->nb_clusters > 0);
 
     old_cluster = g_try_new(uint64_t, m->nb_clusters);
@@ -1503,8 +1505,8 @@ handle_copied(BlockDriverState *bs, uint64_t guest_offset,
     unsigned int keep_clusters;
     int ret;
 
-    trace_qcow2_handle_copied(qemu_coroutine_self(), guest_offset, *host_offset,
-                              *bytes);
+    //trace_qcow2_handle_copied(qemu_coroutine_self(), guest_offset, *host_offset,
+    //                          *bytes);
 
     assert(*host_offset == INV_OFFSET || offset_into_cluster(s, guest_offset)
                                       == offset_into_cluster(s, *host_offset));
@@ -1607,8 +1609,8 @@ do_alloc_cluster_offset(BlockDriverState *bs, uint64_t guest_offset,
 {
     BDRVQcow2State *s = bs->opaque;
 
-    trace_qcow2_do_alloc_clusters_offset(qemu_coroutine_self(), guest_offset,
-                                         *host_offset, *nb_clusters);
+    //trace_qcow2_do_alloc_clusters_offset(qemu_coroutine_self(), guest_offset,
+    //                                     *host_offset, *nb_clusters);
 
     if (has_data_file(bs)) {
         assert(*host_offset == INV_OFFSET ||
@@ -1618,7 +1620,7 @@ do_alloc_cluster_offset(BlockDriverState *bs, uint64_t guest_offset,
     }
 
     /* Allocate new clusters */
-    trace_qcow2_cluster_alloc_phys(qemu_coroutine_self());
+    //trace_qcow2_cluster_alloc_phys(qemu_coroutine_self());
     if (*host_offset == INV_OFFSET) {
         int64_t cluster_offset =
             qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
@@ -1670,8 +1672,8 @@ handle_alloc(BlockDriverState *bs, uint64_t guest_offset,
 
     uint64_t alloc_cluster_offset;
 
-    trace_qcow2_handle_alloc(qemu_coroutine_self(), guest_offset, *host_offset,
-                             *bytes);
+    //trace_qcow2_handle_alloc(qemu_coroutine_self(), guest_offset, *host_offset,
+    //                         *bytes);
     assert(*bytes > 0);
 
     /*
@@ -1791,7 +1793,7 @@ int coroutine_fn qcow2_alloc_host_offset(BlockDriverState *bs, uint64_t offset,
     uint64_t cur_bytes;
     int ret;
 
-    trace_qcow2_alloc_clusters_offset(qemu_coroutine_self(), offset, *bytes);
+    //trace_qcow2_alloc_clusters_offset(qemu_coroutine_self(), offset, *bytes);
 
 again:
     start = offset;
diff --git a/qcow2/lib/qcow2-refcount.c b/qcow2/lib/qcow2-refcount.c
index 0266542c..9442522a 100644
--- a/qcow2/lib/qcow2-refcount.c
+++ b/qcow2/lib/qcow2-refcount.c
@@ -30,7 +30,7 @@
 #include "qemu/bswap.h"
 #include "qemu/cutils.h"
 #include "qemu/memalign.h"
-#include "trace.h"
+//#include "trace.h"
 
 static int64_t alloc_clusters_noref(BlockDriverState *bs, uint64_t size,
                                     uint64_t max);
@@ -745,8 +745,7 @@ void qcow2_process_discards(BlockDriverState *bs, int ret)
         if (ret >= 0) {
             int r2 = bdrv_pdiscard(bs->file, d->offset, d->bytes);
             if (r2 < 0) {
-                trace_qcow2_process_discards_failed_region(d->offset, d->bytes,
-                                                           r2);
+                //trace_qcow2_process_discards_failed_region(d->offset, d->bytes, r2);
             }
         }
 
@@ -2277,6 +2276,7 @@ calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,
         return ret;
     }
 
+#if 0
     /* encryption */
     if (s->crypto_header.length) {
         ret = qcow2_inc_refcounts_imrt(bs, res, refcount_table, nb_clusters,
@@ -2286,6 +2286,7 @@ calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,
             return ret;
         }
     }
+#endif
 
     /* bitmaps */
     ret = qcow2_check_bitmaps_refcounts(bs, res, refcount_table, nb_clusters);
diff --git a/qcow2/lib/qcow2-threads.c b/qcow2/lib/qcow2-threads.c
index d6071a1e..f6de6e60 100644
--- a/qcow2/lib/qcow2-threads.c
+++ b/qcow2/lib/qcow2-threads.c
@@ -36,7 +36,7 @@
 #include "qcow2.h"
 #include "block/block-io.h"
 #include "block/thread-pool.h"
-#include "crypto.h"
+//#include "crypto.h"
 
 static int coroutine_fn
 qcow2_co_process(BlockDriverState *bs, ThreadPoolFunc *func, void *arg)
@@ -426,6 +426,7 @@ qcow2_co_decompress(BlockDriverState *bs, void *dest, size_t dest_size,
 }
 
 
+#if 0
 /*
  * Cryptography
  */
@@ -525,3 +526,4 @@ qcow2_co_decrypt(BlockDriverState *bs, uint64_t host_offset,
     return qcow2_co_encdec(bs, host_offset, guest_offset, buf, len,
                            qcrypto_block_decrypt);
 }
+#endif
diff --git a/qcow2/lib/qcow2.c b/qcow2/lib/qcow2.c
index 70b19730..801042e0 100644
--- a/qcow2/lib/qcow2.c
+++ b/qcow2/lib/qcow2.c
@@ -31,17 +31,17 @@
 #include "qcow2.h"
 #include "qemu/error-report.h"
 #include "qapi/error.h"
-#include "qapi/qapi-events-block-core.h"
+//#include "qapi/qapi-events-block-core.h"
 #include "qapi/qmp/qdict.h"
 #include "qapi/qmp/qstring.h"
-#include "trace.h"
+//#include "trace.h"
 #include "qemu/option_int.h"
 #include "qemu/cutils.h"
 #include "qemu/bswap.h"
 #include "qemu/memalign.h"
 #include "qapi/qobject-input-visitor.h"
 #include "qapi/qapi-visit-block-core.h"
-#include "crypto.h"
+//#include "crypto.h"
 #include "block/aio_task.h"
 #include "block/dirty-bitmap.h"
 
@@ -95,6 +95,7 @@ static int qcow2_probe(const uint8_t *buf, int buf_size, const char *filename)
 }
 
 
+#if 0
 static int GRAPH_RDLOCK
 qcow2_crypto_hdr_read_func(QCryptoBlock *block, size_t offset,
                            uint8_t *buf, size_t buflen,
@@ -193,6 +194,7 @@ qcow2_extract_crypto_opts(QemuOpts *opts, const char *fmt, Error **errp)
     qdict_put_str(cryptoopts_qdict, "format", fmt);
     return cryptoopts_qdict;
 }
+#endif
 
 /*
  * read qcow2 extension and fill bs
@@ -287,6 +289,7 @@ qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,
             break;
 
         case QCOW2_EXT_MAGIC_CRYPTO_HEADER: {
+#if 0
             unsigned int cflags = 0;
             if (s->crypt_method_header != QCOW_CRYPT_LUKS) {
                 error_setg(errp, "CRYPTO header extension only "
@@ -325,6 +328,9 @@ qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,
             if (!s->crypto) {
                 return -EINVAL;
             }
+#else
+            assert(0);
+#endif
         }   break;
 
         case QCOW2_EXT_MAGIC_BITMAPS:
@@ -817,8 +823,10 @@ static QemuOptsList qcow2_runtime_opts = {
             .type = QEMU_OPT_NUMBER,
             .help = "Clean unused cache entries after this time (in seconds)",
         },
+#if 0
         BLOCK_CRYPTO_OPT_DEF_KEY_SECRET("encrypt.",
             "ID of secret providing qcow2 AES key or LUKS passphrase"),
+#endif
         { /* end of list */ }
     },
 };
@@ -979,7 +987,7 @@ typedef struct Qcow2ReopenState {
     bool discard_passthrough[QCOW2_DISCARD_MAX];
     bool discard_no_unref;
     uint64_t cache_clean_interval;
-    QCryptoBlockOpenOptions *crypto_opts; /* Disk encryption runtime options */
+    //QCryptoBlockOpenOptions *crypto_opts; /* Disk encryption runtime options */
 } Qcow2ReopenState;
 
 static int GRAPH_RDLOCK
@@ -992,12 +1000,12 @@ qcow2_update_options_prepare(BlockDriverState *bs, Qcow2ReopenState *r,
     int overlap_check_template = 0;
     uint64_t l2_cache_size, l2_cache_entry_size, refcount_cache_size;
     int i;
-    const char *encryptfmt;
-    QDict *encryptopts = NULL;
+    //const char *encryptfmt;
+    //QDict *encryptopts = NULL;
     int ret;
 
-    qdict_extract_subqdict(options, &encryptopts, "encrypt.");
-    encryptfmt = qdict_get_try_str(encryptopts, "format");
+    //qdict_extract_subqdict(options, &encryptopts, "encrypt.");
+    //encryptfmt = qdict_get_try_str(encryptopts, "format");
 
     opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);
     if (!qemu_opts_absorb_qdict(opts, options, errp)) {
@@ -1157,6 +1165,7 @@ qcow2_update_options_prepare(BlockDriverState *bs, Qcow2ReopenState *r,
         goto fail;
     }
 
+#if 0
     switch (s->crypt_method_header) {
     case QCOW_CRYPT_NONE:
         if (encryptfmt) {
@@ -1205,10 +1214,11 @@ qcow2_update_options_prepare(BlockDriverState *bs, Qcow2ReopenState *r,
         ret = -EINVAL;
         goto fail;
     }
+#endif
 
     ret = 0;
 fail:
-    qobject_unref(encryptopts);
+    //qobject_unref(encryptopts);
     qemu_opts_del(opts);
     opts = NULL;
     return ret;
@@ -1245,8 +1255,8 @@ static void qcow2_update_options_commit(BlockDriverState *bs,
         cache_clean_timer_init(bs, bdrv_get_aio_context(bs));
     }
 
-    qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
-    s->crypto_opts = r->crypto_opts;
+    //qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
+    //s->crypto_opts = r->crypto_opts;
 }
 
 static void qcow2_update_options_abort(BlockDriverState *bs,
@@ -1258,7 +1268,7 @@ static void qcow2_update_options_abort(BlockDriverState *bs,
     if (r->refcount_block_cache) {
         qcow2_cache_destroy(r->refcount_block_cache);
     }
-    qapi_free_QCryptoBlockOpenOptions(r->crypto_opts);
+    //qapi_free_QCryptoBlockOpenOptions(r->crypto_opts);
 }
 
 static int coroutine_fn GRAPH_RDLOCK
@@ -1494,6 +1504,7 @@ qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
     s->refcount_max = UINT64_C(1) << (s->refcount_bits - 1);
     s->refcount_max += s->refcount_max - 1;
 
+#if 0
     s->crypt_method_header = header.crypt_method;
     if (s->crypt_method_header) {
         if (bdrv_uses_whitelist() &&
@@ -1521,6 +1532,7 @@ qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
 
         bs->encrypted = true;
     }
+#endif
 
     s->l2_bits = s->cluster_bits - ctz32(l2_entry_size(s));
     s->l2_size = 1 << s->l2_bits;
@@ -1705,6 +1717,7 @@ qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
         }
     }
 
+#if 0
     /* qcow2_read_extension may have set up the crypto context
      * if the crypt method needs a header region, some methods
      * don't need header extensions, so must check here
@@ -1728,6 +1741,7 @@ qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
             goto fail;
         }
     }
+#endif
 
     /* read the backing file name */
     if (header.backing_file_offset != 0) {
@@ -1913,8 +1927,8 @@ qcow2_do_open(BlockDriverState *bs, QDict *options, int flags,
     if (s->refcount_block_cache) {
         qcow2_cache_destroy(s->refcount_block_cache);
     }
-    qcrypto_block_free(s->crypto);
-    qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
+    //qcrypto_block_free(s->crypto);
+    //qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
     return ret;
 }
 
@@ -1976,10 +1990,12 @@ static void qcow2_refresh_limits(BlockDriverState *bs, Error **errp)
 {
     BDRVQcow2State *s = bs->opaque;
 
+#if 0
     if (bs->encrypted) {
         /* Encryption works on a sector granularity */
         bs->bl.request_alignment = qcrypto_block_get_sector_size(s->crypto);
     }
+#endif
     bs->bl.pwrite_zeroes_alignment = s->subcluster_size;
     bs->bl.pdiscard_alignment = s->cluster_size;
 }
@@ -2170,7 +2186,7 @@ qcow2_co_block_status(BlockDriverState *bs, bool want_zero, int64_t offset,
 
     if ((type == QCOW2_SUBCLUSTER_NORMAL ||
          type == QCOW2_SUBCLUSTER_ZERO_ALLOC ||
-         type == QCOW2_SUBCLUSTER_UNALLOCATED_ALLOC) && !s->crypto) {
+         type == QCOW2_SUBCLUSTER_UNALLOCATED_ALLOC)/* && !s->crypto*/) {
         *map = host_offset;
         *file = s->data_file->bs;
         status |= BDRV_BLOCK_OFFSET_VALID;
@@ -2225,6 +2241,7 @@ out:
     return ret;
 }
 
+#if 0
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_co_preadv_encrypted(BlockDriverState *bs,
                            uint64_t host_offset,
@@ -2271,6 +2288,7 @@ fail:
 
     return ret;
 }
+#endif
 
 typedef struct Qcow2AioTask {
     AioTask task;
@@ -2312,10 +2330,10 @@ static coroutine_fn int qcow2_add_task(BlockDriverState *bs,
         .l2meta = l2meta,
     };
 
-    trace_qcow2_add_task(qemu_coroutine_self(), bs, pool,
-                         func == qcow2_co_preadv_task_entry ? "read" : "write",
-                         subcluster_type, host_offset, offset, bytes,
-                         qiov, qiov_offset);
+    //trace_qcow2_add_task(qemu_coroutine_self(), bs, pool,
+    //                     func == qcow2_co_preadv_task_entry ? "read" : "write",
+    //                     subcluster_type, host_offset, offset, bytes,
+    //                     qiov, qiov_offset);
 
     if (!pool) {
         return func(&task->task);
@@ -2353,8 +2371,10 @@ qcow2_co_preadv_task(BlockDriverState *bs, QCow2SubclusterType subc_type,
 
     case QCOW2_SUBCLUSTER_NORMAL:
         if (bs->encrypted) {
+#if 0
             return qcow2_co_preadv_encrypted(bs, host_offset,
                                              offset, bytes, qiov, qiov_offset);
+#endif
         }
 
         BLKDBG_CO_EVENT(bs->file, BLKDBG_READ_AIO);
@@ -2398,10 +2418,12 @@ qcow2_co_preadv_part(BlockDriverState *bs, int64_t offset, int64_t bytes,
     while (bytes != 0 && aio_task_pool_status(aio) == 0) {
         /* prepare next request */
         cur_bytes = MIN(bytes, INT_MAX);
+#if 0
         if (s->crypto) {
             cur_bytes = MIN(cur_bytes,
                             QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);
         }
+#endif
 
         qemu_co_mutex_lock(&s->lock);
         ret = qcow2_get_host_offset(bs, offset, &cur_bytes,
@@ -2534,10 +2556,12 @@ handle_alloc_space(BlockDriverState *bs, QCowL2Meta *l2meta)
     if (!(s->data_file->bs->supported_zero_flags & BDRV_REQ_NO_FALLBACK)) {
         return 0;
     }
+#if 0
 
     if (bs->encrypted) {
         return 0;
     }
+#endif
 
     for (m = l2meta; m != NULL; m = m->next) {
         int ret;
@@ -2577,7 +2601,7 @@ handle_alloc_space(BlockDriverState *bs, QCowL2Meta *l2meta)
             continue;
         }
 
-        trace_qcow2_skip_cow(qemu_coroutine_self(), m->offset, m->nb_clusters);
+        //trace_qcow2_skip_cow(qemu_coroutine_self(), m->offset, m->nb_clusters);
         m->skip_cow = true;
     }
     return 0;
@@ -2596,9 +2620,10 @@ int qcow2_co_pwritev_task(BlockDriverState *bs, uint64_t host_offset,
 {
     int ret;
     BDRVQcow2State *s = bs->opaque;
-    void *crypt_buf = NULL;
-    QEMUIOVector encrypted_qiov;
+    //void *crypt_buf = NULL;
+    //QEMUIOVector encrypted_qiov;
 
+#if 0
     if (bs->encrypted) {
         assert(s->crypto);
         assert(bytes <= QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);
@@ -2618,6 +2643,7 @@ int qcow2_co_pwritev_task(BlockDriverState *bs, uint64_t host_offset,
         qiov = &encrypted_qiov;
         qiov_offset = 0;
     }
+#endif
 
     /* Try to efficiently initialize the physical space with zeroes */
     ret = handle_alloc_space(bs, l2meta);
@@ -2633,7 +2659,7 @@ int qcow2_co_pwritev_task(BlockDriverState *bs, uint64_t host_offset,
      */
     if (!merge_cow(offset, bytes, qiov, qiov_offset, l2meta)) {
         BLKDBG_CO_EVENT(bs->file, BLKDBG_WRITE_AIO);
-        trace_qcow2_writev_data(qemu_coroutine_self(), host_offset);
+        //trace_qcow2_writev_data(qemu_coroutine_self(), host_offset);
         ret = bdrv_co_pwritev_part(s->data_file, host_offset,
                                    bytes, qiov, qiov_offset, 0);
         if (ret < 0) {
@@ -2653,7 +2679,7 @@ out_locked:
     qcow2_handle_l2meta(bs, &l2meta, false);
     qemu_co_mutex_unlock(&s->lock);
 
-    qemu_vfree(crypt_buf);
+    //qemu_vfree(crypt_buf);
 
     return ret;
 }
@@ -2686,13 +2712,13 @@ qcow2_co_pwritev_part(BlockDriverState *bs, int64_t offset, int64_t bytes,
     QCowL2Meta *l2meta = NULL;
     AioTaskPool *aio = NULL;
 
-    trace_qcow2_writev_start_req(qemu_coroutine_self(), offset, bytes);
+    //trace_qcow2_writev_start_req(qemu_coroutine_self(), offset, bytes);
 
     while (bytes != 0 && aio_task_pool_status(aio) == 0) {
 
         l2meta = NULL;
 
-        trace_qcow2_writev_start_part(qemu_coroutine_self());
+        //trace_qcow2_writev_start_part(qemu_coroutine_self());
         offset_in_cluster = offset_into_cluster(s, offset);
         cur_bytes = MIN(bytes, INT_MAX);
         if (bs->encrypted) {
@@ -2731,7 +2757,7 @@ qcow2_co_pwritev_part(BlockDriverState *bs, int64_t offset, int64_t bytes,
         bytes -= cur_bytes;
         offset += cur_bytes;
         qiov_offset += cur_bytes;
-        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_bytes);
+        //trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_bytes);
     }
     ret = 0;
 
@@ -2751,7 +2777,7 @@ fail_nometa:
         g_free(aio);
     }
 
-    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);
+    //trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);
 
     return ret;
 }
@@ -2807,9 +2833,9 @@ qcow2_do_close(BlockDriverState *bs, bool close_data_file)
     qcow2_cache_destroy(s->l2_table_cache);
     qcow2_cache_destroy(s->refcount_block_cache);
 
-    qcrypto_block_free(s->crypto);
-    s->crypto = NULL;
-    qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
+    //qcrypto_block_free(s->crypto);
+    //s->crypto = NULL;
+    //qapi_free_QCryptoBlockOpenOptions(s->crypto_opts);
 
     g_free(s->unknown_header_fields);
     cleanup_unknown_header_ext(bs);
@@ -2847,7 +2873,7 @@ qcow2_co_invalidate_cache(BlockDriverState *bs, Error **errp)
     BDRVQcow2State *s = bs->opaque;
     BdrvChild *data_file;
     int flags = s->flags;
-    QCryptoBlock *crypto = NULL;
+ //   QCryptoBlock *crypto = NULL;
     QDict *options;
     int ret;
 
@@ -2856,8 +2882,8 @@ qcow2_co_invalidate_cache(BlockDriverState *bs, Error **errp)
      * that means we don't have to worry about reopening them here.
      */
 
-    crypto = s->crypto;
-    s->crypto = NULL;
+//    crypto = s->crypto;
+//    s->crypto = NULL;
 
     /*
      * Do not reopen s->data_file (i.e., have qcow2_do_close() not close it,
@@ -2885,7 +2911,7 @@ qcow2_co_invalidate_cache(BlockDriverState *bs, Error **errp)
         return;
     }
 
-    s->crypto = crypto;
+//    s->crypto = crypto;
 }
 
 static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
@@ -2957,7 +2983,8 @@ int qcow2_update_header(BlockDriverState *bs)
         .backing_file_size      = 0,
         .cluster_bits           = cpu_to_be32(s->cluster_bits),
         .size                   = cpu_to_be64(total_size),
-        .crypt_method           = cpu_to_be32(s->crypt_method_header),
+        //.crypt_method           = cpu_to_be32(s->crypt_method_header),
+        .crypt_method           = cpu_to_be32(QCOW_CRYPT_NONE),
         .l1_size                = cpu_to_be32(s->l1_size),
         .l1_table_offset        = cpu_to_be64(s->l1_table_offset),
         .refcount_table_offset  = cpu_to_be64(s->refcount_table_offset),
@@ -3030,6 +3057,7 @@ int qcow2_update_header(BlockDriverState *bs)
         buflen -= ret;
     }
 
+#if 0
     /* Full disk encryption header pointer extension */
     if (s->crypto_header.offset != 0) {
         s->crypto_header.offset = cpu_to_be64(s->crypto_header.offset);
@@ -3045,6 +3073,7 @@ int qcow2_update_header(BlockDriverState *bs)
         buf += ret;
         buflen -= ret;
     }
+#endif
 
     /*
      * Feature table.  A mere 8 feature names occupies 392 bytes, and
@@ -3204,6 +3233,7 @@ qcow2_co_change_backing_file(BlockDriverState *bs, const char *backing_file,
     return qcow2_update_header(bs);
 }
 
+#if 0
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_set_up_encryption(BlockDriverState *bs,
                         QCryptoBlockCreateOptions *cryptoopts,
@@ -3246,6 +3276,7 @@ qcow2_set_up_encryption(BlockDriverState *bs,
     qcrypto_block_free(crypto);
     return ret;
 }
+#endif
 
 /**
  * Preallocates metadata structures for data clusters between @offset (in the
@@ -3850,6 +3881,7 @@ qcow2_co_create(BlockdevCreateOptions *create_options, Error **errp)
         }
     }
 
+#if 0
     /* Want encryption? There you go. */
     if (qcow2_opts->encrypt) {
         bdrv_graph_co_rdlock();
@@ -3860,7 +3892,7 @@ qcow2_co_create(BlockdevCreateOptions *create_options, Error **errp)
             goto out;
         }
     }
-
+#endif
     blk_co_unref(blk);
     blk = NULL;
 
@@ -4069,7 +4101,7 @@ qcow2_co_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int64_t bytes,
     uint32_t tail = ROUND_UP(offset + bytes, s->subcluster_size) -
         (offset + bytes);
 
-    trace_qcow2_pwrite_zeroes_start_req(qemu_coroutine_self(), offset, bytes);
+    //trace_qcow2_pwrite_zeroes_start_req(qemu_coroutine_self(), offset, bytes);
     if (offset + bytes == bs->total_sectors * BDRV_SECTOR_SIZE) {
         tail = 0;
     }
@@ -4105,7 +4137,7 @@ qcow2_co_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int64_t bytes,
         qemu_co_mutex_lock(&s->lock);
     }
 
-    trace_qcow2_pwrite_zeroes(qemu_coroutine_self(), offset, bytes);
+    //trace_qcow2_pwrite_zeroes(qemu_coroutine_self(), offset, bytes);
 
     /* Whatever is left can use real zero subclusters */
     ret = qcow2_subcluster_zeroize(bs, offset, bytes, flags);
@@ -4289,7 +4321,7 @@ fail:
 
     qemu_co_mutex_unlock(&s->lock);
 
-    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);
+    //trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);
 
     return ret;
 }
@@ -5023,7 +5055,7 @@ static int GRAPH_RDLOCK qcow2_make_empty(BlockDriverState *bs)
 
     if (s->qcow_version >= 3 && !s->snapshots && !s->nb_bitmaps &&
         3 + l1_clusters <= s->refcount_block_size &&
-        s->crypt_method_header != QCOW_CRYPT_LUKS &&
+        /*s->crypt_method_header != QCOW_CRYPT_LUKS &&*/
         !has_data_file(bs)) {
         /* The following function only works for qcow2 v3 images (it
          * requires the dirty flag) and only as long as there are no
@@ -5083,7 +5115,7 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
     char *optstr;
     PreallocMode prealloc;
     bool has_backing_file;
-    bool has_luks;
+    //bool has_luks;
     bool extended_l2;
     size_t l2e_size;
 
@@ -5119,9 +5151,10 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
     g_free(optstr);
 
     optstr = qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT_FORMAT);
-    has_luks = optstr && strcmp(optstr, "luks") == 0;
+    //has_luks = optstr && strcmp(optstr, "luks") == 0;
     g_free(optstr);
 
+#if 0
     if (has_luks) {
         g_autoptr(QCryptoBlockCreateOptions) create_opts = NULL;
         QDict *cryptoopts = qcow2_extract_crypto_opts(opts, "luks", errp);
@@ -5142,6 +5175,7 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
 
         luks_payload_size = ROUND_UP(headerlen, cluster_size);
     }
+#endif
 
     virtual_size = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0);
     virtual_size = ROUND_UP(virtual_size, cluster_size);
@@ -5252,14 +5286,16 @@ qcow2_get_specific_info(BlockDriverState *bs, Error **errp)
 {
     BDRVQcow2State *s = bs->opaque;
     ImageInfoSpecific *spec_info;
-    QCryptoBlockInfo *encrypt_info = NULL;
+    //QCryptoBlockInfo *encrypt_info = NULL;
 
+#if 0
     if (s->crypto != NULL) {
         encrypt_info = qcrypto_block_get_info(s->crypto, errp);
         if (!encrypt_info) {
             return NULL;
         }
     }
+#endif
 
     spec_info = g_new(ImageInfoSpecific, 1);
     *spec_info = (ImageInfoSpecific){
@@ -5275,7 +5311,7 @@ qcow2_get_specific_info(BlockDriverState *bs, Error **errp)
         Qcow2BitmapInfoList *bitmaps;
         if (!qcow2_get_bitmap_info_list(bs, &bitmaps, errp)) {
             qapi_free_ImageInfoSpecific(spec_info);
-            qapi_free_QCryptoBlockInfo(encrypt_info);
+     //       qapi_free_QCryptoBlockInfo(encrypt_info);
             return NULL;
         }
         *spec_info->u.qcow2.data = (ImageInfoSpecificQCow2){
@@ -5302,6 +5338,7 @@ qcow2_get_specific_info(BlockDriverState *bs, Error **errp)
         assert(false);
     }
 
+#if 0
     if (encrypt_info) {
         ImageInfoSpecificQCow2Encryption *qencrypt =
             g_new(ImageInfoSpecificQCow2Encryption, 1);
@@ -5323,6 +5360,7 @@ qcow2_get_specific_info(BlockDriverState *bs, Error **errp)
 
         spec_info->u.qcow2.data->encrypt = qencrypt;
     }
+#endif
 
     return spec_info;
 }
@@ -5725,6 +5763,7 @@ qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,
             backing_file = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);
         } else if (!strcmp(desc->name, BLOCK_OPT_BACKING_FMT)) {
             backing_format = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);
+#if 0
         } else if (g_str_has_prefix(desc->name, "encrypt.")) {
             if (!s->crypto) {
                 error_setg(errp,
@@ -5737,6 +5776,7 @@ qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,
                 return -ENOTSUP;
             }
             encryption_update = true;
+#endif
         } else if (!strcmp(desc->name, BLOCK_OPT_LAZY_REFCOUNTS)) {
             lazy_refcounts = qemu_opt_get_bool(opts, BLOCK_OPT_LAZY_REFCOUNTS,
                                                lazy_refcounts);
@@ -5793,6 +5833,7 @@ qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,
         }
     }
 
+#if 0
     if (encryption_update) {
         QDict *amend_opts_dict;
         QCryptoBlockAmendOptions *amend_opts;
@@ -5819,6 +5860,7 @@ qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,
             return ret;
         }
     }
+#endif
 
     if (s->refcount_bits != refcount_bits) {
         int refcount_order = ctz32(refcount_bits);
@@ -5938,10 +5980,11 @@ static int coroutine_fn qcow2_co_amend(BlockDriverState *bs,
                                        bool force,
                                        Error **errp)
 {
-    BlockdevAmendOptionsQcow2 *qopts = &opts->u.qcow2;
-    BDRVQcow2State *s = bs->opaque;
+//    BlockdevAmendOptionsQcow2 *qopts = &opts->u.qcow2;
+//    BDRVQcow2State *s = bs->opaque;
     int ret = 0;
 
+#if 0
     if (qopts->encrypt) {
         if (!s->crypto) {
             error_setg(errp, "image is not encrypted, can't amend");
@@ -5968,6 +6011,7 @@ static int coroutine_fn qcow2_co_amend(BlockDriverState *bs,
                                           force,
                                           errp);
     }
+#endif
     return ret;
 }
 
@@ -5981,7 +6025,7 @@ void qcow2_signal_corruption(BlockDriverState *bs, bool fatal, int64_t offset,
                              int64_t size, const char *message_format, ...)
 {
     BDRVQcow2State *s = bs->opaque;
-    const char *node_name;
+    //const char *node_name;
     char *message;
     va_list ap;
 
@@ -6005,12 +6049,14 @@ void qcow2_signal_corruption(BlockDriverState *bs, bool fatal, int64_t offset,
                 "corruption events will be suppressed\n", message);
     }
 
+#if 0
     node_name = bdrv_get_node_name(bs);
     qapi_event_send_block_image_corrupted(bdrv_get_device_name(bs),
                                           *node_name ? node_name : NULL,
                                           message, offset >= 0, offset,
                                           size >= 0, size,
                                           fatal);
+#endif
     g_free(message);
 
     if (fatal) {
@@ -6069,6 +6115,7 @@ void qcow2_signal_corruption(BlockDriverState *bs, bool fatal, int64_t offset,
 static QemuOptsList qcow2_create_opts = {
     .name = "qcow2-create-opts",
     .head = QTAILQ_HEAD_INITIALIZER(qcow2_create_opts.head),
+#if 0
     .desc = {
         {                                                               \
             .name = BLOCK_OPT_ENCRYPT,                                  \
@@ -6117,24 +6164,55 @@ static QemuOptsList qcow2_create_opts = {
         QCOW_COMMON_OPTIONS,
         { /* end of list */ }
     }
+#else
+    .desc = {
+        {                                                               \
+            .name = BLOCK_OPT_CLUSTER_SIZE,                             \
+            .type = QEMU_OPT_SIZE,                                      \
+            .help = "qcow2 cluster size",                               \
+            .def_value_str = stringify(DEFAULT_CLUSTER_SIZE)            \
+        },                                                              \
+        {                                                               \
+            .name = BLOCK_OPT_EXTL2,                                    \
+            .type = QEMU_OPT_BOOL,                                      \
+            .help = "Extended L2 tables",                               \
+            .def_value_str = "off"                                      \
+        },                                                              \
+        {                                                               \
+            .name = BLOCK_OPT_PREALLOC,                                 \
+            .type = QEMU_OPT_STRING,                                    \
+            .help = "Preallocation mode (allowed values: off, "         \
+                    "metadata, falloc, full)"                           \
+        },                                                              \
+        {                                                               \
+            .name = BLOCK_OPT_COMPRESSION_TYPE,                         \
+            .type = QEMU_OPT_STRING,                                    \
+            .help = "Compression method used for image cluster "        \
+                    "compression",                                      \
+            .def_value_str = "zlib"                                     \
+        },
+        QCOW_COMMON_OPTIONS,
+        { /* end of list */ }
+    }
+#endif
 };
 
 static QemuOptsList qcow2_amend_opts = {
     .name = "qcow2-amend-opts",
     .head = QTAILQ_HEAD_INITIALIZER(qcow2_amend_opts.head),
     .desc = {
-        BLOCK_CRYPTO_OPT_DEF_LUKS_STATE("encrypt."),
-        BLOCK_CRYPTO_OPT_DEF_LUKS_KEYSLOT("encrypt."),
-        BLOCK_CRYPTO_OPT_DEF_LUKS_OLD_SECRET("encrypt."),
-        BLOCK_CRYPTO_OPT_DEF_LUKS_NEW_SECRET("encrypt."),
-        BLOCK_CRYPTO_OPT_DEF_LUKS_ITER_TIME("encrypt."),
+//        BLOCK_CRYPTO_OPT_DEF_LUKS_STATE("encrypt."),
+//        BLOCK_CRYPTO_OPT_DEF_LUKS_KEYSLOT("encrypt."),
+//        BLOCK_CRYPTO_OPT_DEF_LUKS_OLD_SECRET("encrypt."),
+//        BLOCK_CRYPTO_OPT_DEF_LUKS_NEW_SECRET("encrypt."),
+//        BLOCK_CRYPTO_OPT_DEF_LUKS_ITER_TIME("encrypt."),
         QCOW_COMMON_OPTIONS,
         { /* end of list */ }
     }
 };
 
 static const char *const qcow2_strong_runtime_opts[] = {
-    "encrypt." BLOCK_CRYPTO_OPT_QCOW_KEY_SECRET,
+//    "encrypt." BLOCK_CRYPTO_OPT_QCOW_KEY_SECRET,
 
     NULL
 };
diff --git a/qcow2/lib/qobject/block-qdict.c b/qcow2/lib/qobject/block-qdict.c
index 4a83bda2..0d2eba5b 100644
--- a/qcow2/lib/qobject/block-qdict.c
+++ b/qcow2/lib/qobject/block-qdict.c
@@ -586,6 +586,7 @@ static QObject *qdict_crumple_for_keyval_qiv(QDict *src, Error **errp)
     return dst;
 }
 
+#if 0
 /**
  * qdict_array_entries(): Returns the number of direct array entries if the
  * sub-QDict of src specified by the prefix in subqdict (or src itself for
@@ -647,6 +648,7 @@ int qdict_array_entries(QDict *src, const char *subqdict)
 
     return i;
 }
+#endif
 
 /**
  * qdict_join(): Absorb the src QDict into the dest QDict, that is, move all
diff --git a/qcow2/lib/system/cpus.c b/qcow2/lib/system/cpus.c
index 1c818ff6..81236835 100644
--- a/qcow2/lib/system/cpus.c
+++ b/qcow2/lib/system/cpus.c
@@ -23,29 +23,29 @@
  */
 
 #include "qemu/osdep.h"
-#include "monitor/monitor.h"
+//#include "monitor/monitor.h"
 #include "qemu/coroutine-tls.h"
 #include "qapi/error.h"
-#include "qapi/qapi-commands-machine.h"
-#include "qapi/qapi-commands-misc.h"
-#include "qapi/qapi-events-run-state.h"
+//#include "qapi/qapi-commands-machine.h"
+//#include "qapi/qapi-commands-misc.h"
+//#include "qapi/qapi-events-run-state.h"
 #include "qapi/qmp/qerror.h"
-#include "exec/gdbstub.h"
-#include "sysemu/hw_accel.h"
-#include "exec/cpu-common.h"
+//#include "exec/gdbstub.h"
+//#include "sysemu/hw_accel.h"
+//#include "exec/cpu-common.h"
 #include "qemu/thread.h"
 #include "qemu/main-loop.h"
-#include "qemu/plugin.h"
-#include "sysemu/cpus.h"
-#include "qemu/guest-random.h"
-#include "hw/nmi.h"
-#include "sysemu/replay.h"
-#include "sysemu/runstate.h"
+//#include "qemu/plugin.h"
+//#include "sysemu/cpus.h"
+//#include "qemu/guest-random.h"
+//#include "hw/nmi.h"
+//#include "sysemu/replay.h"
+//#include "sysemu/runstate.h"
 #include "sysemu/cpu-timers.h"
-#include "sysemu/whpx.h"
-#include "hw/boards.h"
-#include "hw/hw.h"
-#include "trace.h"
+//#include "sysemu/whpx.h"
+//#include "hw/boards.h"
+//#include "hw/hw.h"
+//#include "trace.h"
 
 #ifdef CONFIG_LINUX
 
@@ -68,6 +68,7 @@
 /* The Big QEMU Lock (BQL) */
 static QemuMutex bql;
 
+#if 0
 /*
  * The chosen accelerator is supposed to register this.
  */
@@ -414,17 +415,21 @@ static QemuThread io_thread;
 static QemuCond qemu_cpu_cond;
 /* system init */
 static QemuCond qemu_pause_cond;
+#endif
 
 void qemu_init_cpu_loop(void)
 {
+#if 0
     qemu_init_sigbus();
     qemu_cond_init(&qemu_cpu_cond);
     qemu_cond_init(&qemu_pause_cond);
+#endif
     qemu_mutex_init(&bql);
 
-    qemu_thread_get_self(&io_thread);
+    //qemu_thread_get_self(&io_thread);
 }
 
+#if 0
 void run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data)
 {
     do_run_on_cpu(cpu, func, data, &bql);
@@ -511,6 +516,7 @@ bool qemu_in_vcpu_thread(void)
 {
     return current_cpu && qemu_cpu_is_self(current_cpu);
 }
+#endif
 
 QEMU_DEFINE_STATIC_CO_TLS(bool, bql_locked)
 
@@ -544,6 +550,7 @@ void bql_unlock(void)
     qemu_mutex_unlock(&bql);
 }
 
+#if 0
 void qemu_cond_wait_bql(QemuCond *cond)
 {
     qemu_cond_wait(cond, &bql);
@@ -875,4 +882,5 @@ void qmp_inject_nmi(Error **errp)
 {
     nmi_monitor_handle(monitor_get_cpu_index(monitor_cur()), errp);
 }
+#endif
 
diff --git a/qcow2/lib/util/aio-posix.c b/qcow2/lib/util/aio-posix.c
index 266c9dd3..237951d9 100644
--- a/qcow2/lib/util/aio-posix.c
+++ b/qcow2/lib/util/aio-posix.c
@@ -19,9 +19,9 @@
 #include "qemu/main-loop.h"
 #include "qemu/rcu.h"
 #include "qemu/rcu_queue.h"
-#include "qemu/sockets.h"
+//#include "qemu/sockets.h"
 #include "qemu/cutils.h"
-#include "trace.h"
+//#include "trace.h"
 #include "aio-posix.h"
 
 /* Stop userspace polling on a handler if it isn't active for some time */
@@ -338,7 +338,7 @@ static bool aio_dispatch_handler(AioContext *ctx, AioHandler *node)
     if (!QLIST_IS_INSERTED(node, node_deleted) &&
         !QLIST_IS_INSERTED(node, node_poll) &&
         node->io_poll) {
-        trace_poll_add(ctx, node, node->pfd.fd, revents);
+        //trace_poll_add(ctx, node, node->pfd.fd, revents);
         if (ctx->poll_started && node->io_poll_begin) {
             node->io_poll_begin(node->opaque);
         }
@@ -486,7 +486,7 @@ static bool remove_idle_poll_handlers(AioContext *ctx,
         if (node->poll_idle_timeout == 0LL) {
             node->poll_idle_timeout = now + POLL_IDLE_INTERVAL_NS;
         } else if (now >= node->poll_idle_timeout) {
-            trace_poll_remove(ctx, node, node->pfd.fd);
+            //trace_poll_remove(ctx, node, node->pfd.fd);
             node->poll_idle_timeout = 0LL;
             QLIST_SAFE_REMOVE(node, node_poll);
             if (ctx->poll_started && node->io_poll_end) {
@@ -527,7 +527,7 @@ static bool run_poll_handlers(AioContext *ctx, AioHandlerList *ready_list,
 
     assert(qemu_lockcnt_count(&ctx->list_lock) > 0);
 
-    trace_run_poll_handlers_begin(ctx, max_ns, *timeout);
+    //trace_run_poll_handlers_begin(ctx, max_ns, *timeout);
 
     /*
      * Optimization: ->io_poll() handlers often contain RCU read critical
@@ -561,7 +561,7 @@ static bool run_poll_handlers(AioContext *ctx, AioHandlerList *ready_list,
         *timeout -= MIN(*timeout, elapsed_time);
     }
 
-    trace_run_poll_handlers_end(ctx, progress, *timeout);
+    //trace_run_poll_handlers_end(ctx, progress, *timeout);
     return progress;
 }
 
@@ -686,7 +686,7 @@ bool aio_poll(AioContext *ctx, bool blocking)
             /* This is the sweet spot, no adjustment needed */
         } else if (block_ns > ctx->poll_max_ns) {
             /* We'd have to poll for too long, poll less */
-            int64_t old = ctx->poll_ns;
+            //int64_t old = ctx->poll_ns;
 
             if (ctx->poll_shrink) {
                 ctx->poll_ns /= ctx->poll_shrink;
@@ -694,11 +694,11 @@ bool aio_poll(AioContext *ctx, bool blocking)
                 ctx->poll_ns = 0;
             }
 
-            trace_poll_shrink(ctx, old, ctx->poll_ns);
+            //trace_poll_shrink(ctx, old, ctx->poll_ns);
         } else if (ctx->poll_ns < ctx->poll_max_ns &&
                    block_ns < ctx->poll_max_ns) {
             /* There is room to grow, poll longer */
-            int64_t old = ctx->poll_ns;
+            //int64_t old = ctx->poll_ns;
             int64_t grow = ctx->poll_grow;
 
             if (grow == 0) {
@@ -715,7 +715,7 @@ bool aio_poll(AioContext *ctx, bool blocking)
                 ctx->poll_ns = ctx->poll_max_ns;
             }
 
-            trace_poll_grow(ctx, old, ctx->poll_ns);
+            //trace_poll_grow(ctx, old, ctx->poll_ns);
         }
     }
 
diff --git a/qcow2/lib/util/async.c b/qcow2/lib/util/async.c
index 3e3e4fc7..bcc6dee9 100644
--- a/qcow2/lib/util/async.c
+++ b/qcow2/lib/util/async.c
@@ -35,7 +35,7 @@
 #include "qemu/coroutine_int.h"
 #include "qemu/coroutine-tls.h"
 #include "sysemu/cpu-timers.h"
-#include "trace.h"
+//#include "trace.h"
 
 /***********************************************************/
 /* bottom halves (can be seen as timers which expire ASAP) */
@@ -162,9 +162,11 @@ void aio_bh_call(QEMUBH *bh)
     MemReentrancyGuard *reentrancy_guard = bh->reentrancy_guard;
     if (reentrancy_guard) {
         last_engaged_in_io = reentrancy_guard->engaged_in_io;
+#if 0
         if (reentrancy_guard->engaged_in_io) {
             trace_reentrant_aio(bh->ctx, bh->name);
         }
+#endif
         reentrancy_guard->engaged_in_io = true;
     }
 
@@ -563,7 +565,7 @@ static void co_schedule_bh_cb(void *opaque)
     while (!QSLIST_EMPTY(&straight)) {
         Coroutine *co = QSLIST_FIRST(&straight);
         QSLIST_REMOVE_HEAD(&straight, co_scheduled_next);
-        trace_aio_co_schedule_bh_cb(ctx, co);
+        //trace_aio_co_schedule_bh_cb(ctx, co);
 
         /* Protected by write barrier in qemu_aio_coroutine_enter */
         qatomic_set(&co->scheduled, NULL);
@@ -628,7 +630,7 @@ fail:
 
 void aio_co_schedule(AioContext *ctx, Coroutine *co)
 {
-    trace_aio_co_schedule(ctx, co);
+    //trace_aio_co_schedule(ctx, co);
     const char *scheduled = qatomic_cmpxchg(&co->scheduled, NULL,
                                            __func__);
 
diff --git a/qcow2/lib/util/bufferiszero.c b/qcow2/lib/util/bufferiszero.c
index 522146da..b86b90a2 100644
--- a/qcow2/lib/util/bufferiszero.c
+++ b/qcow2/lib/util/bufferiszero.c
@@ -24,7 +24,7 @@
 #include "qemu/osdep.h"
 #include "qemu/cutils.h"
 #include "qemu/bswap.h"
-#include "host/cpuinfo.h"
+//#include "host/cpuinfo.h"
 
 typedef bool (*biz_accel_fn)(const void *, size_t);
 
@@ -81,7 +81,12 @@ static bool buffer_is_zero_int_ge256(const void *buf, size_t len)
     return t == 0;
 }
 
-#include "host/bufferiszero.c.inc"
+//#include "host/bufferiszero.c.inc"
+static biz_accel_fn const accel_table[1] = {
+    buffer_is_zero_int_ge256
+};
+
+#define best_accel() 0
 
 static biz_accel_fn buffer_is_zero_accel;
 static unsigned accel_index;
diff --git a/qcow2/lib/util/cutils.c b/qcow2/lib/util/cutils.c
index 42364039..a0f76614 100644
--- a/qcow2/lib/util/cutils.c
+++ b/qcow2/lib/util/cutils.c
@@ -1009,6 +1009,7 @@ int qemu_pstrcmp0(const char **str1, const char **str2)
     return g_strcmp0(*str1, *str2);
 }
 
+#if 0
 static inline bool starts_with_prefix(const char *dir)
 {
     size_t prefix_len = strlen(CONFIG_PREFIX);
@@ -1040,6 +1041,7 @@ static inline const char *next_component(const char *dir, int *p_len)
     *p_len = len;
     return dir;
 }
+#endif
 
 static const char *exec_dir;
 
@@ -1139,11 +1141,12 @@ void qemu_init_exec_dir(const char *argv0)
     if (p) {
         exec_dir = g_path_get_dirname(p);
     } else {
-        exec_dir = CONFIG_BINDIR;
+        exec_dir = "/usr/bin" /*CONFIG_BINDIR*/;
     }
 #endif
 }
 
+#if 0
 const char *qemu_get_exec_dir(void)
 {
     return exec_dir;
@@ -1216,3 +1219,4 @@ char *get_relocated_path(const char *dir)
 out:
     return g_string_free(result, false);
 }
+#endif
diff --git a/qcow2/lib/util/error-report.c b/qcow2/lib/util/error-report.c
index 1b17c11d..0554f186 100644
--- a/qcow2/lib/util/error-report.c
+++ b/qcow2/lib/util/error-report.c
@@ -10,8 +10,10 @@
  * See the COPYING file in the top-level directory.
  */
 
+#include <syslog.h>
+
 #include "qemu/osdep.h"
-#include "monitor/monitor.h"
+//#include "monitor/monitor.h"
 #include "qemu/error-report.h"
 
 /*
@@ -32,12 +34,11 @@ const char *error_guest_name;
 int error_printf(const char *fmt, ...)
 {
     va_list ap;
-    int ret;
 
     va_start(ap, fmt);
-    ret = error_vprintf(fmt, ap);
+    vsyslog(LOG_ERR, fmt, ap);
     va_end(ap);
-    return ret;
+    return 0;
 }
 
 static Location std_loc = {
@@ -144,7 +145,7 @@ static void print_loc(void)
     int i;
     const char *const *argp;
 
-    if (!monitor_cur() && g_get_prgname()) {
+    if (/*!monitor_cur() && */g_get_prgname()) {
         error_printf("%s:", g_get_prgname());
         sep = " ";
     }
@@ -188,14 +189,14 @@ static void vreport(report_type type, const char *fmt, va_list ap)
 {
     gchar *timestr;
 
-    if (message_with_timestamp && !monitor_cur()) {
+    if (message_with_timestamp/* && !monitor_cur()*/) {
         timestr = real_time_iso8601();
         error_printf("%s ", timestr);
         g_free(timestr);
     }
 
     /* Only prepend guest name if -msg guest-name and -name guest=... are set */
-    if (error_with_guestname && error_guest_name && !monitor_cur()) {
+    if (error_with_guestname && error_guest_name/* && !monitor_cur()*/) {
         error_printf("%s ", error_guest_name);
     }
 
@@ -212,8 +213,8 @@ static void vreport(report_type type, const char *fmt, va_list ap)
         break;
     }
 
-    error_vprintf(fmt, ap);
-    error_printf("\n");
+    vsyslog(LOG_ERR, fmt, ap);
+    //error_printf("\n");
 }
 
 /*
diff --git a/qcow2/lib/util/error.c b/qcow2/lib/util/error.c
index e5e24720..e84b4b16 100644
--- a/qcow2/lib/util/error.c
+++ b/qcow2/lib/util/error.c
@@ -32,7 +32,7 @@ Error *error_warn;
 static void error_handle(Error **errp, Error *err)
 {
     if (errp == &error_abort) {
-        fprintf(stderr, "Unexpected error in %s() at %s:%d:\n",
+        error_report("Unexpected error in %s() at %s:%d:\n",
                 err->func, err->src, err->line);
         error_report("%s", error_get_pretty(err));
         if (err->hint) {
@@ -231,6 +231,8 @@ const char *error_get_pretty(const Error *err)
 
 void error_report_err(Error *err)
 {
+    error_report("libqcow2: error in %s() at %s:%d:\n",
+            err->func, err->src, err->line);
     error_report("%s", error_get_pretty(err));
     if (err->hint) {
         error_printf("%s", err->hint->str);
@@ -240,6 +242,8 @@ void error_report_err(Error *err)
 
 void warn_report_err(Error *err)
 {
+    warn_report("libqcow2: error in %s() at %s:%d:\n",
+            err->func, err->src, err->line);
     warn_report("%s", error_get_pretty(err));
     if (err->hint) {
         error_printf("%s", err->hint->str);
diff --git a/qcow2/lib/util/hbitmap.c b/qcow2/lib/util/hbitmap.c
index 6d6e1b59..106be57b 100644
--- a/qcow2/lib/util/hbitmap.c
+++ b/qcow2/lib/util/hbitmap.c
@@ -12,7 +12,7 @@
 #include "qemu/osdep.h"
 #include "qemu/hbitmap.h"
 #include "qemu/host-utils.h"
-#include "trace.h"
+//#include "trace.h"
 #include "crypto/hash.h"
 
 /* HBitmaps provides an array of bits.  The bits are stored as usual in an
@@ -140,7 +140,7 @@ static unsigned long hbitmap_iter_skip_words(HBitmapIter *hbi)
     }
 
     hbi->pos = pos;
-    trace_hbitmap_iter_skip_words(hbi->hb, hbi, pos, cur);
+    //trace_hbitmap_iter_skip_words(hbi->hb, hbi, pos, cur);
 
     assert(cur);
     return cur;
@@ -471,8 +471,8 @@ void hbitmap_set(HBitmap *hb, uint64_t start, uint64_t count)
         return;
     }
 
-    trace_hbitmap_set(hb, start, count,
-                      start >> hb->granularity, last >> hb->granularity);
+    //trace_hbitmap_set(hb, start, count,
+    //                  start >> hb->granularity, last >> hb->granularity);
 
     first = start >> hb->granularity;
     last >>= hb->granularity;
@@ -569,8 +569,8 @@ void hbitmap_reset(HBitmap *hb, uint64_t start, uint64_t count)
     assert(QEMU_IS_ALIGNED(start, gran));
     assert(QEMU_IS_ALIGNED(count, gran) || (start + count == hb->orig_size));
 
-    trace_hbitmap_reset(hb, start, count,
-                        start >> hb->granularity, last >> hb->granularity);
+    //trace_hbitmap_reset(hb, start, count,
+    //                    start >> hb->granularity, last >> hb->granularity);
 
     first = start >> hb->granularity;
     last >>= hb->granularity;
diff --git a/qcow2/lib/util/host-utils.c b/qcow2/lib/util/host-utils.c
index fb91bcba..6d0e2825 100644
--- a/qcow2/lib/util/host-utils.c
+++ b/qcow2/lib/util/host-utils.c
@@ -267,6 +267,7 @@ void ulshift(uint64_t *plow, uint64_t *phigh, int32_t shift, bool *overflow)
     }
 }
 
+#if 0
 /*
  * Unsigned 256-by-128 division.
  * Returns the remainder via r.
@@ -446,3 +447,4 @@ Int128 divs256(Int128 *plow, Int128 *phigh, Int128 divisor)
         return rem;
     }
 }
+#endif
diff --git a/qcow2/lib/util/iov.c b/qcow2/lib/util/iov.c
index 7e73948f..14eb3cd1 100644
--- a/qcow2/lib/util/iov.c
+++ b/qcow2/lib/util/iov.c
@@ -18,7 +18,7 @@
 
 #include "qemu/osdep.h"
 #include "qemu/iov.h"
-#include "qemu/sockets.h"
+//#include "qemu/sockets.h"
 #include "qemu/cutils.h"
 
 size_t iov_from_buf_full(const struct iovec *iov, unsigned int iov_cnt,
@@ -229,6 +229,7 @@ ssize_t iov_send_recv(int sockfd, const struct iovec *_iov, unsigned iov_cnt,
 }
 
 
+#if 0
 void iov_hexdump(const struct iovec *iov, const unsigned int iov_cnt,
                  FILE *fp, const char *prefix, size_t limit)
 {
@@ -245,6 +246,7 @@ void iov_hexdump(const struct iovec *iov, const unsigned int iov_cnt,
     qemu_hexdump(fp, prefix, buf, size);
     g_free(buf);
 }
+#endif
 
 unsigned iov_copy(struct iovec *dst_iov, unsigned int dst_iov_cnt,
                  const struct iovec *iov, unsigned int iov_cnt,
@@ -432,7 +434,7 @@ bool qemu_iovec_is_zero(QEMUIOVector *qiov, size_t offset, size_t bytes)
         uint8_t *base = (uint8_t *)iov->iov_base + current_offset;
         size_t len = MIN(iov->iov_len - current_offset, bytes);
 
-        if (!buffer_is_zero(base, len)) {
+        if (!buffer_is_zero((char*)base, len)) {
             return false;
         }
 
diff --git a/qcow2/lib/util/lockcnt.c b/qcow2/lib/util/lockcnt.c
index 5da36946..69274a4a 100644
--- a/qcow2/lib/util/lockcnt.c
+++ b/qcow2/lib/util/lockcnt.c
@@ -9,7 +9,7 @@
 #include "qemu/osdep.h"
 #include "qemu/thread.h"
 #include "qemu/atomic.h"
-#include "trace.h"
+//#include "trace.h"
 
 #ifdef CONFIG_LINUX
 #include "qemu/futex.h"
@@ -60,10 +60,10 @@ static bool qemu_lockcnt_cmpxchg_or_wait(QemuLockCnt *lockcnt, int *val,
     if ((*val & QEMU_LOCKCNT_STATE_MASK) == QEMU_LOCKCNT_STATE_FREE) {
         int expected = *val;
 
-        trace_lockcnt_fast_path_attempt(lockcnt, expected, new_if_free);
+        //trace_lockcnt_fast_path_attempt(lockcnt, expected, new_if_free);
         *val = qatomic_cmpxchg(&lockcnt->count, expected, new_if_free);
         if (*val == expected) {
-            trace_lockcnt_fast_path_success(lockcnt, expected, new_if_free);
+            //trace_lockcnt_fast_path_success(lockcnt, expected, new_if_free);
             *val = new_if_free;
             return true;
         }
@@ -80,7 +80,7 @@ static bool qemu_lockcnt_cmpxchg_or_wait(QemuLockCnt *lockcnt, int *val,
             int expected = *val;
             int new = expected - QEMU_LOCKCNT_STATE_LOCKED + QEMU_LOCKCNT_STATE_WAITING;
 
-            trace_lockcnt_futex_wait_prepare(lockcnt, expected, new);
+            //trace_lockcnt_futex_wait_prepare(lockcnt, expected, new);
             *val = qatomic_cmpxchg(&lockcnt->count, expected, new);
             if (*val == expected) {
                 *val = new;
@@ -90,10 +90,10 @@ static bool qemu_lockcnt_cmpxchg_or_wait(QemuLockCnt *lockcnt, int *val,
 
         if ((*val & QEMU_LOCKCNT_STATE_MASK) == QEMU_LOCKCNT_STATE_WAITING) {
             *waited = true;
-            trace_lockcnt_futex_wait(lockcnt, *val);
+            //trace_lockcnt_futex_wait(lockcnt, *val);
             qemu_futex_wait(&lockcnt->count, *val);
             *val = qatomic_read(&lockcnt->count);
-            trace_lockcnt_futex_wait_resume(lockcnt, *val);
+            //trace_lockcnt_futex_wait_resume(lockcnt, *val);
             continue;
         }
 
@@ -104,7 +104,7 @@ static bool qemu_lockcnt_cmpxchg_or_wait(QemuLockCnt *lockcnt, int *val,
 
 static void lockcnt_wake(QemuLockCnt *lockcnt)
 {
-    trace_lockcnt_futex_wake(lockcnt);
+    //trace_lockcnt_futex_wake(lockcnt);
     qemu_futex_wake(&lockcnt->count, 1);
 }
 
@@ -261,11 +261,11 @@ void qemu_lockcnt_inc_and_unlock(QemuLockCnt *lockcnt)
     do {
         expected = val;
         new = (val + QEMU_LOCKCNT_COUNT_STEP) & ~QEMU_LOCKCNT_STATE_MASK;
-        trace_lockcnt_unlock_attempt(lockcnt, val, new);
+        //trace_lockcnt_unlock_attempt(lockcnt, val, new);
         val = qatomic_cmpxchg(&lockcnt->count, val, new);
     } while (val != expected);
 
-    trace_lockcnt_unlock_success(lockcnt, val, new);
+    //trace_lockcnt_unlock_success(lockcnt, val, new);
     if (val & QEMU_LOCKCNT_STATE_WAITING) {
         lockcnt_wake(lockcnt);
     }
@@ -279,11 +279,11 @@ void qemu_lockcnt_unlock(QemuLockCnt *lockcnt)
     do {
         expected = val;
         new = val & ~QEMU_LOCKCNT_STATE_MASK;
-        trace_lockcnt_unlock_attempt(lockcnt, val, new);
+        //trace_lockcnt_unlock_attempt(lockcnt, val, new);
         val = qatomic_cmpxchg(&lockcnt->count, val, new);
     } while (val != expected);
 
-    trace_lockcnt_unlock_success(lockcnt, val, new);
+    //trace_lockcnt_unlock_success(lockcnt, val, new);
     if (val & QEMU_LOCKCNT_STATE_WAITING) {
         lockcnt_wake(lockcnt);
     }
diff --git a/qcow2/lib/util/main-loop.c b/qcow2/lib/util/main-loop.c
index a0386cfe..ce3f16ce 100644
--- a/qcow2/lib/util/main-loop.c
+++ b/qcow2/lib/util/main-loop.c
@@ -27,13 +27,13 @@
 #include "qemu/cutils.h"
 #include "qemu/timer.h"
 #include "sysemu/cpu-timers.h"
-#include "sysemu/replay.h"
+//#include "sysemu/replay.h"
 #include "qemu/main-loop.h"
 #include "block/aio.h"
 #include "block/thread-pool.h"
 #include "qemu/error-report.h"
 #include "qemu/queue.h"
-#include "qom/object.h"
+//#include "qom/object.h"
 
 #ifndef _WIN32
 #include <sys/wait.h>
@@ -95,10 +95,10 @@ static int qemu_signal_init(Error **errp)
      * not catch it reliably.
      */
     sigemptyset(&set);
-    sigaddset(&set, SIG_IPI);
+    //sigaddset(&set, SIG_IPI);
     sigaddset(&set, SIGIO);
     sigaddset(&set, SIGALRM);
-    sigaddset(&set, SIGBUS);
+    //sigaddset(&set, SIGBUS);
     /* SIGINT cannot be handled via signalfd, so that ^C can be used
      * to interrupt QEMU when it is being run under gdb.  SIGHUP and
      * SIGTERM are also handled asynchronously, even though it is not
@@ -106,7 +106,7 @@ static int qemu_signal_init(Error **errp)
      */
     pthread_sigmask(SIG_BLOCK, &set, NULL);
 
-    sigdelset(&set, SIG_IPI);
+    //sigdelset(&set, SIG_IPI);
     sigfd = qemu_signalfd(&set);
     if (sigfd == -1) {
         error_setg_errno(errp, errno, "failed to create signalfd");
@@ -153,6 +153,14 @@ void qemu_notify_event(void)
 
 static GArray *gpollfds;
 
+
+void qemu_timer_notify_cb(void *opaque, QEMUClockType type)
+{
+    if (!icount_enabled() || type != QEMU_CLOCK_VIRTUAL) {
+        qemu_notify_event();
+    }
+}
+
 int qemu_init_main_loop(Error **errp)
 {
     int ret;
@@ -183,6 +191,7 @@ int qemu_init_main_loop(Error **errp)
     return 0;
 }
 
+#if 0
 static void main_loop_update_params(EventLoopBase *base, Error **errp)
 {
     ERRP_GUARD();
@@ -242,6 +251,7 @@ static void main_loop_register_types(void)
 }
 
 type_init(main_loop_register_types)
+#endif
 
 static int max_priority;
 
@@ -300,11 +310,11 @@ static int os_host_main_loop_wait(int64_t timeout)
     glib_pollfds_fill(&timeout);
 
     bql_unlock();
-    replay_mutex_unlock();
+    //replay_mutex_unlock();
 
     ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);
 
-    replay_mutex_lock();
+    //replay_mutex_lock();
     bql_lock();
 
     glib_pollfds_poll();
diff --git a/qcow2/lib/util/memalign.c b/qcow2/lib/util/memalign.c
index c199ae70..c8b526e5 100644
--- a/qcow2/lib/util/memalign.c
+++ b/qcow2/lib/util/memalign.c
@@ -27,7 +27,7 @@
 #include "qemu/osdep.h"
 #include "qemu/host-utils.h"
 #include "qemu/memalign.h"
-#include "trace.h"
+//#include "trace.h"
 
 void *qemu_try_memalign(size_t alignment, size_t size)
 {
@@ -62,9 +62,10 @@ void *qemu_try_memalign(size_t alignment, size_t size)
 #elif defined(CONFIG_MEMALIGN)
     ptr = memalign(alignment, size);
 #else
-    #error No function to allocate aligned memory available
+    ptr = aligned_alloc(alignment, size);
+    //#error No function to allocate aligned memory available
 #endif
-    trace_qemu_memalign(alignment, size, ptr);
+    //trace_qemu_memalign(alignment, size, ptr);
     return ptr;
 }
 
@@ -82,7 +83,7 @@ void *qemu_memalign(size_t alignment, size_t size)
 
 void qemu_vfree(void *ptr)
 {
-    trace_qemu_vfree(ptr);
+    //trace_qemu_vfree(ptr);
 #if !defined(CONFIG_POSIX_MEMALIGN) && defined(CONFIG_ALIGNED_MALLOC)
     /* Only Windows _aligned_malloc needs a special free function */
     _aligned_free(ptr);
diff --git a/qcow2/lib/util/module.c b/qcow2/lib/util/module.c
index 3eb0f06d..f0791505 100644
--- a/qcow2/lib/util/module.c
+++ b/qcow2/lib/util/module.c
@@ -25,7 +25,7 @@
 #ifdef CONFIG_MODULE_UPGRADES
 #include "qemu-version.h"
 #endif
-#include "trace.h"
+//#include "trace.h"
 
 typedef struct ModuleEntry
 {
@@ -191,7 +191,7 @@ static bool module_load_dso(const char *fname, bool export_symbols,
         e->init();
         register_module_init(e->init, e->type);
     }
-    trace_module_load_module(fname);
+    //trace_module_load_module(fname);
     QTAILQ_FOREACH_SAFE(e, &dso_init_list, node, next) {
         QTAILQ_REMOVE(&dso_init_list, e, node);
         g_free(e);
@@ -327,7 +327,7 @@ int module_load_qom(const char *type, Error **errp)
         return -1;
     }
 
-    trace_module_lookup_object_type(type);
+    //trace_module_lookup_object_type(type);
     for (modinfo = module_info; modinfo->name != NULL; modinfo++) {
         if (!modinfo->objs) {
             continue;
diff --git a/qcow2/lib/util/osdep.c b/qcow2/lib/util/osdep.c
index 77036983..cffa8a52 100644
--- a/qcow2/lib/util/osdep.c
+++ b/qcow2/lib/util/osdep.c
@@ -24,14 +24,14 @@
 #include "qemu/osdep.h"
 #include "qapi/error.h"
 #include "qemu/cutils.h"
-#include "qemu/sockets.h"
+//#include "qemu/sockets.h"
 #include "qemu/error-report.h"
-#include "qemu/madvise.h"
-#include "qemu/mprotect.h"
-#include "qemu/hw-version.h"
-#include "monitor/monitor.h"
+//#include "qemu/madvise.h"
+//#include "qemu/mprotect.h"
+//#include "qemu/hw-version.h"
+//#include "monitor/monitor.h"
 
-static const char *hw_version = QEMU_HW_VERSION;
+//static const char *hw_version = QEMU_HW_VERSION;
 
 int socket_set_cork(int fd, int v)
 {
@@ -42,6 +42,7 @@ int socket_set_cork(int fd, int v)
 #endif
 }
 
+#if 0
 int socket_set_nodelay(int fd)
 {
     int v = 1;
@@ -118,6 +119,7 @@ int qemu_mprotect_none(void *addr, size_t size)
     return qemu_mprotect__osdep(addr, size, PROT_NONE);
 #endif
 }
+#endif
 
 #ifndef _WIN32
 
@@ -327,7 +329,7 @@ qemu_open_internal(const char *name, int flags, mode_t mode, Error **errp)
             return -1;
         }
 
-        return monitor_fdset_dup_fd_add(fdset_id, flags, errp);
+        return 0 /*monitor_fdset_dup_fd_add(fdset_id, flags, errp)*/;
     }
 #endif
 
@@ -400,7 +402,7 @@ int qemu_open_old(const char *name, int flags, ...)
 int qemu_close(int fd)
 {
     /* Close fd that was dup'd from an fdset */
-    monitor_fdset_dup_fd_remove(fd);
+    //monitor_fdset_dup_fd_remove(fd);
     return close(fd);
 }
 
@@ -451,6 +453,7 @@ ssize_t qemu_write_full(int fd, const void *buf, size_t count)
     return total;
 }
 
+#if 0
 /*
  * Opens a socket with FD_CLOEXEC set
  */
@@ -514,7 +517,9 @@ ssize_t qemu_send_full(int s, const void *buf, size_t count)
 
     return total;
 }
+#endif
 
+#if 0
 void qemu_set_hw_version(const char *version)
 {
     hw_version = version;
@@ -524,6 +529,7 @@ const char *qemu_hw_version(void)
 {
     return hw_version;
 }
+#endif
 
 #ifdef _WIN32
 static void socket_cleanup(void)
diff --git a/qcow2/lib/util/oslib-posix.c b/qcow2/lib/util/oslib-posix.c
index 11b35e48..74638fef 100644
--- a/qcow2/lib/util/oslib-posix.c
+++ b/qcow2/lib/util/oslib-posix.c
@@ -31,20 +31,20 @@
 
 #include <glib/gprintf.h>
 
-#include "sysemu/sysemu.h"
-#include "trace.h"
+//#include "sysemu/sysemu.h"
+//#include "trace.h"
 #include "qapi/error.h"
 #include "qemu/error-report.h"
-#include "qemu/madvise.h"
-#include "qemu/sockets.h"
+//#include "qemu/madvise.h"
+//#include "qemu/sockets.h"
 #include "qemu/thread.h"
 #include <libgen.h>
 #include "qemu/cutils.h"
 #include "qemu/units.h"
-#include "qemu/thread-context.h"
+//#include "qemu/thread-context.h"
 #include "qemu/main-loop.h"
 
-#ifdef CONFIG_LINUX
+#if defined(__linux__)
 #include <sys/syscall.h>
 #endif
 
@@ -58,14 +58,14 @@
 #include <lwp.h>
 #endif
 
-#include "qemu/mmap-alloc.h"
+//#include "qemu/mmap-alloc.h"
 
 #define MAX_MEM_PREALLOC_THREAD_COUNT 16
 
 struct MemsetThread;
 
-static QLIST_HEAD(, MemsetContext) memset_contexts =
-    QLIST_HEAD_INITIALIZER(memset_contexts);
+//static QLIST_HEAD(, MemsetContext) memset_contexts =
+//    QLIST_HEAD_INITIALIZER(memset_contexts);
 
 typedef struct MemsetContext {
     bool all_threads_created;
@@ -86,12 +86,12 @@ struct MemsetThread {
 typedef struct MemsetThread MemsetThread;
 
 /* used by sigbus_handler() */
-static MemsetContext *sigbus_memset_context;
-struct sigaction sigbus_oldact;
-static QemuMutex sigbus_mutex;
+//static MemsetContext *sigbus_memset_context;
+//struct sigaction sigbus_oldact;
+//static QemuMutex sigbus_mutex;
 
-static QemuMutex page_mutex;
-static QemuCond page_cond;
+//static QemuMutex page_mutex;
+//static QemuCond page_cond;
 
 int qemu_get_thread_id(void)
 {
@@ -188,6 +188,7 @@ fail_close:
     return false;
 }
 
+#if 0
 /* alloc shared memory pages */
 void *qemu_anon_ram_alloc(size_t size, uint64_t *alignment, bool shared,
                           bool noreserve)
@@ -655,6 +656,7 @@ char *qemu_get_pid_name(pid_t pid)
 
     return name;
 }
+#endif
 
 
 void *qemu_alloc_stack(size_t *sz)
@@ -775,6 +777,7 @@ void sigaction_invoke(struct sigaction *action,
     action->sa_sigaction(info->ssi_signo, &si, NULL);
 }
 
+#if 0
 size_t qemu_get_host_physmem(void)
 {
 #ifdef _SC_PHYS_PAGES
@@ -931,3 +934,4 @@ void qemu_close_all_open_fd(const int *skip, unsigned int nskip)
         qemu_close_all_open_fd_fallback(skip, nskip, open_max);
     }
 }
+#endif
diff --git a/qcow2/lib/util/qemu-coroutine-lock.c b/qcow2/lib/util/qemu-coroutine-lock.c
index 25344353..6afe27a0 100644
--- a/qcow2/lib/util/qemu-coroutine-lock.c
+++ b/qcow2/lib/util/qemu-coroutine-lock.c
@@ -31,7 +31,7 @@
 #include "qemu/processor.h"
 #include "qemu/queue.h"
 #include "block/aio.h"
-#include "trace.h"
+//#include "trace.h"
 
 void qemu_co_queue_init(CoQueue *queue)
 {
@@ -198,7 +198,7 @@ static void coroutine_fn qemu_co_mutex_lock_slowpath(AioContext *ctx,
     CoWaitRecord w;
     unsigned old_handoff;
 
-    trace_qemu_co_mutex_lock_entry(mutex, self);
+    //trace_qemu_co_mutex_lock_entry(mutex, self);
     push_waiter(mutex, &w);
 
     /*
@@ -230,7 +230,7 @@ static void coroutine_fn qemu_co_mutex_lock_slowpath(AioContext *ctx,
     }
 
     qemu_coroutine_yield();
-    trace_qemu_co_mutex_lock_return(mutex, self);
+    //trace_qemu_co_mutex_lock_return(mutex, self);
 }
 
 void coroutine_fn qemu_co_mutex_lock(CoMutex *mutex)
@@ -264,7 +264,7 @@ retry_fast_path:
 
     if (waiters == 0) {
         /* Uncontended.  */
-        trace_qemu_co_mutex_lock_uncontended(mutex, self);
+        //trace_qemu_co_mutex_lock_uncontended(mutex, self);
         mutex->ctx = ctx;
     } else {
         qemu_co_mutex_lock_slowpath(ctx, mutex);
@@ -277,7 +277,7 @@ void coroutine_fn qemu_co_mutex_unlock(CoMutex *mutex)
 {
     Coroutine *self = qemu_coroutine_self();
 
-    trace_qemu_co_mutex_unlock_entry(mutex, self);
+    //trace_qemu_co_mutex_unlock_entry(mutex, self);
 
     assert(mutex->locked);
     assert(mutex->holder == self);
@@ -326,7 +326,7 @@ void coroutine_fn qemu_co_mutex_unlock(CoMutex *mutex)
         }
     }
 
-    trace_qemu_co_mutex_unlock_return(mutex, self);
+    //trace_qemu_co_mutex_unlock_return(mutex, self);
 }
 
 struct CoRwTicket {
diff --git a/qcow2/lib/util/qemu-coroutine.c b/qcow2/lib/util/qemu-coroutine.c
index eb4eebef..3f9b9920 100644
--- a/qcow2/lib/util/qemu-coroutine.c
+++ b/qcow2/lib/util/qemu-coroutine.c
@@ -13,7 +13,7 @@
  */
 
 #include "qemu/osdep.h"
-#include "trace.h"
+//#include "trace.h"
 #include "qemu/thread.h"
 #include "qemu/atomic.h"
 #include "qemu/coroutine_int.h"
@@ -265,7 +265,7 @@ void qemu_aio_coroutine_enter(AioContext *ctx, Coroutine *co)
 
         QSIMPLEQ_REMOVE_HEAD(&pending, co_queue_next);
 
-        trace_qemu_aio_coroutine_enter(ctx, from, to, to->entry_arg);
+        //trace_qemu_aio_coroutine_enter(ctx, from, to, to->entry_arg);
 
         /* if the Coroutine has already been scheduled, entering it again will
          * cause us to enter it twice, potentially even after the coroutine has
@@ -302,7 +302,7 @@ void qemu_aio_coroutine_enter(AioContext *ctx, Coroutine *co)
             break;
         case COROUTINE_TERMINATE:
             assert(!to->locks_held);
-            trace_qemu_coroutine_terminate(to);
+            //trace_qemu_coroutine_terminate(to);
             coroutine_delete(to);
             break;
         default:
@@ -328,7 +328,7 @@ void coroutine_fn qemu_coroutine_yield(void)
     Coroutine *self = qemu_coroutine_self();
     Coroutine *to = self->caller;
 
-    trace_qemu_coroutine_yield(self, to);
+    //trace_qemu_coroutine_yield(self, to);
 
     if (!to) {
         fprintf(stderr, "Co-routine is yielding to no one\n");
diff --git a/qcow2/lib/util/qemu-option.c b/qcow2/lib/util/qemu-option.c
index 201f7a87..4ba11fa1 100644
--- a/qcow2/lib/util/qemu-option.c
+++ b/qcow2/lib/util/qemu-option.c
@@ -637,7 +637,7 @@ QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id,
     opts = g_malloc0(sizeof(*opts));
     opts->id = g_strdup(id);
     opts->list = list;
-    loc_save(&opts->loc);
+    //loc_save(&opts->loc);
     QTAILQ_INIT(&opts->head);
     QTAILQ_INSERT_TAIL(&list->head, opts, next);
     return opts;
@@ -654,7 +654,7 @@ void qemu_opts_reset(QemuOptsList *list)
 
 void qemu_opts_loc_restore(QemuOpts *opts)
 {
-    loc_restore(&opts->loc);
+    //loc_restore(&opts->loc);
 }
 
 const char *qemu_opts_id(QemuOpts *opts)
@@ -1125,20 +1125,20 @@ bool qemu_opts_validate(QemuOpts *opts, const QemuOptDesc *desc, Error **errp)
 int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func,
                       void *opaque, Error **errp)
 {
-    Location loc;
+    //Location loc;
     QemuOpts *opts, *next;
     int rc = 0;
 
-    loc_push_none(&loc);
+    //loc_push_none(&loc);
     QTAILQ_FOREACH_SAFE(opts, &list->head, next, next) {
-        loc_restore(&opts->loc);
+        //loc_restore(&opts->loc);
         rc = func(opaque, opts, errp);
         if (rc) {
             break;
         }
         assert(!errp || !*errp);
     }
-    loc_pop(&loc);
+    //loc_pop(&loc);
     return rc;
 }
 
diff --git a/qcow2/lib/util/qemu-print.c b/qcow2/lib/util/qemu-print.c
index 69ba612f..98ca5474 100644
--- a/qcow2/lib/util/qemu-print.c
+++ b/qcow2/lib/util/qemu-print.c
@@ -11,7 +11,7 @@
  */
 
 #include "qemu/osdep.h"
-#include "monitor/monitor.h"
+//#include "monitor/monitor.h"
 #include "qemu/qemu-print.h"
 
 /*
@@ -20,10 +20,12 @@
  */
 int qemu_vprintf(const char *fmt, va_list ap)
 {
+#if 0
     Monitor *cur_mon = monitor_cur();
     if (cur_mon) {
         return monitor_vprintf(cur_mon, fmt, ap);
     }
+#endif
     return vprintf(fmt, ap);
 }
 
@@ -48,9 +50,11 @@ int qemu_printf(const char *fmt, ...)
  */
 int qemu_vfprintf(FILE *stream, const char *fmt, va_list ap)
 {
+#if 0
     if (!stream) {
         return monitor_vprintf(monitor_cur(), fmt, ap);
     }
+#endif
     return vfprintf(stream, fmt, ap);
 }
 
diff --git a/qcow2/lib/util/qemu-thread-common.h b/qcow2/lib/util/qemu-thread-common.h
index 2af6b120..d09ade17 100644
--- a/qcow2/lib/util/qemu-thread-common.h
+++ b/qcow2/lib/util/qemu-thread-common.h
@@ -14,7 +14,7 @@
 #define QEMU_THREAD_COMMON_H
 
 #include "qemu/thread.h"
-#include "trace.h"
+//#include "trace.h"
 
 static inline void qemu_mutex_post_init(QemuMutex *mutex)
 {
@@ -28,7 +28,7 @@ static inline void qemu_mutex_post_init(QemuMutex *mutex)
 static inline void qemu_mutex_pre_lock(QemuMutex *mutex,
                                        const char *file, int line)
 {
-    trace_qemu_mutex_lock(mutex, file, line);
+    //trace_qemu_mutex_lock(mutex, file, line);
 }
 
 static inline void qemu_mutex_post_lock(QemuMutex *mutex,
@@ -38,7 +38,7 @@ static inline void qemu_mutex_post_lock(QemuMutex *mutex,
     mutex->file = file;
     mutex->line = line;
 #endif
-    trace_qemu_mutex_locked(mutex, file, line);
+    //trace_qemu_mutex_locked(mutex, file, line);
 }
 
 static inline void qemu_mutex_pre_unlock(QemuMutex *mutex,
@@ -48,7 +48,7 @@ static inline void qemu_mutex_pre_unlock(QemuMutex *mutex,
     mutex->file = NULL;
     mutex->line = 0;
 #endif
-    trace_qemu_mutex_unlock(mutex, file, line);
+    //trace_qemu_mutex_unlock(mutex, file, line);
 }
 
 #endif
diff --git a/qcow2/lib/util/qemu-thread-posix.c b/qcow2/lib/util/qemu-thread-posix.c
index b2e26e21..8ea29d06 100644
--- a/qcow2/lib/util/qemu-thread-posix.c
+++ b/qcow2/lib/util/qemu-thread-posix.c
@@ -15,7 +15,7 @@
 #include "qemu/atomic.h"
 #include "qemu/notify.h"
 #include "qemu-thread-common.h"
-#include "qemu/tsan.h"
+//#include "qemu/tsan.h"
 #include "qemu/bitmap.h"
 
 #ifdef CONFIG_PTHREAD_SET_NAME_NP
@@ -235,9 +235,9 @@ qemu_cond_timedwait_ts(QemuCond *cond, QemuMutex *mutex, struct timespec *ts,
     int err;
 
     assert(cond->initialized);
-    trace_qemu_mutex_unlock(mutex, file, line);
+    //trace_qemu_mutex_unlock(mutex, file, line);
     err = pthread_cond_timedwait(&cond->cond, &mutex->lock, ts);
-    trace_qemu_mutex_locked(mutex, file, line);
+    //trace_qemu_mutex_locked(mutex, file, line);
     if (err && err != ETIMEDOUT) {
         error_exit(err, __func__);
     }
@@ -518,7 +518,7 @@ static void *qemu_thread_start(void *args)
         pthread_set_name_np(pthread_self(), qemu_thread_args->name);
 # endif
     }
-    QEMU_TSAN_ANNOTATE_THREAD_NAME(qemu_thread_args->name);
+    //QEMU_TSAN_ANNOTATE_THREAD_NAME(qemu_thread_args->name);
     g_free(qemu_thread_args->name);
     g_free(qemu_thread_args);
 
diff --git a/qcow2/lib/util/qemu-timer.c b/qcow2/lib/util/qemu-timer.c
index 6b1533bc..bdef6238 100644
--- a/qcow2/lib/util/qemu-timer.c
+++ b/qcow2/lib/util/qemu-timer.c
@@ -27,8 +27,8 @@
 #include "qemu/timer.h"
 #include "qemu/lockable.h"
 #include "sysemu/cpu-timers.h"
-#include "sysemu/replay.h"
-#include "sysemu/cpus.h"
+//#include "sysemu/replay.h"
+//#include "sysemu/cpus.h"
 
 #ifdef CONFIG_POSIX
 #include <pthread.h>
@@ -522,14 +522,18 @@ bool timerlist_run_timers(QEMUTimerList *timer_list)
     case QEMU_CLOCK_VIRTUAL:
         break;
     case QEMU_CLOCK_HOST:
+#if 0
         if (!replay_checkpoint(CHECKPOINT_CLOCK_HOST)) {
             goto out;
         }
+#endif
         break;
     case QEMU_CLOCK_VIRTUAL_RT:
+#if 0
         if (!replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL_RT)) {
             goto out;
         }
+#endif
         break;
     }
 
@@ -552,6 +556,7 @@ bool timerlist_run_timers(QEMUTimerList *timer_list)
              */
             break;
         }
+#if 0
         /* Checkpoint for virtual clock is redundant in cases where
          * it's being triggered with only non-EXTERNAL timers, because
          * these timers don't change guest state directly.
@@ -563,6 +568,7 @@ bool timerlist_run_timers(QEMUTimerList *timer_list)
             qemu_mutex_unlock(&timer_list->active_timers_lock);
             goto out;
         }
+#endif
 
         /* remove timer from the list before calling the callback */
         timer_list->active_timers = ts->next;
@@ -604,6 +610,7 @@ void timerlistgroup_deinit(QEMUTimerListGroup *tlg)
     QEMUClockType type;
     for (type = 0; type < QEMU_CLOCK_MAX; type++) {
         timerlist_free(tlg->tl[type]);
+        tlg->tl[type] = NULL;
     }
 }
 
@@ -637,18 +644,28 @@ int64_t qemu_clock_get_ns(QEMUClockType type)
         return get_clock();
     default:
     case QEMU_CLOCK_VIRTUAL:
+#if 0
         return cpus_get_virtual_clock();
+#else
+        return get_clock();
+#endif
     case QEMU_CLOCK_HOST:
-        return REPLAY_CLOCK(REPLAY_CLOCK_HOST, get_clock_realtime());
+        return /*REPLAY_CLOCK(REPLAY_CLOCK_HOST,*/ get_clock_realtime()/*)*/;
     case QEMU_CLOCK_VIRTUAL_RT:
+#if 0
         return REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT, cpu_get_clock());
+#else
+        assert(0);
+#endif
     }
 }
 
+#if 0
 static void qemu_virtual_clock_set_ns(int64_t time)
 {
     return cpus_set_virtual_clock(time);
 }
+#endif
 
 void init_clocks(QEMUTimerListNotifyCB *notify_cb)
 {
@@ -681,6 +698,7 @@ bool qemu_clock_run_all_timers(void)
     return progress;
 }
 
+#if 0
 int64_t qemu_clock_advance_virtual_time(int64_t dest)
 {
     int64_t clock = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
@@ -711,3 +729,4 @@ int64_t qemu_clock_advance_virtual_time(int64_t dest)
 
     return clock;
 }
+#endif
diff --git a/qcow2/lib/util/qsp.c b/qcow2/lib/util/qsp.c
index 6b783e2e..5e54c4be 100644
--- a/qcow2/lib/util/qsp.c
+++ b/qcow2/lib/util/qsp.c
@@ -61,10 +61,11 @@
 #include "qemu/qemu-print.h"
 #include "qemu/thread.h"
 #include "qemu/timer.h"
-#include "qemu/qht.h"
+//#include "qemu/qht.h"
 #include "qemu/rcu.h"
-#include "qemu/xxhash.h"
+//#include "qemu/xxhash.h"
 
+#if 0
 enum QSPType {
     QSP_MUTEX,
     QSP_BQL_MUTEX,
@@ -124,15 +125,19 @@ static const char * const qsp_typenames[] = {
     [QSP_CONDVAR]   = "condvar",
 };
 
+#endif
 QemuMutexLockFunc bql_mutex_lock_func = qemu_mutex_lock_impl;
 QemuMutexLockFunc qemu_mutex_lock_func = qemu_mutex_lock_impl;
+#if 0
 QemuMutexTrylockFunc qemu_mutex_trylock_func = qemu_mutex_trylock_impl;
 QemuRecMutexLockFunc qemu_rec_mutex_lock_func = qemu_rec_mutex_lock_impl;
 QemuRecMutexTrylockFunc qemu_rec_mutex_trylock_func =
     qemu_rec_mutex_trylock_impl;
+#endif
 QemuCondWaitFunc qemu_cond_wait_func = qemu_cond_wait_impl;
 QemuCondTimedWaitFunc qemu_cond_timedwait_func = qemu_cond_timedwait_impl;
 
+#if 0
 /*
  * It pays off to _not_ hash callsite->file; hashing a string is slow, and
  * without it we still get a pretty unique hash.
@@ -811,3 +816,4 @@ void qsp_reset(void)
         call_rcu(old, qsp_snapshot_destroy, rcu);
     }
 }
+#endif
diff --git a/qcow2/lib/util/thread-pool.c b/qcow2/lib/util/thread-pool.c
index 27eb777e..c0026baa 100644
--- a/qcow2/lib/util/thread-pool.c
+++ b/qcow2/lib/util/thread-pool.c
@@ -19,7 +19,7 @@
 #include "qemu/queue.h"
 #include "qemu/thread.h"
 #include "qemu/coroutine.h"
-#include "trace.h"
+//#include "trace.h"
 #include "block/thread-pool.h"
 #include "qemu/main-loop.h"
 
@@ -184,8 +184,8 @@ restart:
             continue;
         }
 
-        trace_thread_pool_complete(pool, elem, elem->common.opaque,
-                                   elem->ret);
+        //trace_thread_pool_complete(pool, elem, elem->common.opaque,
+        //                           elem->ret);
         QLIST_REMOVE(elem, all);
 
         if (elem->common.cb) {
@@ -220,7 +220,7 @@ static void thread_pool_cancel(BlockAIOCB *acb)
     ThreadPoolElement *elem = (ThreadPoolElement *)acb;
     ThreadPool *pool = elem->pool;
 
-    trace_thread_pool_cancel(elem, elem->common.opaque);
+    //trace_thread_pool_cancel(elem, elem->common.opaque);
 
     QEMU_LOCK_GUARD(&pool->lock);
     if (elem->state == THREAD_QUEUED) {
@@ -256,7 +256,7 @@ BlockAIOCB *thread_pool_submit_aio(ThreadPoolFunc *func, void *arg,
 
     QLIST_INSERT_HEAD(&pool->head, req, all);
 
-    trace_thread_pool_submit(pool, req, arg);
+    //trace_thread_pool_submit(pool, req, arg);
 
     qemu_mutex_lock(&pool->lock);
     if (pool->idle_threads == 0 && pool->cur_threads < pool->max_threads) {
diff --git a/qcow2/qemu-img.c b/qcow2/qemu-img.c
index 7668f867..60db40b2 100644
--- a/qcow2/qemu-img.c
+++ b/qcow2/qemu-img.c
@@ -25,9 +25,9 @@
 #include "qemu/osdep.h"
 #include <getopt.h>
 
-#include "qemu/help-texts.h"
+//#include "qemu/help-texts.h"
 #include "qemu/qemu-progress.h"
-#include "qemu-version.h"
+//#include "qemu-version.h"
 #include "qapi/error.h"
 #include "qapi/qapi-commands-block-core.h"
 #include "qapi/qapi-visit-block-core.h"
@@ -38,25 +38,24 @@
 #include "qemu/config-file.h"
 #include "qemu/option.h"
 #include "qemu/error-report.h"
-#include "qemu/log.h"
+//#include "qemu/log.h"
 #include "qemu/main-loop.h"
 #include "qemu/module.h"
-#include "qemu/sockets.h"
+//#include "qemu/sockets.h"
 #include "qemu/units.h"
 #include "qemu/memalign.h"
-#include "qom/object_interfaces.h"
+//#include "qom/object_interfaces.h"
 #include "sysemu/block-backend.h"
 #include "block/block_int.h"
 #include "block/blockjob.h"
 #include "block/dirty-bitmap.h"
 #include "block/qapi.h"
-#include "crypto/init.h"
-#include "trace/control.h"
-#include "qemu/throttle.h"
-#include "block/throttle-groups.h"
+//#include "crypto/init.h"
+//#include "trace/control.h"
+//#include "qemu/throttle.h"
+//#include "block/throttle-groups.h"
 
-#define QEMU_IMG_VERSION "qemu-img version " QEMU_FULL_VERSION \
-                          "\n" QEMU_COPYRIGHT "\n"
+#define QEMU_IMG_VERSION "qemu-img version 9.1.1"
 
 typedef struct img_cmd_t {
     const char *name;
@@ -230,7 +229,7 @@ void help(void)
 
     printf("%s\nSupported formats:", help_msg);
     bdrv_iterate_format(format_print, NULL, false);
-    printf("\n\n" QEMU_HELP_BOTTOM "\n");
+    //printf("\n\n" QEMU_HELP_BOTTOM "\n");
     exit(EXIT_SUCCESS);
 }
 
@@ -563,7 +562,7 @@ static int img_create(int argc, char **argv)
             flags |= BDRV_O_NO_BACKING;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         }
     }
@@ -790,7 +789,7 @@ static int img_check(int argc, char **argv)
             force_share = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -930,6 +929,8 @@ static void run_block_job(BlockJob *job, Error **errp)
             progress = (float)progress_current / progress_total * 100.f;
         }
         qemu_progress_print(progress, 0);
+        printf("(%ld/%ld)\r", progress_current, progress_total);
+        fflush(stdout);
         job_lock();
     } while (!job_is_ready_locked(&job->job) &&
              !job_is_completed_locked(&job->job));
@@ -1014,7 +1015,7 @@ static int img_commit(int argc, char **argv)
             }
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -1124,6 +1125,7 @@ unref_backing:
 
 done:
     qemu_progress_end();
+    printf("\n");
 
     /*
      * Manually inactivate the image first because this way we can know whether
@@ -1423,6 +1425,7 @@ static int img_compare(int argc, char **argv)
             break;
         case OPTION_OBJECT:
             {
+#if 0
                 Error *local_err = NULL;
 
                 if (!user_creatable_add_from_str(optarg, &local_err)) {
@@ -1434,6 +1437,7 @@ static int img_compare(int argc, char **argv)
                         exit(EXIT_SUCCESS);
                     }
                 }
+#endif
                 break;
             }
         case OPTION_IMAGE_OPTS:
@@ -2222,6 +2226,7 @@ static int convert_copy_bitmaps(BlockDriverState *src, BlockDriverState *dst,
 
 static void set_rate_limit(BlockBackend *blk, int64_t rate_limit)
 {
+#if 0
     ThrottleConfig cfg;
 
     throttle_config_init(&cfg);
@@ -2229,6 +2234,7 @@ static void set_rate_limit(BlockBackend *blk, int64_t rate_limit)
 
     blk_io_limits_enable(blk, CONVERT_THROTTLE_GROUP);
     blk_set_io_limits(blk, &cfg);
+#endif
 }
 
 static int img_convert(int argc, char **argv)
@@ -2384,7 +2390,7 @@ static int img_convert(int argc, char **argv)
             }
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -3051,7 +3057,7 @@ static int img_info(int argc, char **argv)
             chain = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -3291,7 +3297,7 @@ static int img_map(int argc, char **argv)
             }
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -3451,7 +3457,7 @@ static int img_snapshot(int argc, char **argv)
             force_share = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -3608,7 +3614,7 @@ static int img_rebase(int argc, char **argv)
             quiet = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -4093,7 +4099,7 @@ static int img_resize(int argc, char **argv)
             quiet = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -4297,7 +4303,7 @@ static int img_amend(int argc, char **argv)
             quiet = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -4870,7 +4876,7 @@ static int img_bitmap(int argc, char **argv)
             merge = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -5145,7 +5151,7 @@ static int img_dd(int argc, char **argv)
             force_share = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -5405,7 +5411,7 @@ static int img_measure(int argc, char **argv)
             force_share = true;
             break;
         case OPTION_OBJECT:
-            user_creatable_process_cmdline(optarg);
+            //user_creatable_process_cmdline(optarg);
             break;
         case OPTION_IMAGE_OPTS:
             image_opts = true;
@@ -5555,14 +5561,16 @@ int main(int argc, char **argv)
     signal(SIGPIPE, SIG_IGN);
 #endif
 
-    socket_init();
+    //socket_init();
     error_init(argv[0]);
     module_call_init(MODULE_INIT_TRACE);
     qemu_init_exec_dir(argv[0]);
 
     qemu_init_main_loop(&error_fatal);
+    qemu_init_cpu_loop();
+    bql_lock();
 
-    qcrypto_init(&error_fatal);
+    //qcrypto_init(&error_fatal);
 
     module_call_init(MODULE_INIT_QOM);
     bdrv_init();
@@ -5571,7 +5579,7 @@ int main(int argc, char **argv)
     }
 
     qemu_add_opts(&qemu_source_opts);
-    qemu_add_opts(&qemu_trace_opts);
+    //qemu_add_opts(&qemu_trace_opts);
 
     while ((c = getopt_long(argc, argv, "+:hVT:", long_options, NULL)) != -1) {
         switch (c) {
@@ -5588,7 +5596,7 @@ int main(int argc, char **argv)
             printf(QEMU_IMG_VERSION);
             return 0;
         case 'T':
-            trace_opt_parse(optarg);
+            //trace_opt_parse(optarg);
             break;
         }
     }
@@ -5603,11 +5611,11 @@ int main(int argc, char **argv)
     argv += optind;
     qemu_reset_optind();
 
-    if (!trace_init_backends()) {
-        exit(1);
-    }
-    trace_init_file();
-    qemu_set_log(LOG_TRACE, &error_fatal);
+    //if (!trace_init_backends()) {
+    //    exit(1);
+    //}
+    //trace_init_file();
+    //qemu_set_log(LOG_TRACE, &error_fatal);
 
     /* find the command */
     for (cmd = img_cmds; cmd->name != NULL; cmd++) {
