From c19c0de43aa7dc930868d10da112b6fcafb334e4 Mon Sep 17 00:00:00 2001
From: Kevin Lampis <klampis@cloud.com>
Date: Wed, 7 Aug 2024 10:16:38 +0100
Subject: [PATCH 04/30] CP-46765 - Fix asan issues in unit tests

Signed-off-by: Kevin Lampis <klampis@cloud.com>
---
 drivers/tapdisk-nbdserver.h                |   2 +
 mockatests/cbt/Makefile.am                 |   3 -
 mockatests/cbt/test-cbt-util-set.c         |  16 +-
 mockatests/control/Makefile.am             |   3 -
 mockatests/control/test-suites.h           |   1 +
 mockatests/control/test-tap-ctl-allocate.c |   2 +
 mockatests/drivers/Makefile.am             |   3 -
 mockatests/drivers/test-scheduler.c        | 243 ++++++++++++++++-----
 mockatests/drivers/test-tapdisk-vbd.c      |  41 ++--
 mockatests/vhd/Makefile.am                 |   3 -
 10 files changed, 229 insertions(+), 88 deletions(-)

diff --git a/drivers/tapdisk-nbdserver.h b/drivers/tapdisk-nbdserver.h
index c572c9d4..e0fde58a 100644
--- a/drivers/tapdisk-nbdserver.h
+++ b/drivers/tapdisk-nbdserver.h
@@ -204,4 +204,6 @@ void tapdisk_nbdserver_handshake_cb(event_id_t, char, void*);
 int recv_fully_or_fail(int f, void *buf, size_t len);
 int send_fully_or_fail(int f, void *buf, size_t len);
 
+void free_extents(struct tapdisk_extents *extents);
+
 #endif /* _TAPDISK_NBDSERVER_H_ */
diff --git a/mockatests/cbt/Makefile.am b/mockatests/cbt/Makefile.am
index a6503a8a..ee2cfe83 100644
--- a/mockatests/cbt/Makefile.am
+++ b/mockatests/cbt/Makefile.am
@@ -1,6 +1,3 @@
-CFLAGS:=$(filter-out -fsanitize=leak,$(CFLAGS))
-LDFLAGS:=$(filter-out -static-liblsan,$(LDFLAGS))
-
 AM_CFLAGS  = -Wall
 AM_CFLAGS += -Werror
 AM_CFLAGS += -fprofile-dir=/tmp/coverage/blktap/mockatests/cbt -fprofile-arcs -ftest-coverage
diff --git a/mockatests/cbt/test-cbt-util-set.c b/mockatests/cbt/test-cbt-util-set.c
index c6b05a87..e454e2e6 100644
--- a/mockatests/cbt/test-cbt-util-set.c
+++ b/mockatests/cbt/test-cbt-util-set.c
@@ -51,8 +51,8 @@ test_cbt_util_set_parent(void **state)
 	int result;
 	void *log_meta;
 	uuid_t parent;
-	char uuid_str[36];
-	char uuid_str_after[36];
+	char uuid_str[37];
+	char uuid_str_after[37];
 
 	uuid_generate_random(parent);
 	uuid_unparse(parent, uuid_str);
@@ -80,8 +80,8 @@ test_cbt_util_set_child(void **state)
 	int result;
 	void *log_meta;
 	uuid_t child;
-	char uuid_str[36];
-	char uuid_str_after[36];
+	char uuid_str[37];
+	char uuid_str_after[37];
 
 	uuid_generate_random(child);
 	uuid_unparse(child, uuid_str);
@@ -108,7 +108,7 @@ test_cbt_util_set_flag(void **state)
 {
 	int result;
 	void *log_meta;
-	char flag_string[1] = "2";
+	char *flag_string = "2";
 	int flag_int = 2;
 	int log_flag;
 	char* args[] = {"cbt-util", "-n", "test_disk.log", "-f", flag_string};
@@ -337,7 +337,7 @@ test_cbt_util_set_malloc_failure(void **state)
 {
 	int result;
 	uuid_t parent;
-	char uuid_str[36];
+	char uuid_str[37];
 	uuid_generate_random(parent);
 	uuid_unparse(parent, uuid_str);
 
@@ -356,7 +356,7 @@ test_cbt_util_set_no_data_failure(void **state)
 {
 	int result;
 	uuid_t parent;
-	char uuid_str[36];
+	char uuid_str[37];
 	uuid_generate_random(parent);
 	uuid_unparse(parent, uuid_str);
 
@@ -377,7 +377,7 @@ test_cbt_util_set_no_file_failure(void **state)
 {
 	int result;
 	uuid_t parent;
-	char uuid_str[36];
+	char uuid_str[37];
 	uuid_generate_random(parent);
 	uuid_unparse(parent, uuid_str);
 
diff --git a/mockatests/control/Makefile.am b/mockatests/control/Makefile.am
index 140ac6a8..73094100 100644
--- a/mockatests/control/Makefile.am
+++ b/mockatests/control/Makefile.am
@@ -1,6 +1,3 @@
-CFLAGS:=$(filter-out -fsanitize=leak,$(CFLAGS))
-LDFLAGS:=$(filter-out -static-liblsan,$(LDFLAGS))
-
 AM_CFLAGS  = -Wall
 AM_CFLAGS += -Werror
 AM_CFLAGS += -fprofile-dir=/tmp/coverage/blktap/mockatests/control -fprofile-arcs -ftest-coverage
diff --git a/mockatests/control/test-suites.h b/mockatests/control/test-suites.h
index 556d3de3..9e32d506 100644
--- a/mockatests/control/test-suites.h
+++ b/mockatests/control/test-suites.h
@@ -35,6 +35,7 @@
 #include <cmocka.h>
 #include <uuid/uuid.h>
 #include <stdint.h>
+#include <stdlib.h>
 #include <cbt-util.h>
 
 
diff --git a/mockatests/control/test-tap-ctl-allocate.c b/mockatests/control/test-tap-ctl-allocate.c
index 54602eb7..c8abe3a6 100644
--- a/mockatests/control/test-tap-ctl-allocate.c
+++ b/mockatests/control/test-tap-ctl-allocate.c
@@ -405,4 +405,6 @@ void test_tap_ctl_allocate_success(void **state)
 	free_mock_misc();
 
 	assert_int_equal(0, result);
+
+	free(devname);
 }
diff --git a/mockatests/drivers/Makefile.am b/mockatests/drivers/Makefile.am
index 916845b3..71fe3aae 100644
--- a/mockatests/drivers/Makefile.am
+++ b/mockatests/drivers/Makefile.am
@@ -1,6 +1,3 @@
-CFLAGS:=$(filter-out -fsanitize=leak,$(CFLAGS))
-LDFLAGS:=$(filter-out -static-liblsan,$(LDFLAGS))
-
 AM_CFLAGS  = -Wall
 AM_CFLAGS += -Werror
 AM_CFLAGS += -fprofile-dir=/tmp/coverage/blktap/mockatests/drivers -fprofile-arcs -ftest-coverage
diff --git a/mockatests/drivers/test-scheduler.c b/mockatests/drivers/test-scheduler.c
index bd22cbfe..113ffd8b 100644
--- a/mockatests/drivers/test-scheduler.c
+++ b/mockatests/drivers/test-scheduler.c
@@ -182,6 +182,9 @@ test_scheduler_register_event_null_callback(void **state)
 
   const int r = scheduler_register_event(&s, mode, fd, timeout, cb, private);
   assert_int_equal(r, -EINVAL);
+
+  scheduler_unregister_event(&s, r);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -198,6 +201,9 @@ test_scheduler_register_event_bad_mode(void **state)
 
   const int r = scheduler_register_event(&s, mode, fd, timeout, cb, private);
   assert_int_equal(r, -EINVAL);
+
+  scheduler_unregister_event(&s, r);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -225,6 +231,10 @@ test_scheduler_register_multiple_events(void **state)
 
   /* The two event IDs we were given are different */
   assert_int_not_equal(event_id1, event_id2);
+
+  scheduler_unregister_event(&s, event_id1);
+  scheduler_unregister_event(&s, event_id2);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -256,6 +266,9 @@ test_scheduler_register_event_populates_event(void **state)
 
   assert_int_equal(e->deadline.tv_sec,  fake_gettimeofday.tv_sec + timeout.tv_sec);
   assert_int_equal(e->deadline.tv_usec, fake_gettimeofday.tv_usec + timeout.tv_usec);
+
+  scheduler_unregister_event(&s, event_id1);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -270,11 +283,14 @@ test_scheduler_set_timeout_inf(void **state)
   struct timeval timeout = TV_INF;
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
 
   const event_t* e = list_first_entry(&s.events, event_t, next);
 
   assert_true(TV_IS_INF(e->timeout));
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -300,12 +316,14 @@ test_scheduler_set_timeout_on_non_polled_event(void **state)
   struct timeval timeout = { .tv_sec = 996 };
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
   const int r = scheduler_event_set_timeout(&s, e->id, (struct timeval){});
   assert_int_equal(r, -EINVAL);
 
   close(fd);
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -320,10 +338,13 @@ test_scheduler_set_timeout_missing_event(void **state)
   struct timeval timeout = { .tv_sec = 996 };
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
   const int r = scheduler_event_set_timeout(&s, e->id+1, (struct timeval){});
   assert_int_equal(r, -ENOENT);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -343,9 +364,9 @@ test_scheduler_set_timeout(void **state)
   int fake_gettimeofday_tv_sec = 1;
   fake_gettimeofday = (struct timeval){ .tv_sec = fake_gettimeofday_tv_sec, .tv_usec = 0};
 
-  (void)scheduler_register_event(&s, mode, fd, timeout1, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout2, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout3, cb, NULL);
+  const int id1 = scheduler_register_event(&s, mode, fd, timeout1, cb, NULL);
+  const int id2 = scheduler_register_event(&s, mode, fd, timeout2, cb, NULL);
+  const int id3 = scheduler_register_event(&s, mode, fd, timeout3, cb, NULL);
   const event_t* e1 = list_first_entry(&s.events, event_t, next);
   const event_t* e2 = list_next_entry(e1, next);
   const event_t* e3 = list_next_entry(e2, next);
@@ -366,6 +387,11 @@ test_scheduler_set_timeout(void **state)
   assert_int_equal(e1->deadline.tv_sec, fake_gettimeofday_tv_sec + timeout1.tv_sec);
   assert_int_equal(e2->deadline.tv_sec, fake_gettimeofday_tv_sec + new_timeout2.tv_sec);
   assert_int_equal(e3->deadline.tv_sec, fake_gettimeofday_tv_sec + timeout3.tv_sec);
+
+  scheduler_unregister_event(&s, id1);
+  scheduler_unregister_event(&s, id2);
+  scheduler_unregister_event(&s, id3);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -382,7 +408,7 @@ test_scheduler_set_timeout_inf_and_deadline(void **state)
 
   fake_gettimeofday = (struct timeval){ .tv_sec = 1, .tv_usec = 2};
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
 
   assert_int_equal(e->timeout.tv_sec, timeout.tv_sec);
@@ -392,6 +418,9 @@ test_scheduler_set_timeout_inf_and_deadline(void **state)
 
   assert_true(TV_IS_INF(e->timeout));
   assert_true(TV_IS_INF(e->deadline));
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -406,12 +435,15 @@ test_scheduler_unregister_event_will_set_dead_field(void **state)
   struct timeval timeout = { .tv_sec = 1 };
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
   assert_int_not_equal(e->dead, 1);
 
   scheduler_unregister_event(&s, e->id);
   assert_int_equal(e->dead, 1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -426,12 +458,15 @@ test_scheduler_unregister_event_will_ignore_invalid_event(void **state)
   struct timeval timeout = { .tv_sec = 1 };
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
   assert_int_not_equal(e->dead, 1);
 
   scheduler_unregister_event(&s, 0);
   assert_int_not_equal(e->dead, 1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -446,7 +481,7 @@ test_scheduler_mask_event_will_set_masked_field(void **state)
   struct timeval timeout = { .tv_sec = 1 };
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
   assert_int_not_equal(e->masked, 1);
 
@@ -455,6 +490,9 @@ test_scheduler_mask_event_will_set_masked_field(void **state)
 
   scheduler_mask_event(&s, e->id, 0);
   assert_int_not_equal(e->masked, 1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -469,12 +507,15 @@ test_scheduler_mask_event_will_accept_non_zero_value(void **state)
   struct timeval timeout = { .tv_sec = 1 };
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
   assert_int_not_equal(e->masked, 1);
 
   scheduler_mask_event(&s, e->id, 959);
   assert_int_equal(e->masked, 1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -489,12 +530,15 @@ test_scheduler_mask_event_will_ignore_invalid_event_id(void **state)
   struct timeval timeout = { .tv_sec = 1 };
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e = list_first_entry(&s.events, event_t, next);
   assert_int_not_equal(e->masked, 1);
 
   scheduler_mask_event(&s, 0, 1);
   assert_int_not_equal(e->masked, 1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -538,11 +582,11 @@ test_scheduler_get_uuid_overflow_fragmented(void **state)
   // | 1 | 3 |   |...
   // +---+---+---+---
   s.uuid = 1;
-  (void)scheduler_register_event(&s, SCHEDULER_POLL_TIMEOUT, 1,
+  const int id1 = scheduler_register_event(&s, SCHEDULER_POLL_TIMEOUT, 1,
                                  (struct timeval){}, &fake_event_cb, NULL);
 
   s.uuid = 3;
-  (void)scheduler_register_event(&s, SCHEDULER_POLL_TIMEOUT, 1,
+  const int id2 = scheduler_register_event(&s, SCHEDULER_POLL_TIMEOUT, 1,
                                  (struct timeval){}, &fake_event_cb, NULL);
 
   // After an overflow the next UUID should be 2
@@ -560,6 +604,10 @@ test_scheduler_get_uuid_overflow_fragmented(void **state)
   // +---+---+---+---+---
   // | 1 | 3 | 2 | 4 |...
   // +---+---+---+---+---
+
+  scheduler_unregister_event(&s, id1);
+  scheduler_unregister_event(&s, id2);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -578,9 +626,9 @@ test_scheduler_gc_will_remove_dead_events_from_list(void **state)
   // +---+  +---+  +---+
   // | 1 |->| 2 |->| 3 |
   // +---+  +---+  +---+
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id1 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id2 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id3 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
   const event_t* e1 = list_first_entry(&s.events, event_t, next);
   const event_t* e2 = list_next_entry(e1, next);
   const event_t* e3 = list_next_entry(e2, next);
@@ -602,6 +650,11 @@ test_scheduler_gc_will_remove_dead_events_from_list(void **state)
 
   // event 1 is now linked to event 3
   assert_ptr_equal(list_next_entry(e1, next), e3);
+
+  scheduler_unregister_event(&s, id1);
+  scheduler_unregister_event(&s, id2);
+  scheduler_unregister_event(&s, id3);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -616,12 +669,12 @@ test_scheduler_check_timeouts(void **state)
   struct timeval timeout = {};
   event_cb_t cb = &fake_event_cb;
 
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
-  (void)scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id1 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id2 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id3 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id4 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id5 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
+  const int id6 = scheduler_register_event(&s, mode, fd, timeout, cb, NULL);
 
   event_t* e1 = list_first_entry(&s.events, event_t, next);
   event_t* e2 = list_next_entry(e1, next);
@@ -647,6 +700,14 @@ test_scheduler_check_timeouts(void **state)
   assert_int_not_equal(e4->pending, SCHEDULER_POLL_TIMEOUT); // unchanged
   assert_int_not_equal(e5->pending, SCHEDULER_POLL_TIMEOUT); // unchanged
   assert_int_equal(e6->pending, SCHEDULER_POLL_TIMEOUT); // changed
+
+  scheduler_unregister_event(&s, id1);
+  scheduler_unregister_event(&s, id2);
+  scheduler_unregister_event(&s, id3);
+  scheduler_unregister_event(&s, id4);
+  scheduler_unregister_event(&s, id5);
+  scheduler_unregister_event(&s, id6);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -666,7 +727,7 @@ test_scheduler_callback(void **state)
   // Update current time to time_now1
   fake_gettimeofday = (struct timeval){ .tv_sec = time_now1 };
 
-  (void)scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
+  const int id = scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
   event_t* event1 = list_first_entry(&s.events, event_t, next);
 
   // Event deadline is using time_now1
@@ -691,6 +752,9 @@ test_scheduler_callback(void **state)
 
   // Event deadline has been updated using time_now2
   assert_int_equal(event1->deadline.tv_sec, to.tv_sec + time_now2);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -705,7 +769,7 @@ test_scheduler_callback_ignores_masked_events(void **state)
   const struct timeval to = {};
   event_cb_spy_t event_cb_spy = {};
 
-  (void)scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
+  const int id = scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
   event_t* event1 = list_first_entry(&s.events, event_t, next);
 
   // Mask the event here
@@ -718,6 +782,9 @@ test_scheduler_callback_ignores_masked_events(void **state)
   assert_int_equal(event_cb_spy.was_called, 0);
   assert_int_not_equal(event_cb_spy.mode, test_mode);
   assert_int_not_equal(event_cb_spy.id, event1->id);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -732,7 +799,7 @@ test_scheduler_run_events_run_callback_if_pending(void **state)
   const struct timeval to = {};
   event_cb_spy_t event_cb_spy = {};
 
-  (void)scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
+  const int id = scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Set event to pending
@@ -742,6 +809,9 @@ test_scheduler_run_events_run_callback_if_pending(void **state)
 
   assert_int_equal(n_dispatched, 1);
   assert_int_equal(event_cb_spy.was_called, 1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -756,7 +826,7 @@ test_scheduler_run_events_no_callback_if_not_pending(void **state)
   const struct timeval to = {};
   event_cb_spy_t event_cb_spy = {};
 
-  (void)scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
+  const int id = scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   event->pending = 0;
@@ -765,6 +835,9 @@ test_scheduler_run_events_no_callback_if_not_pending(void **state)
 
   assert_int_equal(n_dispatched, 0);
   assert_int_equal(event_cb_spy.was_called, 0);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -779,7 +852,7 @@ test_scheduler_run_events_pending_mode_is_reset(void **state)
   const struct timeval to = {};
   event_cb_spy_t event_cb_spy = {};
 
-  (void)scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
+  const int id = scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Set event to pending
@@ -792,6 +865,9 @@ test_scheduler_run_events_pending_mode_is_reset(void **state)
 
   // Event pending flag is reset
   assert_int_not_equal(event->pending, SCHEDULER_POLL_TIMEOUT);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -806,7 +882,7 @@ test_scheduler_run_events_ignore_event_if_dead(void **state)
   const struct timeval to = {};
   event_cb_spy_t event_cb_spy = {};
 
-  (void)scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
+  const int id = scheduler_register_event(&s, md, fd, to, &mock_event_cb, &event_cb_spy);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Set event to pending
@@ -818,6 +894,9 @@ test_scheduler_run_events_ignore_event_if_dead(void **state)
 
   assert_int_equal(n_dispatched, 0);
   assert_int_equal(event_cb_spy.was_called, 0);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -852,7 +931,7 @@ test_scheduler_prepare_events_masked_event_ignored(void **state)
   const char md = SCHEDULER_POLL_TIMEOUT;
   const int fd = 1;
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Mask the event here
@@ -861,6 +940,9 @@ test_scheduler_prepare_events_masked_event_ignored(void **state)
   scheduler_prepare_events(&s);
 
   assert_int_equal(s.max_fd, -1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -873,7 +955,7 @@ test_scheduler_prepare_events_dead_event_ignored(void **state)
   const char md = SCHEDULER_POLL_TIMEOUT;
   const int fd = 1;
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Unalive event here
@@ -882,6 +964,9 @@ test_scheduler_prepare_events_dead_event_ignored(void **state)
   scheduler_prepare_events(&s);
 
   assert_int_equal(s.max_fd, -1);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -894,11 +979,14 @@ test_scheduler_add_read_event(void **state)
   const char md = SCHEDULER_POLL_READ_FD;
   const int test_fd = 991;
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
+  const int id = scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
 
   scheduler_prepare_events(&s);
 
   assert_int_equal(s.max_fd, test_fd);
+
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -911,7 +999,7 @@ test_scheduler_read_event_with_invalid_fd(void **state)
   const char md = SCHEDULER_POLL_READ_FD;
   const int fd = mock_fd_create();
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Invalid event
@@ -922,6 +1010,8 @@ test_scheduler_read_event_with_invalid_fd(void **state)
   assert_int_equal(s.max_fd, -1);
 
   close(fd);
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -934,11 +1024,14 @@ test_scheduler_add_write_event(void **state)
   const char md = SCHEDULER_POLL_WRITE_FD;
   const int test_fd = 991;
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
 
   scheduler_prepare_events(&s);
 
   assert_int_equal(s.max_fd, test_fd);
+
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -951,7 +1044,7 @@ test_scheduler_write_event_with_invalid_fd(void **state)
   const char md = SCHEDULER_POLL_WRITE_FD;
   const int fd = mock_fd_create();
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Invalid event
@@ -960,7 +1053,10 @@ test_scheduler_write_event_with_invalid_fd(void **state)
   scheduler_prepare_events(&s);
 
   assert_int_equal(s.max_fd, -1);
+
   close(fd);
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -973,11 +1069,14 @@ test_scheduler_add_except_event(void **state)
   const char md = SCHEDULER_POLL_EXCEPT_FD;
   const int test_fd = 991;
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
 
   scheduler_prepare_events(&s);
 
   assert_int_equal(s.max_fd, test_fd);
+
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -990,7 +1089,7 @@ test_scheduler_except_event_with_invalid_fd(void **state)
   const char md = SCHEDULER_POLL_EXCEPT_FD;
   const int fd = mock_fd_create();
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
   event_t* event = list_first_entry(&s.events, event_t, next);
 
   // Invalid event
@@ -1000,6 +1099,8 @@ test_scheduler_except_event_with_invalid_fd(void **state)
 
   assert_int_equal(s.max_fd, -1);
   close(fd);
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1013,7 +1114,7 @@ test_scheduler_no_timeout_events_then_timeout_is_max(void **state)
   const char md = SCHEDULER_POLL_EXCEPT_FD;
   const int test_fd = mock_fd_create();
   const struct timeval to = {};
-  (void)scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, test_fd, to, &fake_event_cb, NULL);
 
   scheduler_prepare_events(&s);
 
@@ -1021,6 +1122,8 @@ test_scheduler_no_timeout_events_then_timeout_is_max(void **state)
   assert_int_equal(s.timeout.tv_sec, expected_tv.tv_sec);
 
   close(test_fd);
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1035,7 +1138,7 @@ test_scheduler_add_timeout_event(void **state)
   const int fd = 1;
   const struct timeval to = { .tv_sec = 10 };
   fake_gettimeofday = (struct timeval){ .tv_sec = 0, .tv_usec = 0};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
 
   const struct timeval time_now = { .tv_sec = 2, .tv_usec = 0};
   fake_gettimeofday = time_now;
@@ -1044,6 +1147,9 @@ test_scheduler_add_timeout_event(void **state)
 
   // New timeout value is time to the event deadline
   assert_int_equal(s.timeout.tv_sec, to.tv_sec - time_now.tv_sec);
+
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1059,8 +1165,8 @@ test_scheduler_multiple_timeout_events_use_lowest_timeout(void **state)
   const struct timeval to1 = { .tv_sec = 20 };
   const struct timeval to2 = { .tv_sec = 10 };
   fake_gettimeofday = (struct timeval){ .tv_sec = 0, .tv_usec = 0};
-  (void)scheduler_register_event(&s, md, fd, to1, &fake_event_cb, NULL);
-  (void)scheduler_register_event(&s, md, fd, to2, &fake_event_cb, NULL);
+  const int id1 = scheduler_register_event(&s, md, fd, to1, &fake_event_cb, NULL);
+  const int id2 = scheduler_register_event(&s, md, fd, to2, &fake_event_cb, NULL);
 
   const struct timeval time_now = { .tv_sec = 2, .tv_usec = 0};
   fake_gettimeofday = time_now;
@@ -1069,6 +1175,10 @@ test_scheduler_multiple_timeout_events_use_lowest_timeout(void **state)
 
   // New timeout is based on the smaller event timeout value (to2).
   assert_int_equal(s.timeout.tv_sec, to2.tv_sec - time_now.tv_sec);
+
+  scheduler_unregister_event(&s, id1);
+  scheduler_unregister_event(&s, id2);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1083,7 +1193,7 @@ test_scheduler_timeout_event_is_instant_if_deadline_is_now(void **state)
   const int fd = 1;
   const struct timeval to = { .tv_sec = 10 };
   fake_gettimeofday = (struct timeval){ .tv_sec = 0, .tv_usec = 0};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int event_id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
 
   // Set the time now to the event timeout
   fake_gettimeofday = to;
@@ -1092,6 +1202,9 @@ test_scheduler_timeout_event_is_instant_if_deadline_is_now(void **state)
 
   // New timeout is zero because deadline has already been reached.
   assert_int_equal(s.timeout.tv_sec, 0);
+
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1107,8 +1220,8 @@ test_scheduler_multiple_timeout_events_dont_interfere(void **state)
   const struct timeval to1 = { .tv_sec = 10 };
   const struct timeval to2 = { .tv_sec = 20 };
   fake_gettimeofday = (struct timeval){ .tv_sec = 0, .tv_usec = 0};
-  (void)scheduler_register_event(&s, md, fd, to1, &fake_event_cb, NULL);
-  (void)scheduler_register_event(&s, md, fd, to2, &fake_event_cb, NULL);
+  const int id1 = scheduler_register_event(&s, md, fd, to1, &fake_event_cb, NULL);
+  const int id2 = scheduler_register_event(&s, md, fd, to2, &fake_event_cb, NULL);
 
   // Set the time now to the first event timeout
   fake_gettimeofday = to1;
@@ -1117,6 +1230,10 @@ test_scheduler_multiple_timeout_events_dont_interfere(void **state)
 
   // Event though event2 still has 10 seconds left event1 is 0 therefor timeout is 0
   assert_int_equal(s.timeout.tv_sec, 0);
+
+  scheduler_unregister_event(&s, id1);
+  scheduler_unregister_event(&s, id2);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1131,11 +1248,13 @@ test_scheduler_timeout_event_ignored_if_no_timeout(void **state)
   const int fd = 1;
   const struct timeval to = TV_INF;
   fake_gettimeofday = (struct timeval){ .tv_sec = 0, .tv_usec = 0};
-  (void)scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
+  const int id = scheduler_register_event(&s, md, fd, to, &fake_event_cb, NULL);
 
   scheduler_prepare_events(&s);
 
   assert_int_equal(s.max_fd, -1);
+  scheduler_unregister_event(&s, id);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1163,11 +1282,12 @@ test_scheduler_run_single_read_fd(void **state)
   /* Create a scheduler event for this fd.
    * The callback will be called when fd is ready for reading. */
   event_cb_spy_t event_cb_spy = {};
+  int event_id;
   {
     const char mode = SCHEDULER_POLL_READ_FD;
     const struct timeval timeout = {};
-    const int ret = scheduler_register_event(&s, mode, fd, timeout, &mock_event_cb, &event_cb_spy);
-    assert_int_not_equal(ret, 0);
+    event_id = scheduler_register_event(&s, mode, fd, timeout, &mock_event_cb, &event_cb_spy);
+    assert_int_not_equal(event_id, 0);
   }
 
   /* Tick 1 - nothing changed so should timeout with no callback */
@@ -1181,6 +1301,8 @@ test_scheduler_run_single_read_fd(void **state)
   assert_int_equal(event_cb_spy.was_called, 1);
 
   close(fd);
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 /*
@@ -1204,11 +1326,12 @@ test_scheduler_run_single_write_fd(void **state)
   /* Create a scheduler event for this fd.
    * The callback will be called when fd is ready for writing. */
   event_cb_spy_t event_cb_spy = {};
+  int event_id;
   {
     const char mode = SCHEDULER_POLL_WRITE_FD;
     const struct timeval timeout = {};
-    const int r = scheduler_register_event(&s, mode, fd, timeout, &mock_event_cb, &event_cb_spy);
-    assert_int_not_equal(r, 0);
+    event_id = scheduler_register_event(&s, mode, fd, timeout, &mock_event_cb, &event_cb_spy);
+    assert_int_not_equal(event_id, 0);
   }
 
   /* Tick 1 - fd is ready for writing so event callback should be called */
@@ -1231,6 +1354,8 @@ test_scheduler_run_single_write_fd(void **state)
   assert_int_equal(event_cb_spy.was_called, 2);
 
   close(fd);
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 #if 0
@@ -1302,6 +1427,8 @@ test_scheduler_run_single_dead_event(void **state)
   assert_ptr_not_equal(e2, e1); /* The dead event is gone. */
 
   close(fd);
+  scheduler_unregister_event(&s, event_id);
+  scheduler_gc_events(&s);
 }
 
 /* Create two events with the same fd but different callbacks.
@@ -1355,6 +1482,9 @@ test_scheduler_run_duplicate_fds_are_handled_once(void **state)
   assert_int_equal(event_cb_spy2.was_called, 1);
 
   close(fd);
+  scheduler_unregister_event(&s, event_id1);
+  scheduler_unregister_event(&s, event_id2);
+  scheduler_gc_events(&s);
 }
 
 /* Register two events with different fds but the same callback.
@@ -1371,16 +1501,17 @@ test_scheduler_run_with_duplicate_callbacks(void **state)
 
   event_cb_spy_t event_cb_spy = {};
 
+  int event_id1, event_id2;
   {
     const char mode = SCHEDULER_POLL_WRITE_FD;
     const struct timeval timeout = {};
 
     /* Create a scheduler event for fd1. */
-    const int event_id1 = scheduler_register_event(&s, mode, fd1, timeout, &mock_event_cb, &event_cb_spy);
+    event_id1 = scheduler_register_event(&s, mode, fd1, timeout, &mock_event_cb, &event_cb_spy);
     assert_int_not_equal(event_id1, 0);
 
     /* Create a scheduler event for fd2 but same callback */
-    const int event_id2 = scheduler_register_event(&s, mode, fd2, timeout, &mock_event_cb, &event_cb_spy);
+    event_id2 = scheduler_register_event(&s, mode, fd2, timeout, &mock_event_cb, &event_cb_spy);
     assert_int_not_equal(event_id2, 0);
   }
 
@@ -1392,6 +1523,9 @@ test_scheduler_run_with_duplicate_callbacks(void **state)
 
   close(fd1);
   close(fd2);
+  scheduler_unregister_event(&s, event_id1);
+  scheduler_unregister_event(&s, event_id2);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1451,6 +1585,9 @@ test_scheduler_run_read_and_write_fd(void **state)
   assert_int_equal(event_cb_spy2.was_called, 2);
 
   close(fd);
+  scheduler_unregister_event(&s, event_id1);
+  scheduler_unregister_event(&s, event_id2);
+  scheduler_gc_events(&s);
 }
 
 void
@@ -1495,4 +1632,8 @@ test_scheduler_run_deleted_duplicate_event(void **state)
   assert_int_equal(event_cb_spy2.was_called, 1);
 
   close(fd);
+
+  scheduler_unregister_event(&s, event_id1);
+  scheduler_unregister_event(&s, event_id2);
+  scheduler_gc_events(&s);
 }
diff --git a/mockatests/drivers/test-tapdisk-vbd.c b/mockatests/drivers/test-tapdisk-vbd.c
index 123fdcde..ef46992c 100644
--- a/mockatests/drivers/test-tapdisk-vbd.c
+++ b/mockatests/drivers/test-tapdisk-vbd.c
@@ -40,26 +40,30 @@
 #include "tapdisk-disktype.h"
 #include "tapdisk-image.h"
 #include "tapdisk-interface.h"
+#include "tapdisk-nbdserver.h"
 
 void
 test_vbd_linked_list(void **state)
 {
-	tapdisk_extents_t extents;
-	bzero(&extents, sizeof(tapdisk_extents_t));
+	tapdisk_extents_t *extents = malloc(sizeof(*extents));
+	bzero(extents, sizeof(tapdisk_extents_t));
 	td_request_t vreq;
 	bzero(&vreq, sizeof(td_request_t));
 
 	vreq.sec = 0;
 	vreq.secs = 2;
 	vreq.status = 1;
-	
-	add_extent(&extents, &vreq);
-	assert_ptr_equal(extents.tail, extents.head);
-	assert_int_equal(extents.tail->start, 0);
-	assert_int_equal(extents.tail->length, 2);
-	assert_int_equal(extents.tail->flag, 1);
-	assert_null(extents.tail->next);
-	assert_int_equal(extents.count, 1);
+
+	add_extent(extents, &vreq);
+
+	assert_ptr_equal(extents->tail, extents->head);
+	assert_int_equal(extents->tail->start, 0);
+	assert_int_equal(extents->tail->length, 2);
+	assert_int_equal(extents->tail->flag, 1);
+	assert_null(extents->tail->next);
+	assert_int_equal(extents->count, 1);
+
+	free_extents(extents);
 }
 
 void
@@ -114,8 +118,8 @@ test_vbd_complete_block_status_request(void **stat)
 	td_image_t *image = tapdisk_image_allocate("blah", DISK_TYPE_VHD, TD_OPEN_RDONLY | TD_OPEN_SHAREABLE);
 	list_add_tail(&image->next, &vbd.images);
 
-	tapdisk_extents_t extents;
-	bzero(&extents, sizeof(extents));
+	tapdisk_extents_t *extents = malloc(sizeof(*extents));
+	bzero(extents, sizeof(*extents));
 	
 	td_vbd_request_t vreq;
 	bzero(&vreq, sizeof(td_vbd_request_t));
@@ -127,7 +131,7 @@ test_vbd_complete_block_status_request(void **stat)
 	iov.secs = 123;
 	vreq.iov = &iov;
 	vreq.op = TD_OP_BLOCK_STATUS;
-	vreq.data = &extents;
+	vreq.data = extents;
 
 	td_request_t my_treq;
 	bzero(&my_treq, sizeof(my_treq));
@@ -143,8 +147,11 @@ test_vbd_complete_block_status_request(void **stat)
 	my_treq.cb = tapdisk_vbd_complete_block_status_request;
 
 	tapdisk_vbd_complete_block_status_request(my_treq, 0);
-	assert_non_null(extents.head);
-	assert_int_equal(extents.head->flag, TD_BLOCK_STATE_HOLE);
-	assert_int_equal(extents.head->start, my_treq.sec);
-	assert_int_equal(extents.head->length, my_treq.secs);
+	assert_non_null(extents->head);
+	assert_int_equal(extents->head->flag, TD_BLOCK_STATE_HOLE);
+	assert_int_equal(extents->head->start, my_treq.sec);
+	assert_int_equal(extents->head->length, my_treq.secs);
+
+	tapdisk_image_close(image);
+	free_extents(extents);
 }
diff --git a/mockatests/vhd/Makefile.am b/mockatests/vhd/Makefile.am
index fb8f2fd3..ed9e35eb 100644
--- a/mockatests/vhd/Makefile.am
+++ b/mockatests/vhd/Makefile.am
@@ -1,6 +1,3 @@
-CFLAGS:=$(filter-out -fsanitize=leak,$(CFLAGS))
-LDFLAGS:=$(filter-out -static-liblsan,$(LDFLAGS))
-
 AM_CFLAGS  = -Wall
 AM_CFLAGS += -Werror
 AM_CFLAGS += -fprofile-dir=/tmp/coverage/blktap/mockatests/vhd -fprofile-arcs -ftest-coverage
