CP-23918: Create unit tests for cbt-util set

From: James Davis <james.davis1@citrix.com>

Created unit tests for cbt-util set covering the following four settings:
parent pointer, child pointer, consistency flag, size. Tests also cover
each possible error which is looked for and caught in cbt-util set. Testing
uncovered a memory leak in cbt-util set which has been fixed. Improvements
to how cbt-util.c prints out errors have also been made for cbt_util_set.

Signed-off-by: James Davis <james.davis1@citrix.com>
Reviewed-by: Chandrika Srinivasan <chandrika.srinivasan@citrix.com>

diff --git a/cbt/cbt-util.c b/cbt/cbt-util.c
index d4b8c55..d42f981 100644
--- a/cbt/cbt-util.c
+++ b/cbt/cbt-util.c
@@ -299,6 +299,9 @@ cbt_util_set(int argc, char **argv)
 	if (!argc || !argv)
 		goto usage;
 
+	/* Make sure we start from the start of the args */
+	optind = 1;
+
 	while ((c = getopt(argc, argv, "n:p:c:f:s:h")) != -1) {
 		switch (c) {
 			case 'n':
@@ -420,6 +423,8 @@ cbt_util_set(int argc, char **argv)
 	}
 
 error:
+	if(buf)
+		free(buf);
 	if(log_meta)
 		free(log_meta);
 	if(f)
diff --git a/mockatests/cbt/Makefile.am b/mockatests/cbt/Makefile.am
index 929e853..c941058 100644
--- a/mockatests/cbt/Makefile.am
+++ b/mockatests/cbt/Makefile.am
@@ -9,7 +9,7 @@ AM_CPPFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/cbt -I../include
 check_PROGRAMS = test-cbt-util
 TESTS = test-cbt-util
 
-test_cbt_util_SOURCES = test-cbt-util.c test-cbt-util-commands.c test-cbt-util-get.c test-cbt-util-create.c test-cbt-util-coalesce.c
+test_cbt_util_SOURCES = test-cbt-util.c test-cbt-util-commands.c test-cbt-util-set.c test-cbt-util-get.c test-cbt-util-create.c test-cbt-util-coalesce.c
 test_cbt_util_LDFLAGS = $(top_srcdir)/cbt/libcbtutil.la -lcmocka -luuid
 test_cbt_util_LDFLAGS += ../wrappers/libwrappers.la
 test_cbt_util_LDFLAGS += -Wl,--wrap=fopen,--wrap=fclose
diff --git a/mockatests/cbt/test-cbt-util-set.c b/mockatests/cbt/test-cbt-util-set.c
new file mode 100644
index 0000000..625380a
--- /dev/null
+++ b/mockatests/cbt/test-cbt-util-set.c
@@ -0,0 +1,362 @@
+/*
+ * Copyright (c) 2017, Citrix Systems, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. Neither the name of the copyright holder nor the names of its 
+ *     contributors may be used to endorse or promote products derived from 
+ *     this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+ * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#define __STDC_FORMAT_MACROS
+
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+#include <stdarg.h>
+#include <setjmp.h>
+#include <cmocka.h>
+#include <errno.h>
+#include <uuid/uuid.h>
+#include <inttypes.h>
+
+#include <cbt-util-priv.h>
+#include <wrappers.h>
+#include "test-suites.h"
+
+int __real_printf(const char *format, ...);
+
+void
+test_cbt_util_set_parent(void **state)
+{
+	int result;
+	void *log_meta;
+	uuid_t parent;
+	char uuid_str[36];
+	char uuid_str_after[36];
+
+	uuid_generate_random(parent);
+	uuid_unparse(parent, uuid_str);
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-p", uuid_str};
+
+	log_meta = malloc(sizeof(struct cbt_log_metadata));
+
+	FILE *test_log = fmemopen((void*)log_meta, sizeof(struct cbt_log_metadata), "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, 0);
+
+	uuid_unparse(((struct cbt_log_metadata*)log_meta)->parent, uuid_str_after);
+	assert_string_equal(uuid_str, uuid_str_after);
+
+	free(log_meta);
+}
+
+void
+test_cbt_util_set_child(void **state)
+{
+	int result;
+	void *log_meta;
+	uuid_t child;
+	char uuid_str[36];
+	char uuid_str_after[36];
+
+	uuid_generate_random(child);
+	uuid_unparse(child, uuid_str);
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-c", uuid_str};
+
+	log_meta = malloc(sizeof(struct cbt_log_metadata));
+
+	FILE *test_log = fmemopen((void*)log_meta, sizeof(struct cbt_log_metadata), "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, 0);
+
+	uuid_unparse(((struct cbt_log_metadata*)log_meta)->child, uuid_str_after);
+	assert_string_equal(uuid_str, uuid_str_after);
+
+	free(log_meta);
+}
+
+void
+test_cbt_util_set_flag(void **state)
+{
+	int result;
+	void *log_meta;
+	char flag_string[1] = "2";
+	int flag_int = 2;
+	int log_flag;
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-f", flag_string};
+
+	log_meta = malloc(sizeof(struct cbt_log_metadata));
+
+	FILE *test_log = fmemopen((void*)log_meta, sizeof(struct cbt_log_metadata), "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, 0);
+
+	log_flag = ((struct cbt_log_metadata*)log_meta)->consistent;
+	assert_int_equal(flag_int, log_flag);
+
+	free(log_meta);
+}
+
+void
+test_cbt_util_set_size(void **state)
+{
+	int result;
+	void *log_meta;
+	uint64_t size_int64 = 4194303;
+	char size_string[8];
+	snprintf(size_string, sizeof(size_string), "%" PRIu64, size_int64);
+	uint64_t log_size_int64;
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-s", size_string};
+
+	uint64_t btmsize = bitmap_size(size_int64);
+
+	int file_size = sizeof(struct cbt_log_metadata) + btmsize;
+	log_meta = malloc(file_size);
+
+	((struct cbt_log_metadata*)log_meta)->size = 2048;
+
+	memcpy(log_meta + sizeof(struct cbt_log_metadata), (void*)memcpy, btmsize);
+	FILE *test_log = fmemopen((void*)log_meta, file_size, "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, 0);
+
+	log_size_int64 = ((struct cbt_log_metadata*)log_meta)->size;
+	
+	assert_true(log_size_int64 == size_int64);
+
+	free(log_meta);
+}
+
+void
+test_cbt_util_set_size_smaller_file_failure(void **state)
+{
+	int result;
+	void *log_meta;
+	uint64_t size_int64 = 2048;
+	char size_string[8];
+	snprintf(size_string, sizeof(size_string), "%" PRIu64, size_int64);
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-s", size_string};
+
+
+	log_meta = malloc(sizeof(struct cbt_log_metadata));
+
+	((struct cbt_log_metadata*)log_meta)->size = 4096;
+
+	FILE *test_log = fmemopen((void*)log_meta, sizeof(struct cbt_log_metadata), "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, -EINVAL);
+
+	free(log_meta);
+}
+
+void
+test_cbt_util_set_size_malloc_failure(void **state)
+{
+	int result;
+	uint64_t size_int64 = 4096;
+	int file_size;
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-s", "4194303"};
+	void *log_meta;
+
+	uint64_t btmsize = bitmap_size(size_int64);
+
+	file_size = sizeof(struct cbt_log_metadata) + 4096;
+	log_meta = malloc(file_size);
+
+	((struct cbt_log_metadata*)log_meta)->size = 4096;
+	
+	memcpy(log_meta + sizeof(struct cbt_log_metadata), (void*)memcpy, btmsize);
+	FILE *test_log = fmemopen((void*)log_meta, file_size, "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);	
+		
+	malloc_succeeds(true);
+	malloc_succeeds(false);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, -ENOMEM);
+
+	disable_malloc_mock();
+	free(log_meta);
+}
+
+void
+test_cbt_util_set_size_no_bitmap_failure(void **state)
+{
+	int result;
+	void *log_meta;
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-s", "4194304"};
+
+	log_meta = malloc(sizeof(struct cbt_log_metadata));
+	((struct cbt_log_metadata*)log_meta)->size = 4096;
+
+	FILE *test_log = fmemopen((void*)log_meta, sizeof(struct cbt_log_metadata), "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, -EIO);
+
+	free(log_meta);
+}
+
+void
+test_cbt_util_set_size_write_failure(void **state)
+{
+	int result;
+	void *log_meta;
+	uint64_t size_int64 = 4194303;
+	char size_string[8];
+	snprintf(size_string, sizeof(size_string), "%" PRIu64, size_int64);
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-s", size_string};
+
+	uint64_t btmsize = bitmap_size(size_int64);
+
+	int file_size = sizeof(struct cbt_log_metadata) + btmsize;
+	log_meta = malloc(file_size);
+
+	((struct cbt_log_metadata*)log_meta)->size = 4096;
+
+	memcpy(log_meta + sizeof(struct cbt_log_metadata), (void*)memcpy, btmsize);
+	FILE *test_log = fmemopen((void*)log_meta, file_size, "r");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, -EIO);
+
+	free(log_meta);
+}
+
+
+void
+test_cbt_util_set_no_name_failure(void **state)
+{
+	int result;
+	char* args[] = {"cbt-util", "-p"};
+
+	struct printf_data *output;
+
+	output = setup_vprintf_mock(1024);
+
+	result = cbt_util_set(2, args);
+	assert_int_equal(result, -EINVAL);
+	free_printf_data(output);
+}
+
+void
+test_cbt_util_set_no_command_failure(void **state)
+{
+	int result;
+	char* args[] = {"cbt-util", "-n", "test_disk.log"};
+	struct printf_data *output;
+
+	disable_malloc_mock();
+	output = setup_vprintf_mock(1024);
+
+	result = cbt_util_set(3, args);
+	assert_int_equal(result, -EINVAL);
+	free_printf_data(output);
+}
+
+void
+test_cbt_util_set_malloc_failure(void **state)
+{
+	int result;
+	uuid_t parent;
+	char uuid_str[36];
+	uuid_generate_random(parent);
+	uuid_unparse(parent, uuid_str);
+
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-p", uuid_str};
+
+	malloc_succeeds(false);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, -ENOMEM);
+
+	disable_malloc_mock();
+}
+
+void
+test_cbt_util_set_no_data_failure(void **state)
+{
+	int result;
+	uuid_t parent;
+	char uuid_str[36];
+	uuid_generate_random(parent);
+	uuid_unparse(parent, uuid_str);
+
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-p", uuid_str};
+	void *log_meta[1];
+
+	FILE *test_log = fmemopen((void*)log_meta, 1, "r+");
+
+	will_return(__wrap_fopen, test_log);
+	expect_value(__wrap_fclose, fp, test_log);
+
+	result = cbt_util_set(5, args);
+	assert_int_equal(result, -EIO);
+}
+
+void
+test_cbt_util_set_no_file_failure(void **state)
+{
+	int result;
+	uuid_t parent;
+	char uuid_str[36];
+	uuid_generate_random(parent);
+	uuid_unparse(parent, uuid_str);
+
+
+	char* args[] = {"cbt-util", "-n", "test_disk.log", "-p", uuid_str};
+
+	will_return(__wrap_fopen, NULL);
+
+	result = cbt_util_set(5, args);
+
+	assert_int_equal(result, -ENOENT);
+}
diff --git a/mockatests/cbt/test-cbt-util.c b/mockatests/cbt/test-cbt-util.c
index 4988580..907f334 100644
--- a/mockatests/cbt/test-cbt-util.c
+++ b/mockatests/cbt/test-cbt-util.c
@@ -42,7 +42,8 @@ int main(void)
 		cmocka_run_group_tests_name("Command tests", cbt_command_tests, NULL, NULL) +
 		cmocka_run_group_tests_name("Get tests", cbt_get_tests, NULL, NULL) +
 		cmocka_run_group_tests_name("Create tests", cbt_create_tests, NULL, NULL) +
-		cmocka_run_group_tests_name("Coalesce tests", cbt_coalesce_tests, NULL, NULL);
+		cmocka_run_group_tests_name("Coalesce tests", cbt_coalesce_tests, NULL, NULL) +
+		cmocka_run_group_tests_name("Set tests", cbt_set_tests, NULL, NULL);
 
 	/* Need to flag that the tests are done so that the fclose mock goes quiescent */
 	disable_mocks();
diff --git a/mockatests/cbt/test-suites.h b/mockatests/cbt/test-suites.h
index 57b542a..867a0c6 100644
--- a/mockatests/cbt/test-suites.h
+++ b/mockatests/cbt/test-suites.h
@@ -62,6 +62,22 @@ void test_cbt_util_get_bitmap_nodata_failure(void **state);
 void test_cbt_util_get_bitmap_malloc_failure(void **state);
 void test_cbt_util_get_no_bitmap_flag_failure(void **state);
 
+/* 'cbt-util set' tests */
+void test_cbt_util_set_parent(void **state);
+void test_cbt_util_set_child(void **state);
+void test_cbt_util_set_flag(void **state);
+void test_cbt_util_set_size(void **state);
+void test_cbt_util_set_size_smaller_file_failure(void **state);
+void test_cbt_util_set_size_malloc_failure(void **state);
+void test_cbt_util_set_size_no_bitmap_failure(void **state);
+void test_cbt_util_set_size_write_failure(void **state);
+void test_cbt_util_set_no_name_failure(void **state);
+void test_cbt_util_set_no_command_failure(void **state);
+void test_cbt_util_set_malloc_failure(void **state);
+void test_cbt_util_set_no_data_failure(void **state);
+void test_cbt_util_set_no_file_failure(void **state);
+
+
 /* 'cbt-util create' tests */
 void test_cbt_util_create_success(void **state);
 void test_cbt_util_create_file_open_failure(void **state);
@@ -106,6 +122,22 @@ static const struct CMUnitTest cbt_command_tests[] = {
 	cmocka_unit_test(test_help_success)
 };
 
+static const struct CMUnitTest cbt_set_tests[] = {
+	cmocka_unit_test(test_cbt_util_set_parent),
+	cmocka_unit_test(test_cbt_util_set_child),
+	cmocka_unit_test(test_cbt_util_set_flag),
+	cmocka_unit_test(test_cbt_util_set_size),
+	cmocka_unit_test(test_cbt_util_set_size_smaller_file_failure),
+	cmocka_unit_test(test_cbt_util_set_size_malloc_failure),
+	cmocka_unit_test(test_cbt_util_set_size_no_bitmap_failure),
+	cmocka_unit_test(test_cbt_util_set_size_write_failure),
+	cmocka_unit_test(test_cbt_util_set_no_name_failure),
+	cmocka_unit_test(test_cbt_util_set_no_command_failure),
+	cmocka_unit_test(test_cbt_util_set_malloc_failure),
+	cmocka_unit_test(test_cbt_util_set_no_data_failure),
+	cmocka_unit_test(test_cbt_util_set_no_file_failure)
+};
+
 static const struct CMUnitTest cbt_get_tests[] = {
 	cmocka_unit_test(test_cbt_util_get_flag),
 	cmocka_unit_test(test_cbt_util_get_parent),
diff --git a/mockatests/wrappers/wrappers.c b/mockatests/wrappers/wrappers.c
index c7a506d..0b47b8a 100644
--- a/mockatests/wrappers/wrappers.c
+++ b/mockatests/wrappers/wrappers.c
@@ -42,6 +42,7 @@
 static int tests_running = 1;
 static int mock_malloc = 0;
 static int mock_fwrite = 0;
+static int mock_vprintf = 0;
 
 void *
 __wrap_malloc(size_t size)
@@ -50,7 +51,6 @@ __wrap_malloc(size_t size)
 	if (mock_malloc) {
 		succeed = (bool) mock();
 	}
-
 	if (succeed) {
 		void * result = test_malloc(size);
 		/*fprintf(stderr, "Allocated block of %zu bytes at %p\n", size, result);*/
@@ -70,7 +70,6 @@ FILE *
 __wrap_fopen(void)
 {
 	FILE *file = (FILE*)mock();
-
 	if (file == NULL) {
 		errno = ENOENT;
 	}
@@ -142,18 +141,18 @@ void free_fwrite_data(struct fwrite_data *data)
 int
 wrap_vprintf(const char *format, va_list ap)
 {
-
-	struct printf_data *data = mock();
-
-	int remaining = data->size - data->offset;
-
-	int len = vsnprintf(data->buf + data->offset, remaining, format, ap);
-
-	assert_in_range(len, 0, remaining);
-
-	data->offset += len;
-
-	return len;
+	if (mock_vprintf) {
+		struct printf_data *data = mock();
+		int remaining = data->size - data->offset;
+		int len = vsnprintf(data->buf + data->offset, remaining, format, ap);
+		assert_in_range(len, 0, remaining);
+		data->offset += len;
+		return len;
+	} else {
+		fprintf(stderr, "Unexpected call to printf\n");
+		vfprintf(stderr, format, ap);
+	}
+	return 0;
 }
 
 int
@@ -195,6 +194,8 @@ struct printf_data *setup_vprintf_mock(int size)
 
 	will_return_always(wrap_vprintf, data);
 
+	mock_vprintf = 1;
+
 	return data;
 }
 
@@ -203,6 +204,7 @@ void free_printf_data(struct printf_data *data)
 	if (data->buf)
 		test_free(data->buf);
 	test_free(data);
+	mock_vprintf = 0;
 }
 
 
